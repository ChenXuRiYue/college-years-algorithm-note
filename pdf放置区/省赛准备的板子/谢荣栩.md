[TOC]



#### 1 . bsgs

```cpp
#include<iostream>
#include<unordered_map>
#include<map>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
ll qmi(ll a, ll b, ll c) {
    if(b==0)
        return 1%c;
    ll ans=1,t=a;
    while(b>0) {
       if(b%2==1) ans=ans*t%c;
       b/=2; t=t*t%c;
    }
    return ans;
}
ll bsgs(ll a,ll b,ll m,ll k=1)
{
    b%=m;
    static map<ll,ll>hs;
    hs.clear();
    ll cur=1,t=sqrt(m)+1;
    for(int B=1;B<=t;++B)
    {
        (cur*=a)%=m;
        hs[b*cur%m]=B;
    }
    ll now=qmi(a,t,m);
    if(!now)return b==0?1:-1;
    for(int A=1;A<=t;++A)
    {
        auto it=hs.find(now);
        if(it!=hs.end())
        {
            return A*t-it->second;
        }
        (now*=cur)%=m;
    }
    return -1;
}

void solve()
{
    int y,z,p;
    cin>>p>>y>>z;
    ll ans=bsgs(y,z,p);
    if(ans==-1)cout<<"Orz, I cannot find x!\n";
    else cout<<ans<<'\n';
}

int main()
{
    solve();
}
```

#### 2.  CF242E

```cpp
#include<iostream>
using namespace std;
#define int long long
const int N=1e5+10;

int u[N<<2][25];
int mark[N<<2];
int n,m;
int a[N];

void push_down(int p,int len)
{
    if(len<=1)return;
    for(int i=0;i<=20;i++)
    {
        // if(mark[p][i]==1)
        // {
        //     u[p<<1][i]=(len-len/2)-u[p<<1][i];
        //     u[p<<1|1][i]=(len/2)-u[p<<1|1][i];
        //     mark[p<<1][i]^=mark[p][i];
        //     mark[p<<1|1][i]^=mark[p][i];
        //     mark[p][i]=0;
        // }
        if((mark[p]>>i)&1)
        {
            u[p<<1][i]=(len-len/2)-u[p<<1][i];
            u[p<<1|1][i]=(len/2)-u[p<<1|1][i];
        }
    }
    mark[p<<1]^=mark[p];
    mark[p<<1|1]^=mark[p];
    mark[p]=0;
}

void build(int p=1,int cl=1,int cr=n)
{
    if(cl==cr)
    {
        for(int i=0;i<=20;i++)
        {
            if((a[cl]>>i)&1)u[p][i]=1;
        }
        return;
    }
    int mid=(cl+cr)>>1;
    build(p<<1,cl,mid);
    build(p<<1|1,mid+1,cr);
    for(int i=0;i<=20;i++)
    {
        u[p][i]=u[p<<1][i]+u[p<<1|1][i];
    }
}

void update(int l,int r,int d,int p=1,int cl=1,int cr=n)
{
    if(cl>=l&&cr<=r)
    {
        mark[p]^=d;
        for(int i=0;i<=20;i++)
        {
            if((d>>i)&1)u[p][i]=(cr-cl+1)-u[p][i];
        }
        return;
    }
    push_down(p,cr-cl+1);
    int mid=(cl+cr)>>1;
    if(mid>=l)update(l,r,d,p<<1,cl,mid);
    if(mid<r)update(l,r,d,p<<1|1,mid+1,cr);
    for(int i=0;i<=20;i++)
    {
        u[p][i]=u[p<<1][i]+u[p<<1|1][i];
    }
}

int query(int l,int r,int p=1,int cl=1,int cr=n)
{
    if(cl>=l&&cr<=r)
    {
        int res=0;
        for(int i=0;i<=20;i++)
        {
            res+=(1<<i)*u[p][i];
        }
        return res;
    }
    push_down(p,cr-cl+1);
    int mid=(cl+cr)>>1,ans=0;
    if(mid>=l)ans=(ans+query(l,r,p<<1,cl,mid));
    if(mid<r)ans=(ans+query(l,r,p<<1|1,mid+1,cr));
    return ans;
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    build();
    cin>>m;
    while(m--)
    {
        char o;
        int l,r;
        cin>>o>>l>>r;
        if(o=='1'){
            cout<<query(l,r)<<'\n';
        }
        else{
            int d;
            cin>>d;
            update(l,r,d);
        }
    }
    return 0;
}
```



####  3 . duijiaoshuai 

```cpp
#include<iostream>
using namespace std;
#define ll long long
const int N=1e6+10;
ll sumu[N];
ll Smu[N];
ll sump[N];
ll Sphi[N];

inline ll GetSumu(int n) {
  if(n <= N) return sumu[n]; // sumu是提前筛好的前缀和
  if(Smu[n]) return Smu[n]; // 记忆化
  ll ret = 1ll; // 单位元的前缀和就是 1
  for(int l = 2, r; l <= n; l = r + 1) {
    r = n / (n / l); ret -= (r - l + 1) * GetSumu(n / l);
    // (r - l + 1) 就是 I 在 [l, r] 的和
  } return Smu[n] = ret; // 记忆化
}

inline ll GetSphi(int n) {
  if(n <= N) return sump[n]; // 提前筛好的
  if(Sphi[n]) return Sphi[n]; // 记忆化
  ll ret = 1ll * n * (n + 1) / 2; // f * g = id 的前缀和
  for(int l = 2, r; l <= n; l = r + 1) {
    r = n / (n / l); ret -= (r - l + 1) * GetSphi(n / l);
    // 同上，因为两个的 g 都是 I 
  } return Sphi[n] = ret; // 记忆化
}

int main()
{
}
```



#### 4 exbsgs

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<unordered_map>
#include<map>
using namespace std;
#define ll long long

ll a,b,m;

ll qmi(ll a, ll b, ll c) {
    if(b==0)
        return 1%c;
    ll ans=1,t=a;
    while(b>0) {
       if(b%2==1) ans=ans*t%c;
       b/=2; t=t*t%c;
    }
    return ans;
}

ll gcd(ll a,ll b)
{
    if(b)while((a%=b)&&(b%=a));
    return a+b;
}

ll bsgs(ll a,ll b,ll m,ll k=1)
{
    b%=m;
    static map<ll,ll>hs;
    hs.clear();
    ll cur=1,t=sqrt(m)+1;
    for(int B=1;B<=t;++B)
    {
        (cur*=a)%=m;
        hs[b*cur%m]=B;
    }
    ll now=qmi(a,t,m);
    if(!now)return b==0?1:-1;
    for(int A=1;A<=t;++A)
    {
        auto it=hs.find(now);
        if(it!=hs.end())
        {
            return A*t-it->second;
        }
        (now*=cur)%=m;
    }
    return -1;
}

ll exbsgs(ll a,ll b,ll m,ll k=1)
{
    ll A=a%=m,B=b%=m,M=m;
    if(b==1)return 0;
    ll cur=1%m;
    for(int i=0;;i++)
    {
        if(cur==B)return i;
        cur=cur*A%M;
        ll d=gcd(a,m);
        if(b%d)return -1;
        if(d==1)return bsgs(a,b,m,k*a%m)+i-1;
        k=k*a/d%m,b/=d,m/=d;
    }
}

int main()
{
    ll a,b,m;
    while(cin>>a>>m>>b)
    {
        if(a==0&&b==0&&m==0)
            return 0;
        ll ans=exbsgs(a,b,m);
        if(ans==-1)cout<<"no solution\n";
        else cout<<ans<<'\n';
    }
}
```

----

#### excrt.cpp

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
ll a[100010],b[100010];
ll maxn;
int n,m;
ll mul(ll a,ll b,ll m)
{
    ll res=0;
    while(b)
    {
        if(b&1)res=(a+res)%m;
        a=(a+a)%m;
        b>>=1;
    }
    return res;
}
 
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    ll d=exgcd(b,a%b,x,y);
    ll t=x;
    x=y;
    y=t-a/b*y;
    return d;
}
 
ll excrt()
{
    ll x,y,k;
    ll ans=a[1],M=b[1];
    for(int i=2;i<=n;i++)
    {
        ll ai=M,bi=b[i],c=(a[i]-ans%bi+bi)%bi;
        ll g=exgcd(ai,bi,x,y),f=bi/g;
        if(c%g!=0)
        {
            return -1;
        }
        x=mul(x,c/g,f);
        ans+=x*M;
        M*=f;
        ans=(ans%M+M)%M;
    }
    return (ans%M+M)%M;
}
 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>b[i]>>a[i];
    cout<<excrt()<<'\n';
    return 0;
}
```

----

#### 5. exlucas

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
#ifdef Fading
#define gc getchar
#endif
void exgcd(ll a,ll b,ll &x,ll &y){
    if (!b) return (void)(x=1,y=0);
    exgcd(b,a%b,x,y);
    ll tmp=x;x=y;y=tmp-a/b*y;
}
ll gcd(ll a,ll b){
    if (b==0) return a;
    return gcd(b,a%b); 
}
inline ll INV(ll a,ll p){
    ll x,y;
    exgcd(a,p,x,y);
    return (x+p)%p;
}
inline ll lcm(ll a,ll b){
    return a/gcd(a,b)*b;
}
inline ll mabs(ll x){
    return (x>0?x:-x);
}
inline ll fast_mul(ll a,ll b,ll p){
    ll t=0;a%=p;b%=p;
    while (b){
        if (b&1LL) t=(t+a)%p;
        b>>=1LL;a=(a+a)%p;
    }
    return t;
}
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1LL) t=(t*a)%p;
        b>>=1LL;a=(a*a)%p;
    }
    return t;
}
inline ll read(){
    ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
    while (isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
inline ll F(ll n,ll P,ll PK){
    if (n==0) return 1;
    ll rou=1;//循环节
    ll rem=1;//余项 
    for (ll i=1;i<=PK;i++){
        if (i%P) rou=rou*i%PK;
    }
    rou=fast_pow(rou,n/PK,PK);
    for (ll i=PK*(n/PK);i<=n;i++){
        if (i%P) rem=rem*(i%PK)%PK;
    }
    return F(n/P,P,PK)*rou%PK*rem%PK;
}
inline ll G(ll n,ll P){
    if (n<P) return 0;
    return G(n/P,P)+(n/P);
}
inline ll C_PK(ll n,ll m,ll P,ll PK){
    ll fz=F(n,P,PK),fm1=INV(F(m,P,PK),PK),fm2=INV(F(n-m,P,PK),PK);
    ll mi=fast_pow(P,G(n,P)-G(m,P)-G(n-m,P),PK);
    return fz*fm1%PK*fm2%PK*mi%PK;
}
ll A[1001],B[1001];
//x=B(mod A)
inline ll exLucas(ll n,ll m,ll P){
    ll ljc=P,tot=0;
    for (ll tmp=2;tmp*tmp<=P;tmp++){
        if (!(ljc%tmp)){
            ll PK=1;
            while (!(ljc%tmp)){
                PK*=tmp;ljc/=tmp;
            }
            A[++tot]=PK;B[tot]=C_PK(n,m,tmp,PK);
        }
    }
    if (ljc!=1){
        A[++tot]=ljc;B[tot]=C_PK(n,m,ljc,ljc);
    }
    ll ans=0;
    for (ll i=1;i<=tot;i++){
        ll M=P/A[i],T=INV(M,A[i]);
        ans=(ans+B[i]*M%P*T%P)%P;
    }
    return ans;
}
signed main(){
    ll n=read(),m=read(),P=read();
    printf("%lld\n",exLucas(n,m,P));
    return 0;
}

```



---

#### 6. fft

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;

const ll N=5000010;
const double pi=acos(-1);
string s;
ll n,m,limit,c[N];
struct complex{
    double real,imag;
    complex(double X=0,double Y=0){real=X; imag=Y;}
}a[N],b[N];
inline complex operator +(complex a,complex b)
{
    return complex(a.real+b.real,a.imag+b.imag);
}

inline complex operator -(complex a,complex b)
{
    return complex(a.real-b.real,a.imag-b.imag);
}

inline complex operator *(complex a,complex b)
{
    return complex(a.real*b.real-a.imag*b.imag,a.real*b.imag+a.imag*b.real);
}

void FFT(complex *a,ll op){
    for(ll i=0; i<limit; i++){
        if(i<c[i]) swap(a[i],a[c[i]]);
    }
    for(ll mid=1; mid<limit; mid<<=1){
        complex W(cos(pi/mid),op*sin(pi/mid));
        for(ll r=mid<<1,j=0; j<limit; j+=r){
            complex w(1,0);
            for(ll l=0; l<mid; l++,w=w*W){
                complex x=a[j+l],y=w*a[j+mid+l];
                a[j+l]=x+y; a[j+mid+l]=x-y;
            }
        }
    }
}

void IFFT(complex *A, int N) {
  FFT(A, n);
  reverse(A + 1, A + N);
}

int main(){
    ios::sync_with_stdio(0); 
    int n;
    cin>>n;
    n--;
    for(ll i=0; i<=n; i++){
        int u;
        cin>>u;
        b[n-i].real=a[n-i].real=u;
    } 
    limit=1; ll l=0;
    while(limit<=n*2){
        limit<<=1;
        l++;
    }
    for(ll i=0; i<limit; i++) c[i]=(c[i>>1]>>1)|((i&1)<<(l-1));
    FFT(a,1); FFT(b,1);
    for(ll i=0; i<=limit; i++) a[i]=a[i]*b[i];
    FFT(a,-1);
    //上面是fft的模板
    ll ans=1;
    memset(c,0,sizeof(c));
    for(ll i=0;i<=n*2+1;i++)c[i]=a[i].real/limit+0.5;
    
    for(int i=0;i<=n*2;i++)
    {
        if(c[i]<0)ans*=-1;
        else if(c[i]==0)
        {
            cout<<"woc nong"<<'\n';
            return 0;
        }
    }
    if(ans==1)
    {
        cout<<"woc yuan"<<'\n';
    }
    else {
        cout<<"woc zhou"<<'\n';
    }
}
```

----

#### 7.  fzfft

```cpp
//还没行
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxlogn=18;
const int maxn=(1<<maxlogn)|1;
const int G0=15311432;
const int kcz=998244353;
int n,rev[maxn];
ll G[2][24],f[maxn],g[maxn],a[maxn],b[maxn];
void gcd(ll a,ll b,ll &x,ll &y)
{
    if(!b) x=1,y=0;
    else gcd(b,a%b,y,x),y-=x*(a/b);
}
inline ll inv(ll a)
{
    ll x,y;
    gcd(a,kcz,x,y);
    return (x+kcz)%kcz;
}
inline void calcrev(int logn)
{
    register int i;
    rev[0]=0;
    for(i=1;i<(1<<logn);i++)
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(logn-1));
}
inline void FFT(ll *a,int logn,int flag)
{
    register int i,j,k,mid;
    register ll t1,t2,t;
    for(i=0;i<(1<<logn);i++)
        if(rev[i]<i)
            swap(a[rev[i]],a[i]);
    for(i=1;i<=logn;i++)
        for(mid=1<<(i-1),j=0;j<(1<<logn);j+=1<<i)
            for(k=0,t=1;k<mid;k++,t=t*G[flag][i]%kcz)
            {
                t1=a[j|k],t2=t*a[j|k|mid];
                a[j|k]=(t1+t2)%kcz,a[j|k|mid]=(t1-t2)%kcz;
            }
}
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    // 可能你会注意到，这个卷积是(r-l)/2的长度卷一个r-l的长度，而我卷积时最终结果当作r-l的长度来存，这会不会有影响？注意到超出部分是(r-l)/2左右，根据fft的实现，超出部分是会重新从0开始填的，所以只会影响结果的前半段，与后半段无关
    solve(mid,r,logn-1); // 计算右区间
}
int main()
{
    int logn,i;
    G[1][23]=inv(G[0][23]=G0);
    for(i=22;i>=0;i--)
    {
        G[0][i]=G[0][i+1]*G[0][i+1]%kcz;
        G[1][i]=G[1][i+1]*G[1][i+1]%kcz;
    }
    scanf("%d",&n);
    for(logn=0;(1<<logn)<n;logn++);
    for(i=1;i<n;i++) scanf("%lld",&g[i]);
    for(i=0;i<n;i++) f[i]=!i;
    solve(0,1<<logn,logn);
    for(i=0;i<n;i++)
        printf("%lld ",(f[i]+kcz)%kcz);
    printf("\n");
    return 0;
}
```

#### 8. gcdt

```cpp
//GCD table
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e4 + 10;

int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int nx, ny;
    int d = exgcd(b, a % b, nx, ny);
    x = ny;
    y = nx - a / b * ny;
    return d;
}

int lcm(int a, int b) { return a / __gcd(a, b) * b; }

pair<int, int> excrt(int k, int *a, int *r) {
    int M = r[1], ans = a[1];
    for (int i = 2; i <= k; i++) {
        int x0, y0;
        int c = a[i] - ans;
        int g = exgcd(M, r[i], x0, y0);
        if (c % g != 0) return {-1, -1};
        x0 = (__int128)x0 * (c / g) % (r[i] / g);
        ans = x0 * M + ans;
        M = lcm(M, r[i]);
        ans = (ans % M + M) % M;
    }
    return {ans, M};
}

int n, m, k, a[N];
int b[N];
signed main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= k; i++) cin >> a[i], b[i] = -(i - 1);

    pair<int, int> x = excrt(k, b, a);
    if (x.first == 0) x.first = x.second;

    if (x.first > m - k + 1 || x.second > n || x.first == -1) {
        cout << "NO";
    } else {
        for (int i = 0; i < k; i++)
            if (__gcd(x.first + i, x.second) != a[i + 1]) {
                cout << "NO";
                return 0;
            }
        cout << "YES";
    }
    return 0;
}
```

----

#### 9.  juzhenmul

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int N=3;
long long f[N+1],a[N+1][N+1];
long long n,m;

void fa()
{
    long long w[N+1];
    memset(w,0,sizeof(w));
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            w[i]+=f[j]*a[j][i];
            w[i]%=m;
        }
    }
    memcpy(f,w,sizeof(f));
}

void aa()
{
    long long w[N+1][N+1];
    memset(w,0,sizeof(w));
    for(int i=1;i<=3;i++)
    {
        for(int k=1;k<=3;k++)
        if(a[i][k])
        for(int j=1;j<=3;j++)
        {
            if(a[k][j])w[i][j]=(w[i][j]+a[i][k]*a[k][j])%m;
        }
    }
    memcpy(a,w,sizeof(a));
}

void ksm(long long n)
{
    while(n)
    {
        if(n&1)fa();
        aa();
        n>>=1;
    }
}

int main()
{
     
}
```

-----

####  10 . moblus

```cpp
#include<iostream>
using namespace std;
const int N=1e7+10;
bool st[N];
int p[N];
int mu[N];
int cnt;
void get_mu()
{
    for(int i=2;i<=N-10;i++)
    {
        if(!st[i])p[cnt++]=i,mu[i]=-1;
        for(int j=0;j<cnt&&i*p[j]<=N-10;j++)
        {
            st[i*p[j]]=1;
            if(i%p[j]==0)
            {
                mu[i*p[j]]=0;
                break;
            }
            else mu[i*p[j]]=-mu[i];
        }
    }
}

int main()
{
    get_mu();
}
```





#### 11 ntt

```cpp
//ntt
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin), p1 == p2) ? EOF : *p1++)
#define swap(x,y) x ^= y, y ^= x, x ^= y
#define LL long long 
const int MAXN = 3 * 1e6 + 10, P = 998244353, G = 3, Gi = 332748118; 
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read() { 
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, M, limit = 1, L, r[MAXN];
LL a[MAXN], b[MAXN];
LL qmi(LL a, LL k) {
	LL base = 1;
	while(k) {
		if(k & 1) base = (base * a ) % P;
		a = (a * a) % P;
		k >>= 1;
	}
	return base % P;
}
void NTT(LL *A, int type) {
	for(int i = 0; i < limit; i++) 
		if(i < r[i]) swap(A[i], A[r[i]]);
	for(int mid = 1; mid < limit; mid <<= 1) {	
		LL Wn = qmi( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0; j < limit; j += (mid << 1)) {
			LL w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P) {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
}
int main() {
	N = read(); M = read();
	for(int i = 0; i <= N; i++) a[i] = (read() + P) % P;
	for(int i = 0; i <= M; i++) b[i] = (read() + P) % P;
	while(limit <= N + M) limit <<= 1, L++;
	for(int i = 0; i < limit; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));	
	NTT(a, 1);NTT(b, 1);	
	for(int i = 0; i < limit; i++) a[i] = (a[i] * b[i]) % P;
	NTT(a, -1);	
	LL inv = qmi(limit, P - 2);
	for(int i = 0; i <= N + M; i++)
		printf("%d ", (a[i] * inv) % P);
	return 0;
}
```

----

#### 12. oljm

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 10;

int power(int a, int b, int mod) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int f(int n) {	// 求n的欧拉函数
    int res = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            res = res / i * (i - 1);
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) res = res / n * (n - 1);
    return res;
}

int b, n, c;
string str_b, str_n;

signed main() {
    cin >> str_b >> str_n >> c;

    for (int i = 0; i < str_b.size(); i++) b = (b * 10 + (str_b[i] - '0')) % c;

    int phi_c = f(c);
    bool k = false;
    for (int i = 0; i < str_n.size(); i++) {
        n = n * 10 + (str_n[i] - '0');
        if (n - 1 >= phi_c) n %= phi_c, k = true;
    }
    n--;
    if (k) n += phi_c;
    int res = (b - 1 + c) % c * power(b, n, c) % c;
    if (!res) res = c;
    cout << res;
    
    return 0;
}
```

----

#### 13. p3747

```cpp
//相逢是问候
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define int long long
const int N=5e4+10,b1=2e4;
int a[N],cnt[N<<2],c1[60][N],c2[60][N];
int n,m,c,mod,phi[N];
int num[N],d[N],c3[N],c4,b[N][20],sum[N<<2];

void upt(int &x,int y)
{
    x=y;
    if(x>=mod)x-=mod;
}

int cphi(int x)
{
    int s=sqrt(x),res=x,i;
    for(i=2;i<=s;i++)
    {
        if(x%i==0)
        {
            while(x%i==0)x/=i;
            res/=i;
            res*=i-1;
        }
    }
    if(x>1)res/=x,res*=x-1;
    return res;
}

void init()
{
    d[d[0]=1]=mod;
    while(1)
    {
        d[0]++;
        d[d[0]]=cphi(d[d[0]-1]);
        if(d[d[0]]==1)break;
    }
    reverse(d+1,d+d[0]+1);
    int i,j;
    int y=1;
    c3[0]=1;
    for(i=1;i<b1;i++)
    {
        if(y<=1e8)
        {
            y=y*c;
            c3[i]=y;
            if(y<=1e8)c4=i;
        }
        else break;
    }
    for(i=1;i<=d[0];i++)
    {
        c1[i][0]=c2[i][0]=1;
        for(j=1;j<b1;j++)c2[i][j]=c2[i][j-1]*c%d[i];
        c1[i][1]=c2[i][b1-1]*c%d[i];
        for(j=2;j<b1;j++)c1[i][j]=c1[i][j-1]*c1[i][1]%d[i];
    }
    for(i=1;i<=n;i++)
    {
        b[i][0]=a[i];
        for(j=1;j<6;j++)
        {
            int x=b[i][j-1],p1=x/b1,p0=x%b1;
            if(c3[p0]>1e8||p1||p0>c4)break;
            b[i][j]=c3[p0];
            num[i]=j;
        }
    }
}

int qmi(int y,int p)
{
    return c1[p][y/b1]*c2[p][y%b1]%d[p];
}

int f(int i,int j,int mod)
{
    if(mod==1)return 0;
    if(j==0)return a[i]%d[mod];
    if(c==1||(c!=1&&j-1<=num[i]&&b[i][j-1]<d[mod-1]))
    {
        return qmi(f(i,j-1,mod-1),mod);
    }
    else return qmi(f(i,j-1,mod-1)+d[mod-1],mod);
}

void up(int p)
{
    cnt[p]=min(cnt[p<<1],cnt[p<<1|1]);
    upt(sum[p],sum[p<<1]+sum[p<<1|1]);
}

void build(int l,int r,int p)
{
    if(l==r)
    {
        sum[p]=a[l];
        return;
    }
    int mid=l+r>>1;
    build(l,mid,p<<1);
    build(mid+1,r,p<<1|1);
    up(p);
}

void update(int l,int r,int cl,int cr,int p)
{
    if(cnt[p]>d[0])return;
    if(l==r)
    {
        cnt[p]++;
        sum[p]=f(l,cnt[p],d[0]);
        return;
    }
    int mid=l+r>>1;
    if(cl<=mid)update(l, mid, cl, cr, p<<1);
    if(cr>mid)update(mid+1,r,cl,cr,p<<1|1);
    up(p);
}

int query(int l,int r,int cl,int cr,int p)
{
    if(l==cl&&r==cr)return sum[p];
    int mid=l+r>>1,res=0;
    if(cr<=mid)res=query(l,mid,cl,cr,p<<1);
    else if(cl>mid)res=query(mid+1,r,cl,cr,p<<1|1);
    else upt(res,query(l,mid,cl,mid,p<<1)+query(mid+1,r,mid+1,cr,p<<1|1));
    return res;
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>mod>>c;
	int i, opt, l, r;
	for (i = 1; i <= n; ++i) cin>>a[i];
	init();
	build(1, n, 1);
	while (m--)
	{
        cin>>opt>>l>>r;
		if (!opt) update(1, n, l, r, 1);
		else printf("%d\n", query(1, n, l, r, 1));
	}
}
```

---



#### 14 p4884

```cpp
#include<iostream>
#include<unordered_map>
#include<map>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
ll qmi(ll a, ll b, ll c) {
    if(b==0)
        return 1%c;
    ll ans=1,t=a;
    while(b>0) {
       if(b%2==1) ans=ans*t%c;
       b/=2; t=t*t%c;
    }
    return ans;
}
ll bsgs(ll a,ll b,ll m,ll k=1)
{
    b%=m;
    static map<ll,ll>hs;
    hs.clear();
    ll cur=1,t=sqrt(m)+1;
    for(int B=1;B<=t;++B)
    {
        (cur*=a)%=m;
        hs[b*cur%m]=B;
    }
    ll now=qmi(a,t,m);
    if(!now)return b==0?1:-1;
    for(int A=1;A<=t;++A)
    {
        auto it=hs.find(now);
        if(it!=hs.end())
        {
            return A*t-it->second;
        }
        (now*=cur)%=m;
    }
    return -1;
}

ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    ll d=exgcd(b,a%b,x,y);
    ll t=x;
    x=y;
    y=t-a/b*y;
    return d;
}
int t,k;
void solve()
{
    int y,z,p;
    cin>>p>>y>>z;
    ll ans=bsgs(y,z,p);
    if(ans==-1)cout<<"Orz, I cannot find x!\n";
    else cout<<ans<<'\n';
}

int main()
{
    solve();
}
```



#### 15 qaq

```cpp
#include<iostream>
using namespace std;
#define int long long
int fac[100010];
int fnv[100010];
const int mod=999911659;
int mul(int a,int b,int m)
{
    int res=0;
    while(b)
    {
        if(b&1)res=(a+res)%m;
        a=(a+a)%m;
        b>>=1;
    }
    return res;
}
int qmi(int a, int k, int p)
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a,int b,int p)
{
    return fac[a]*fnv[b]%p*fnv[a-b]%p;
}

int lucas(int a, int b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

void init(int p)
{
    fac[0]=1,fnv[0]=1;
    for(int i=1;i<=100000;i++)
    {
        fac[i]=fac[i-1]*i;
        fnv[i]=qmi(fac[i],p-2,p);
    }
}

int n,m;
int cnt;
int a[100010],b[100010];

int excrt()
{
    int d=0,p=mod-1;
    for(int i=0;i<cnt;i++)
    {
        int m=p/b[i];
        int x=0,y=0;
        exgcd(m,b[i],x,y);
        d=(d+a[i]*m*(x<0?x+b[i]:x)%p)%p;
    }
    return (d%p+p)%p;
}

signed main()
{
    cin>>n>>m;
    if(m%mod==0)
    {
        cout<<0<<'\n';
        return 0;
    }
    int u=mod-1,d=mod-1;
    for(int i=2;i<=u;i++)if(u%i==0){
        b[cnt++]=i,u/=i;
    }
    int ans=0;
    for(int i=0;i<cnt;i++)
    {
        init(b[i]);
        for(int j=1;j*j<=n;j++)
        {
            if(n%j==0)
            {
                a[i]=(a[i]+lucas(n,j,b[i]))%b[i];
                if(j!=n/j)
                {
                    a[i]=(a[i]+lucas(n,n/j,b[i]))%b[i];
                }
            }
        }
    }
    ans=excrt()%mod;
    cout<<qmi(m,ans,mod)<<'\n';
}
```

-----

#### 16.  tongyu

```cpp
#include<iostream>
using namespace std;
#define int long long
int exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

void solve()
{
    int a,b;
    cin>>a>>b;
    int x,y;
    int g=exgcd(a,b,x,y);
    //ax ≡ 1(mod b)
    if(g!=1)cout<<-1<<'\n';
    else cout<<(x%b+b)%b<<'\n';
    //ax ≡ n(mod b) 其中n>1
    //else cout<<cout<<((q*(y/d))%(e/d)+(e/d))%(e/d);
}

signed main()
{
    int t;
    cin>>t;
    while(t--)solve();
}
```

----

#### 17. tongyu

```cpp
#include<iostream>
using namespace std;
#define int long long
int exgcd(int a,int b,int &x,int &y)
{
    if(!b)
    {
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return d;
}

void solve()
{
    int a,b;
    cin>>a>>b;
    int x,y;
    int g=exgcd(a,b,x,y);
    //ax ≡ 1(mod b)
    if(g!=1)cout<<-1<<'\n';
    else cout<<(x%b+b)%b<<'\n';
    //ax ≡ n(mod b) 其中n>1
    //else cout<<cout<<((q*(y/d))%(e/d)+(e/d))%(e/d);
}

signed main()
{
    int t;
    cin>>t;
    while(t--)solve();
}
```



#### 18 xianduanshu

```cpp
#include<iostream>
using namespace std;
#define int long long
const int N=2e5+10;

struct node
{
    int val;
}u[N<<2];
int mark[N<<2];
int n,m,mod;
int a[N];
int mark1[N<<2];

void push_down(int p,int len)
{
    if(len<=1)return;
    u[p<<1].val+=mark[p]*(len-len/2);
    u[p<<1|1].val+=mark[p]*(len/2);
    mark[p<<1]+=mark[p];
    mark[p<<1|1]+=mark[p];
    mark[p]=0;
}

void build(int p=1,int cl=1,int cr=n)
{
    mark1[p]=1;
    mark[p]=0;
    if(cl==cr)
    {
        u[p].val=a[cl];
        return;
    }
    int mid=(cl+cr)>>1;
    build(p<<1,cl,mid);
    build(p<<1|1,mid+1,cr);
    u[p].val=(u[p<<1].val+u[p<<1|1].val);
}

void update(int l,int r,int d,int p=1,int cl=1,int cr=n)
{
    if(cl>=l&&cr<=r)
    {
        u[p].val=u[p].val+d*(cr-cl+1),mark[p]=mark[p]+d;
        return;
    }
    push_down(p,cr-cl+1);
    int mid=(cl+cr)>>1;
    if(mid>=l)update(l,r,d,p<<1,cl,mid);
    if(mid<r)update(l,r,d,p<<1|1,mid+1,cr);
    u[p].val=u[p<<1].val+u[p<<1|1].val;
}


void update1(int l,int r,int d,int p=1,int cl=1,int cr=n)
{
    if(cl>=l&&cr<=r)
    {
        u[p].val=u[p].val*d%mod;
        mark1[p]=mark1[p]*d%mod;
        mark[p]=mark[p]*d%mod;
        return;
    }
    push_down(p,cr-cl+1);
    int mid=(cl+cr)>>1;
    if(mid>=l)update1(l,r,d,p<<1,cl,mid);
    if(mid<r)update1(l,r,d,p<<1|1,mid+1,cr);
    u[p].val=(u[p<<1].val+u[p<<1|1].val)%mod;
}

// int query(int l,int r,int p=1,int cl=1,int cr=n)
// {
//     if(cl>=l&&cr<=r)return u[p].val;
//     push_down(p,cr-cl+1);
//     int mid=(cl+cr)>>1,ans=0;
//     if(mid>=l)ans=(ans+query(l,r,p<<1,cl,mid))%mod;
//     if(mid<r)ans=(ans+query(l,r,p<<1|1,mid+1,cr))%mod;
//     return ans;
// }

int query(int pos,int p=1,int cl=1,int cr=n)
{
    if(cl==cr&&pos==cl)
    {
        return u[p].val;
    }
    push_down(p,cr-cl+1);
    int mid=(cl+cr)>>1,ans=0;
    if(mid>=pos)return query(pos,p<<1,cl,mid);
    else return query(pos,p<<1|1,mid+1,cr);
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    build();
    while(m--)
    {
        char o;
        int l,r;
        cin>>o;
        if(o=='1'){
            cin>>l>>r;
            update(l,r,1);
        }
        else{
            int d;
            cin>>d;
            cout<<query(d)%2<<'\n';
        }
    }
    return 0;
}
```

---

#### 19. 余数求和

```cpp
#include<iostream>
using namespace std;

int main()
{
    long long n,k;
    cin>>n>>k;
    long long ans=0;
    for(long long i=n;i<=k;i++)
	{
        for(long long l = 1;l <= i;l++)
	    {
            long long d=i/l,r=i/d;
            if(i%d==0)ans+=d;
            l=r;
        }
	}
    cout<<ans<<'\n';
}
```



#### 20. 高斯消元

```cpp

高斯消元，枚举答案
for (int j = 0; j < n; ++j) // 枚举列
{
    int i;
    for (i = j; i < n; ++i) // 找到非0元素
        if (A[i][j])
            break;
    if (A[i][j] == 0) // 无解的情形
    {
        puts("No Solution");
        return 0;
    }
    for (int k = 0; k <= n; ++k) // 把非0元素所在行交换到当前行
        swap(A[i][k], A[j][k]);
    for (int k = n; k >= j; --k) // 把当前行除以A[j][j]，令A[j][j]归一，注意循环顺序
        A[j][k] /= A[j][j];
    for (int i = 0; i < n; ++i) // 对其他行消元
        if (i != j)
            for (int k = n; k >= j; --k) // 注意循环顺序
                A[i][k] -= A[j][k] * A[i][j];
}


高斯消元，把n行m列的矩阵化为行最简矩阵
for (int j = 0; j < m; ++j) // 枚举列
{
    int i;
    for (i = curi; i < n; ++i) // 找到非0元素
        if (A[i][j])
            break;
    if (A[i][j] == 0)
        continue;
    for (int k = 0; k < m; ++k) // 把非0元素所在行交换到当前行
        swap(A[i][k], A[curi][k]);
    for (int k = m - 1; k >= j; --k) // 把当前行都除以A[curi][j]，令A[curi][j]归一，注意循环顺序
        A[curi][k] /= A[curi][j];
    for (int i = 0; i < n; ++i) // 对其他行消元
        if (i != curi)
            for (int k = m - 1; k >= j; --k) // 注意循环顺序
                A[i][k] -= A[curi][k] * A[i][j];
    curi++;
}

```

