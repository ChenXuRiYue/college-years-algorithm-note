[TOC]

#### 虚树

# 虚树

参考博客：
[虚树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/virtual-tree/#过程)

## 引子

虚树其实就是一种树处理算法： 将一颗树简化，保留求解问题资源的同时，删去不必要的资源： 然后减少访问冗余资源（这里的资源就是指一些节点， 以及边）的消耗： 

经典问题
[P2495 [SDOI2011\] 消耗战 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2495)

-----

在一场战争中，战场由 $n$ 个岛屿和 $n-1$ 个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为 $1$ 的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他 $k$ 个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。

侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到 $1$ 号岛屿上）。不过侦查部门还发现了这台机器只能够使用 $m$ 次，所以我们只需要把每次任务完成即可。

**输入格式**

第一行一个整数 $n$，代表岛屿数量。

接下来 n-1 行，每行三个整数 $u,v,w$，代表 $u$ 号岛屿和 $v$ 号岛屿由一条代价为 $c$ 的桥梁直接相连，保证 $1\le u,v\le n$ 且 $1\le c\le 10^5$。

第 $n+1$ 行，一个整数 $m$，代表敌方机器能使用的次数。

接下来 $m$ 行，每行一个整数 $k_i$，代表第 $i$ 次后，有 $k_i$ 个岛屿资源丰富，接下来 $k$ 个整数 $h_1,h_2,\cdots ,h_k$，表示资源丰富岛屿的编号。

**输出格式**

输出有 $m$ 行，分别代表每次任务的最小代价。

**数据范围**

对于 $100\%$ 的数据，$2\le n\le 2.5\times 10^5,m\ge 1,\sum k_i\le 5\times 10^5,1\le k_i\le n-1$。

----

### 对上述问题分析引入虚树：

如果只有一组变化，做一个简单的dp即可；$O(N)$ 的复杂度就可以实现。但是多组变化下，其复杂度为$O(NM)$

考虑每次dp的过程： 

![vtree-3](https://oi-wiki.org/graph/images/vtree-vtree1.svg)

如果当前拥有资源的点是2 , 4.那么遍历3 6 7 5 等子树是没有意义的。提供以下抽象方式：

![vtree-4](https://oi-wiki.org/graph/images/vtree-vtree2.svg)

![vtree-5](https://oi-wiki.org/graph/images/vtree-vtree3.svg)

![vtree-6](https://oi-wiki.org/graph/images/vtree-vtree4.svg)



新出现的边的大小显然是两点之间的最小边：

### 建树细节：

1. 定义关键点：即当前要保留的点：
2. 实现算法 ：
   1. 二次排序 + LCA连边：
   2. 使用单调栈：


### 上述引题的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 3E5 + 10;
int n;
/*虚树：
	1. 建树：
	2. 修改solve代码块，在虚树上解决问题：：
	3. 记录关键点。等等，都是无关的紧要的找开机工作：
	如果手敲板子 ， 敲错了。那么问题可能集中于：
		1. 跳表中，这里小的一端放在第一维度上： 一般习惯上，是将其放在第二维上。有可能会脑子短路把
		这个顺序给搞错。
*/
vector<pair<int, int>> e[N];
/*倍增相关：*/
const int LOGN = 18;
int dep[N], par[LOGN + 1][N], val[LOGN + 1][N];
/*与dfs序相关*/
int l[N], r[N], tot;
void dfs(int u, int fa) {
	l[u] = ++tot;
	dep[u] = dep[fa] + 1;
	for (auto p : e[u]) {
		int v = p.first, w = p.second;
		if (v == fa) continue;
		par[0][v] = u;
		val[0][v] = w;
		dfs(v, u);
	}
	r[u] = tot;
}
void init() {
	dfs(1, 0);
	for (int i = 1; i <= LOGN; i++) {
		for (int u = 1; u <= n; u++) {
			par[i][u] = par[i - 1][par[i - 1][u]];
			val[i][u] = min(val[i - 1][u], val[i - 1][par[i - 1][u]]);
		}
	}
}
int LCA(int u, int v) {
	if (dep[u] > dep[v]) swap(u, v);
	int d = dep[v] - dep[u];
	for (int i = LOGN; i >= 0; i--) {
		if ((1 << i) <= d) {
			d -= (1 << i);
			v = par[i][v];
		}
	}
	if (v == u) return v;
	for (int i = LOGN; i >= 0; i--) {
		if (par[i][v] != par[i][u]) {
			v = par[i][v];
			u = par[i][u];
		}
	}
	return par[0][u];
}
int QueryMinEdge(int u, int v) {
	int ans = 1 << 30;
	if (dep[u] > dep[v]) swap(u, v);
	int d = dep[v] - dep[u];
	for (int i = LOGN; i >= 0; i--) {
		if (d & (1 << i)) {
			ans = min(ans, val[i][v]);
			v = par[i][v];
		}
	}
	if (u == v) return ans;
	for (int i = LOGN; i >= 0; i--) {
		if (par[i][u] != par[i][v]) {
			ans = min({ ans , val[i][u] , val[i][v] });
			u = par[i][u];
			v = par[i][v];
		}
	}
	ans = min({ ans , val[0][u] , val[0][v] });
	return ans;
}
//届时怎么清空数组？
// 虚树：
vector<pair<int, int>> VT[N];
// 给两个点建边：

// 建立虚树代码：
void BuildVirtualTree(vector<int>& key) {
	function<bool(int, int)> cmp = [&](int x, int y) {
		return l[x] < l[y];
	};
	// 加边：
	function<void(int, int)> add = [&](int x, int y) {
		VT[x].push_back({ y , QueryMinEdge(x , y) });
	};
	sort(key.begin(), key.end(), cmp);
	vector<int> a;
	for (int i = 0; i < (int)key.size() - 1; i++) {
		a.push_back(key[i]);
		a.push_back(LCA(key[i], key[i + 1]));
	}
	a.push_back(key.back());
	sort(a.begin(), a.end(), cmp);
	a.erase(unique(a.begin(), a.end()), a.end());
	for (int i = 0, lc; i < (int)a.size() - 1; i++) {
		lc = LCA(a[i], a[i + 1]);
		add(lc, a[i + 1]);
	}
}
// 再在虚树上dp：
ll f[N];
bool rec[N];
void solve(int u) {
	f[u] = 0;
	for (auto p : VT[u]) {
		int v = p.first;
		ll w = p.second;
		solve(v);
		// 说明当下为关键点：
		if (rec[v]) {
			f[u] += w;
		} else {
			f[u] += min(f[v], w);
		}
	}
	VT[u].clear();
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		e[u].push_back({ v , w });
		e[v].push_back({ u , w });
	}
	init();
	// 做一些预处理：
	int m;
	cin >> m;
	for (int __ = 1; __ <= m; __++) {
		int k;
		cin >> k;
		vector<int> Key;
		Key.push_back(1);
		for (int i = 1; i <= k; i++) {
			int u; cin >> u;
			Key.push_back(u);
			/*记录关键点， 配合转移*/
			rec[u] = true;;
		}
		BuildVirtualTree(Key);
		solve(1);
		cout << f[1] << "\n";
		for (auto v : Key) {
			rec[v] = false;
		}
	}
}
```



----

####  李超线段树



# 李超线段树

参考博客：

[算法｜李超线段树初步（算法讲解+例题） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/64946571?utm_id=0)
[李超线段树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/li-chao-tree/)

## 算法介绍：

李超线段树是一种用于维护平面直角坐标系内线段关系得数据结构。它常被用来处理这样一种形式得问题：

> 给定一个平面直角坐标系，支持动态插入一条线段，询问从某个位置（x , +oo）能看到得第一个叫线段（即给定一条竖线x = k ， 问这条竖线于所欲线段得最高得交点。）



### solve

线段树维护每个点得最优势线段：
当插入一个线段时： 有以下几种情况：

对于修改，我们先把线段的值域分割到线段树的区间上，每次访问一个完整的包含在线段值域中的区间时：

1. 若当前区间还没有记录最优势线段，则记录最优势线段并返回。
2. 若当前区间的最优势线段被插入的线段完全覆盖，则把最优势线段修改为被插入线段并返回。
3. 若当前区间的最优势线段把被插入线断完全覆盖，则直接返回。
4. 若当前区间最优势线段与被插入线段有交，则先判断哪条线段在当前区间更优，并把更劣的线段下传到交点所在子区间。（交点两边的部分被这两条线段分别控制，而我们已经让在中点更优的那条线段作为区间最优势线段，因此更劣的那条线段只有可能在交点所在子区间超过当前区间的最优势线段）

### problems：

**板题：**
[P4097 [HEOI2013\] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4097)

**一些细节：**

1. 斜率计算出现了卡精度的问题： 自己定义一个判断大小关系的运算：如下：

```cpp
pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
```

或者重新定义一个比较运算如下：

```cpp
//防止精度问题导致相等关系的误判：
inline int check(double x , double y) {
	if (abs(x - y) < eps) return 0;
	else if (x < y) return -1;
	else return 1;
}
```

2. 直线相关的问题：

   1. 直线类定义：

      ```cpp
      struct line {
      	// 斜率 ， y上得交点纵坐标：
      	double k, b;
      	// 值域
      	int l, r;
      	// 当前节点上是否有纵坐标存在：
      	// 表示当前线段的编号：
      	int id;
           // 当前节点所代表的区间是否有优势直线：
      	int flag;
      } seg[4 * maxn]; //线段树的定义
      ```

      

      

   2. 求斜率：即添加直线时的信息记录：归于add函数：

   ```cpp
   line add(int x0, int y0, int x1, int y1) {
   	line now;
   	// 特判垂直：
   	now.id = ++cnt;
   	if (x0 == x1) {
   		now.k = 0;
   		now.b = max(y0, y1);
   	}
   	else {
   		now.k = 1.0 * (y1 - y0) / (x1 - x0);
   		now.b = y0 - now.k * x0;
   	}
   	now.l = x0;
   	now.r = x1;
   	now.flag = 1;
   	return now;
   }
   ```

3. 给定点，求直线上的纵坐标：求两直线的交点：

   ```cpp
   inline double calc(line a, int pos) {
   	return a.k * pos + a.b;
   } //计算某条线段在某一个横坐标的纵坐标值
   inline int cross(line a, line b) {
   	// 向下取整：
   	return floor((a.b - b.b) / (b.k - a.k));
   } //求两条线段交点的横坐标
   ```




**线段树部分：**

1. 使用过程中，主要修改的地方是：
   1. 直线中维护的信息：这里维护了编号，做多一点事情，但其实是差不多的。
   2. 

```cpp
// 自定义取最优运算函数，代替max
pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
//插入：
void modify(int now, int l, int r, line k)
{
	if (k.l <= l && r <= k.r) {
		// 当前线段覆盖区间;
		int resl = check(calc(k , l) , calc(seg[now] , l));
		int resr = check(calc(k , r) , calc(seg[now] , r));
		// 1. 当前区间上没有优势线段：直接标记即可：
		if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
		// 2. 考虑左右边界的情况，
		// 2.1 如果新插入线段左右边界都高： 说明更优：
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id , k.id);
		}
		// 类似相等的情况：
		// 2.2有相交：
		else if (resl == 1  || resr == 1) {
		int resl = check(calc(k, l), calc(seg[now], l));
		int resr = check(calc(k, r), calc(seg[now], r));
		if (not seg[now].flag) { seg[now] = k; }
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id, k.id);
		}
		else if (resl == 1 || resr == 1) {
			int mid = (l + r) / 2;
			// 中间位置的比较：
			int resmid = check(calc(k , mid) , calc(seg[now] , mid));
			if (resmid == 1) {
				line tmp = k; k = seg[now]; seg[now] = tmp;
			} else if (resmid == 0) {
				// 刚好在中点相交：
				if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
				else modify(now << 1 | 1 , mid + 1 , r , k);
				return;
			}

			// 交点在两侧：
			// 判断在哪一侧上：
			resmid = check(cross(k , seg[now]) , mid);
			if (resmid == -1) modify(now << 1, l, mid, k);
			else modify(now << 1 | 1, mid + 1, r, k);
		}
		}
		// 2.3 原来标记的线段更优：不做任何处理.
	}
	// 不覆盖区间，继续分割：
	else {
		int mid = (l + r) >> 1;
		if (k.l <= mid) modify(now << 1, l, mid, k);
		if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
	}
}

// 查询：
pair<double, int> query(int now, int l, int r, int x)
{
	//定位点：
	if (l == r)
		return { calc(seg[now], x) , -seg[now].id };
	else {
		// 不断下放置：
		int mid = (l + r) >> 1;
		pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
		if (x <= mid) {
			return dcmp(ans, query(now << 1, l, mid, x));
		}
		else
			return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
	}
}
```



#### **code1**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define fsio ios::sync_with_stdio(false);cin.tie(0);
#define double long double

const int inf = (int)1E9 + 7;
const ll INF = (long long)1E18 + 7;
const int N = 40000;
const int mod1 = 39989;
const int mod2 = 1E9;
const double eps = 1E-12;

const int maxn = mod1;
int cnt;
struct line {
	// 斜率 ， y上得交点纵坐标：
	double k, b;
	// 值域
	int l, r;
	// 当前节点上是否有纵坐标存在：
	// 表示当前线段的编号：
	int id;
	int flag;
} seg[4 * maxn]; //线段树的定义

pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
inline double calc(line a, int pos) {
	return a.k * pos + a.b;
} //计算某条线段在某一个横坐标的纵坐标值
inline int cross(line a, line b) {
	// 向下取整：
	return floor((a.b - b.b) / (b.k - a.k));
} //求两条线段交点的横坐标
inline int check(double x , double y) {
	if (abs(x - y) < eps) return 0;
	else if (x < y) return -1;
	else return 1;
}
void modify(int now, int l, int r, line k)
{
	if (k.l <= l && r <= k.r) {
		// 当前线段覆盖区间;
		int resl = check(calc(k , l) , calc(seg[now] , l));
		int resr = check(calc(k , r) , calc(seg[now] , r));
		// 1. 当前区间上没有优势线段：直接标记即可：
		if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
		// 2. 考虑左右边界的情况，
		// 2.1 如果新插入线段左右边界都高： 说明更优：
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id , k.id);
		}
		// 类似相等的情况：
		// 2.2有相交：
		else if (resl == 1  || resr == 1) {
			int resl = check(calc(k, l), calc(seg[now], l));
			int resr = check(calc(k, r), calc(seg[now], r));
			if (not seg[now].flag) { seg[now] = k; }
			else if (resl == 1 && resr == 1) {
				seg[now] = k;
			}
			else if (resl == 0 && resr == 0) {
				seg[now].id = min(seg[now].id, k.id);
			}
			else if (resl == 1 || resr == 1) {
				int mid = (l + r) / 2;
				// 中间位置的比较：
				int resmid = check(calc(k , mid) , calc(seg[now] , mid));
				if (resmid == 1) {
					line tmp = k; k = seg[now]; seg[now] = tmp;
				} else if (resmid == 0) {
					// 刚好在中点相交：
					if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
					else modify(now << 1 | 1 , mid + 1 , r , k);
					return;
				}

				// 交点在两侧：
				// 判断在哪一侧上：
				resmid = check(cross(k , seg[now]) , mid);
				if (resmid == -1) modify(now << 1, l, mid, k);
				else modify(now << 1 | 1, mid + 1, r, k);
			}
		}
		// 2.3 原来标记的线段更优：不做任何处理.
	}
	// 不覆盖区间，继续分割：
	else {
		int mid = (l + r) >> 1;
		if (k.l <= mid) modify(now << 1, l, mid, k);
		if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
	}
}


// 查询：
pair<double, int> query(int now, int l, int r, int x)
{
	//定位点：
	if (l == r)
		return { calc(seg[now], x) , -seg[now].id };
	else {
		// 不断下放置：
		int mid = (l + r) >> 1;
		pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
		if (x <= mid) {
			return dcmp(ans, query(now << 1, l, mid, x));
		}
		else
			return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
	}
}

line add(int x0, int y0, int x1, int y1) {
	line now;
	// 特判垂直：
	now.id = ++cnt;
	if (x0 == x1) {
		now.k = 0;
		now.b = max(y0, y1);
	}
	else {
		now.k = 1.0 * (y1 - y0) / (x1 - x0);
		now.b = y0 - now.k * x0;
	}
	now.l = x0;
	now.r = x1;
	now.flag = 1;
	return now;
}

int main() {
	fsio;
	int n;
	cin >> n;
	int lastans = 0;
	for (int i = 1; i <= n; i++) {
		int op; cin >> op;
		if (op == 0) {
			int k;
			cin >> k;
			int x = (k + lastans - 1) % mod1 + 1;
			// cout << x << "\n";
			cout << (lastans = -query(1, 1, N, x).second) << '\n';
		}
		else {
			int a, aa, b, bb;
			cin >> a >> aa >> b >> bb;
			int x0 = (a + lastans - 1) % mod1 + 1;
			int y0 = (aa + lastans - 1) % mod2 + 1;
			int x1 = (b + lastans - 1) % mod1 + 1;
			int y1 = (bb + lastans - 1) % mod2 + 1;
			// 如果有垂直得线应该怎么处理？
			// cout << x0 << " " << y0 << " " << x1 << " " << y1 << "\n";
			if (x0 > x1)swap(x0, x1), swap(y0, y1);
			// 1. 解决垂直线：
			// 2. 求出关于该线段的信息：
			// line now;
			modify(1, 1, N, add(x0, y0, x1, y1));
		}
	}
}
/*
6
1 1 2 5 6
1 1 2 3 4
1 1 3 2 2
1 1 2 2 3
1 1 1 5 8
0 2
*/
```

这个精度更稳一点：并且码风不错：但是似乎被一组数据hack了：

```cpp
#include <iostream>
#include <string>
#define MOD1 39989
#define MOD2 1000000000
#define MAXT 40000
using namespace std;
typedef pair<double, int> pdi;

const double eps = 1e-9;

int cmp(double x, double y) {
  if (x - y > eps) return 1;
  if (y - x > eps) return -1;
  return 0;
}

struct line {
  double k, b;
} p[100005];

int s[160005];
int cnt;

double calc(int id, int d) { return p[id].b + p[id].k * d; }

void add(int x0, int y0, int x1, int y1) {
  cnt++;
  if (x0 == x1)  // 特判直线斜率不存在的情况
    p[cnt].k = 0, p[cnt].b = max(y0, y1);
  else
    p[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), p[cnt].b = y0 - p[cnt].k * x0;
}

void upd(int root, int cl, int cr, int u) {  // 对线段完全覆盖到的区间进行修改
  int &v = s[root], mid = (cl + cr) >> 1;
  if (cmp(calc(u, mid), calc(v, mid)) == 1) swap(u, v);
  int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));
  if (bl == 1 || (!bl && u < v)) upd(root << 1, cl, mid, u);
  if (br == 1 || (!br && u < v)) upd(root << 1 | 1, mid + 1, cr, u);
}

void update(int root, int cl, int cr, int l, int r,
            int u) {  // 定位插入线段完全覆盖到的区间
  if (l <= cl && cr <= r) {
    upd(root, cl, cr, u);
    return;
  }
  int mid = (cl + cr) >> 1;
  if (l <= mid) update(root << 1, cl, mid, l, r, u);
  if (mid < r) update(root << 1 | 1, mid + 1, cr, l, r, u);
}

pdi pmax(pdi x, pdi y) {  // pair max函数
  if (cmp(x.first, y.first) == -1)
    return y;
  else if (cmp(x.first, y.first) == 1)
    return x;
  else
    return x.second < y.second ? x : y;
}

pdi query(int root, int l, int r, int d) {  // 查询
  if (r < d || d < l) return {0, 0};
  int mid = (l + r) >> 1;
  double res = calc(s[root], d);
  if (l == r) return {res, s[root]};
  return pmax({res, s[root]}, pmax(query(root << 1, l, mid, d),
                                   query(root << 1 | 1, mid + 1, r, d)));
}

int main() {
  ios::sync_with_stdio(false);
  int n, lastans = 0;
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      int x0, y0, x1, y1;
      cin >> x0 >> y0 >> x1 >> y1;
      x0 = (x0 + lastans - 1 + MOD1) % MOD1 + 1,
      x1 = (x1 + lastans - 1 + MOD1) % MOD1 + 1;
      y0 = (y0 + lastans - 1 + MOD2) % MOD2 + 1,
      y1 = (y1 + lastans - 1 + MOD2) % MOD2 + 1;
      if (x0 > x1) swap(x0, x1), swap(y0, y1);
      add(x0, y0, x1, y1);
      update(1, 1, MOD1, x0, x1, cnt);
    } else {
      int x;
      cin >> x;
      x = (x + lastans - 1 + MOD1) % MOD1 + 1;
      cout << (lastans = query(1, 1, MOD1, x).second) << endl;
    }
  }
  return 0;
}
```

[P4254 [JSOI2008\] Blue Mary 开公司 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4254)

### **灵活应用：**

斜率dp优化：

[「杂谈」关于斜率优化维护凸包 - do_while_true - 博客园 (cnblogs.com)](https://www.cnblogs.com/do-while-true/p/15404389.html)

### 板子

```cpp
struct line {
	// 斜率 ， y上得交点纵坐标：
	double k, b;
	// 值域
	int l, r;
	// 当前节点上是否有纵坐标存在：
	// 表示当前线段的编号：
	int id;
	int flag;
}; //线段树的定义

line add(int x0, int y0, int x1, int y1) {
	line now;
	// 特判垂直：
	now.id = ++cnt;
	if (x0 == x1) {
		now.k = 0;
		now.b = max(y0, y1);
	}
	else {
		now.k = 1.0 * (y1 - y0) / (x1 - x0);
		now.b = y0 - now.k * x0;
	}
	now.l = x0;
	now.r = x1;
	now.flag = 1;
	return now;
}
const int maxn = mod1;
struct LiChaoSegementTree {
	line seg[maxn * 4];
	pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
		// 表示接近相等
		double d = x.first - y.first;
		if (abs(d) < eps) {
			x.second = max(x.second , y.second);
		} else if (d < 0) {
			x = y;
		}
		return x;
	}
	inline double calc(line a, int pos) {
		return a.k * pos + a.b;
	} //计算某条线段在某一个横坐标的纵坐标值
	inline int cross(line a, line b) {
		// 向下取整：
		return floor((a.b - b.b) / (b.k - a.k));
	} //求两条线段交点的横坐标
	inline int check(double x , double y) {
		if (abs(x - y) < eps) return 0;
		else if (x < y) return -1;
		else return 1;
	}
	void modify(int now, int l, int r, line k)
	{
		if (k.l <= l && r <= k.r) {
			// 当前线段覆盖区间;
			int resl = check(calc(k , l) , calc(seg[now] , l));
			int resr = check(calc(k , r) , calc(seg[now] , r));
			// 1. 当前区间上没有优势线段：直接标记即可：
			if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
			// 2. 考虑左右边界的情况，
			// 2.1 如果新插入线段左右边界都高： 说明更优：
			else if (resl == 1 && resr == 1) {
				seg[now] = k;
			}
			else if (resl == 0 && resr == 0) {
				seg[now].id = min(seg[now].id , k.id);
			}
			// 类似相等的情况：
			// 2.2有相交：
			else if (resl == 1  || resr == 1) {
				int resl = check(calc(k, l), calc(seg[now], l));
				int resr = check(calc(k, r), calc(seg[now], r));
				if (not seg[now].flag) { seg[now] = k; }
				else if (resl == 1 && resr == 1) {
					seg[now] = k;
				}
				else if (resl == 0 && resr == 0) {
					seg[now].id = min(seg[now].id, k.id);
				}
				else if (resl == 1 || resr == 1) {
					int mid = (l + r) / 2;
					// 中间位置的比较：
					int resmid = check(calc(k , mid) , calc(seg[now] , mid));
					if (resmid == 1) {
						line tmp = k; k = seg[now]; seg[now] = tmp;
					} else if (resmid == 0) {
						// 刚好在中点相交：
						if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
						else modify(now << 1 | 1 , mid + 1 , r , k);
						return;
					}

					// 交点在两侧：
					// 判断在哪一侧上：
					resmid = check(cross(k , seg[now]) , mid);
					if (resmid == -1) modify(now << 1, l, mid, k);
					else modify(now << 1 | 1, mid + 1, r, k);
				}
			}
			// 2.3 原来标记的线段更优：不做任何处理.
		}
		// 不覆盖区间，继续分割：
		else {
			int mid = (l + r) >> 1;
			if (k.l <= mid) modify(now << 1, l, mid, k);
			if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
		}
	}


// 查询：
	pair<double, int> query(int now, int l, int r, int x)
	{
		//定位点：
		if (l == r)
			return { calc(seg[now], x) , -seg[now].id };
		else {
			// 不断下放置：
			int mid = (l + r) >> 1;
			pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
			if (x <= mid) {
				return dcmp(ans, query(now << 1, l, mid, x));
			}
			else
				return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
		}
	}
} tree;
/*
主要修正过程:
1. add修改
2. 维护信息修改
3. 查询函数返回时，其运算修改：
*/




```

100行的板子：其实应该是80行：



#### 字符串哈希

```cpp
class shash {
public:
	vector<ll> pres;
	vector<ll> epow;
	ll e, p;

	shash(string& s, ll e, ll p) {
		int n = s.size();
		this->e = e;
		this->p = p;
		pres = vector<ll>(n + 1);
		epow = vector<ll>(n + 1);
		epow[0] = 1;
		for (int i = 0; i < n; i++) {
			pres[i + 1] = (pres[i] * e + s[i]) % p;
			epow[i + 1] = (epow[i] * e) % p;
		}
	}

	ll operator()(int l, int r) {
		ll res = (pres[r + 1] - pres[l] * epow[r - l + 1] % p) % p;
		return (res + p) % p;
	}
};

int main(){
    string s ="0000";
    shash ss(s , 1331 , 1E9 + 7);
    cout << ss(0 , 1) << "\n";
}
```



------

