#### 21 dxksm

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int C=300010,mod=998244353;
inline int ksm(int a,int x)
{
    int res=1;
    while(x)
    {
        if(x&1)res=1ll*a*res%mod;
        x>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
int G=3,Gi=ksm(3,mod-2),rev[C];
inline void ntt(int a[],int o,int len)
{
    int l2;for (l2=0;(1<<l2)<len;++l2);
    for (int i=0;i<len;++i)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<(l2-1));
        if (i<rev[i])swap(a[i],a[rev[i]]);
    }
    for (int step=2;step<=len;step<<=1)
    {
        int wn=ksm((o==1)?G:Gi,(mod-1)/step);
        for (int i=0;i<len;i+=step)
        {
            int w=1;
            for (int j=i;j<i+(step>>1);++j)
            {
                int u=a[j],v=1ll*w*a[j+(step>>1)]%mod;
                a[j]=(u)+(v)<mod?(u)+(v):(u)+(v)-mod;
                a[j+(step>>1)]=(u)<(v)?(u)-(v)+mod:(u)-(v);
                w=1ll*w*wn%mod;
            }
        }
    }
    if (o==-1)
    {
        int inv=ksm(len,mod-2);
        for (int i=0;i<len;++i)
            a[i]=1ll*a[i]*inv%mod;
    }
}
namespace Poly
{
    int m2[C],to[C];
    inline void mul(int a[],int b[],int to[],int len)
    {
        for (int i=0;i<(len>>1);++i)
            m2[i]=b[i],to[i]=a[i];
        for (int i=len>>1;i<=len;++i)
            to[i]=m2[i]=0;
        ntt(to,1,len);ntt(m2,1,len);
        for (int i=0;i<len;++i)
            to[i]=1ll*to[i]*m2[i]%mod;
        ntt(to,-1,len);
    }
}
int v[C],u[C];
void solve()
{
    int n,m,k;
    cin>>n>>m>>k;
    int limit=1;
    while((1<<limit)<=k*2)
        limit++;
    limit=1<<limit;
    //上面是ntt的模板
    v[0]=1;
    for(int i=1;i<=k;i++)
        v[i]=v[i-1]*(n-i+1)%mod*ksm(i,mod-2)%mod;
    
    // for(int i=0;i<=k;i++)
    // {
    //     v[i]=v[i]*2%mod;
    // }
    
    // for(int i=1;i<=k;i+=2)
    // {
    //     v[i]=0;
    // }
    u[0]=1;
    while(m)
    {
        if(m&1)Poly::mul(u,v,u,limit);
        Poly::mul(v,v,v,limit);
        m>>=1;
    }
    cout<<u[k]<<'\n';
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t=1;
    //cin>>t;
    while(t--)solve();
}
```

#### 22 dxsny

```cpp
//多项式逆元
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353,G=3,N=4000005;
int k,n,f[N],g[N],c[N],r[N];
inline int qmi(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
int d[N],v[N];
inline void init(){
    d[0]=1;for(int i=1;i<=n;++i)d[i]=d[i-1]*i%mod;
    v[n]=qmi(d[n],mod-2);for(int i=n;i;--i)v[i-1]=v[i]*i%mod;
}
inline void NTT(int *f,int fl,int n)
{
    for(int i=0;i<n;++i)
    {
        r[i]=(r[i>>1]>>1)|((i&1)?(n>>1):0);
        if(i<r[i])swap(f[i],f[r[i]]);
    }
    for(int i=2,j=1;i<=n;i<<=1,j<<=1)
    {
        int pl=qmi(G,(mod-1)/i);
        if(fl==-1) pl=qmi(pl,mod-2);
        for(int k=0;k<n;k+=i)
            for(int l=k,nw=1;l<k+j;++l,nw=nw*pl%mod)
                {
                    int x=f[l],y=nw*f[l+j]%mod;
                    f[l]=(x+y)%mod,f[l+j]=(x-y+mod)%mod;
                }
    }
}
inline void inv(int *f,int *g,int n)
{
    g[0]=qmi(f[0],mod-2);
    for(int i=1,j=2;i<=n;i<<=1,j<<=1)
    {
        for(int p=0;p<j;++p) c[p]=f[p];
        for(int p=j;p<j*2;++p) c[p]=0;
        NTT(c,1,j*2),NTT(g,1,j*2);
        for(int p=0;p<j*2;++p)
            g[p]=(g[p]*2-g[p]*g[p]%mod*c[p]%mod+mod)%mod;
        NTT(g,-1,j*2);
        int vj=qmi(j*2,mod-2);
        for(int p=0;p<j;++p) g[p]=g[p]*vj%mod;
        for(int p=j;p<j*2;++p) g[p]=0;
    }
}
void solve()
{
    cin>>n>>k;
    n++;
    init();
    for(int i=0;i<n;i++)
        f[i]=qmi(2,i*(i-1)/2)*v[i]%mod;
    inv(f,g,n);
    for(int i=k+1;i<=4*n;i++)g[i]=0;
    fill(f,f+4*n+1,0);
    inv(g,f,n);
    int ans=f[n-1];
    g[k]=0;
    fill(f,f+4*n+1,0);
    inv(g,f,n);
    ans=(ans+mod-f[n-1]+mod)%mod;
    cout<<ans*d[n-1]%mod<<'\n';
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    solve();
}
```