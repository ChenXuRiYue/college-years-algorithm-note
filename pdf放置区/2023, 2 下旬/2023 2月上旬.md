## 树形背包上下界面优化

参考：

https://www.cnblogs.com/ouuan/p/BackpackOnTree.html

#### 简介

在某一些背景之中，树形dp的复杂度看似$N^3$但是经过优化之后复杂度事实上会是$O(N^2)$。这篇笔记，总结一些平方的树形dp。包括复杂度证明、经典问题、实现关键。





#### 问题引入

树上背包（选课问题等）

现在看这些问题的共性：

1. 状态设计上形如$f_{u,k}$，根节点与子节点之间的状态合并的复杂度为：$O(N^2)$。
2. 指标函数中，第二个维度的值域和子树的节点数有关。注意控制两个dp数组的大小，就可以整体上控制复杂度为$O(N^2)$

#### 证明如下：

几个角度：

1. 研究整体的转移过程：得到一个公式
2. 然后从子节点开始看。利用数学上（和平方>平方和的性质）得到最小规模子树的处理复杂度。
3. 往上递归证明得到根节点的复杂度。

-------

#### 树形背包1

[树上背包1 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/269)

 [F - Components.md](F - Components.md) 



##### 问题简述：

1. 上述树形背包问题

   选择节点数量恰好为m的连通块的最大节点权值和。

2. 上笔记中的例题

   连通块数量为m的方案个数。

事实上都是树形背包问题。在子树中选择独立结构。

#### solve

1. 定义$f_{i , j}$表示根为i的子树中，选择了根并且节点数量为j的连通块 ， 的最大权值。
2. 初始化。
   1. 对于所有方案初始化为0.
3. 转移。
   1. 合并所有儿子的dp数组。
   1. 对于一个节点合并完成后统计答案。

看上去复杂度为$O(N^3)$
对于节点i， 有意义的选择数量的值域只可能是（1....size(i)）.
只求有意义的合并数组。

但是如果关注每一个点对，发现它们只合并一次。而所有子树的情形下，都有一个dp元素与之中匹配。

##### code

``` cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2010 , inf = - 1E9;
vector<int> e[N];
int w[N] , sz[N] , n ,  q;
ll f[N][N];

void dfs(int u) {
	sz[u] = 0;
	for (auto v : e[u]) {
		dfs(v);
		vector<ll> temp(sz[u] + sz[v] + 1 , inf);
		for (int i = 0; i <= sz[u]; i++)
			for (int j = 0; j <= sz[v]; j++) {
				temp[i + j] = max(temp[i + j] , f[u][i] + f[v][j]);
			}
		sz[u] += sz[v];
		for (int i = 0; i <= sz[u]; i++) {
			f[u][i] = temp[i];
		}
	}
	sz[u] ++;
	for (int i = sz[u]; i >= 1 ; i--) {
		f[u][i] = f[u][i - 1] +  w[u];
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		int x; cin >> x;
		e[x].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
	}
	dfs(1);
	while (q--) {
		int x, y;
		cin >> x >> y;
		cout << f[x][y] << '\n';
	}
}
```

#### 生长思考：

1. 处理树的根节点：

   1. 计算的过程是，利用子问题的最优结构子问题的解。
   2. 对于根节点 ，如果开始就处理。设计$f_{u , 1} = w[u]$。出现问题。因为只关注，迁移过程中用到的为1的节点数。迁移过程中，指标函数的解可能不再含有根。
   3. 处理方法是，记录除根外的结构。最后补充上。
2. 计算dp数组过程中。不同阶段，该数据具有不同的意义：
   1.  0 ... i个节点 ， 选择j个节点连通块的最大权值和。
   2.  表示整一颗子树选择了j个节点的最大权值和。




#### 补充：

另外一种写法：关于迁移时初始化的方式不同。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2010 , inf = - 1E9;
vector<int> e[N];
int w[N] , sz[N] , n ,  q;
ll f[N][N];

void dfs(int u) {
	sz[u] = 1;
	f[u][0] = inf;
	f[u][1] = w[u];
	for (auto v : e[u]) {
		dfs(v);
		vector<ll> temp(sz[u] + sz[v] + 1 , inf);
		for (int i = 0; i <= sz[u]; i++)
			for (int j = 0; j <= sz[v]; j++) {
				temp[i + j] = max(temp[i + j] , f[u][i] + f[v][j]);
			}
		sz[u] += sz[v];
		for (int i = 0; i <= sz[u]; i++) {
			f[u][i] = temp[i];
		}
	}
	f[u][0] = 0;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		int x; cin >> x;
		e[x].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
	}
	dfs(1);
	while (q--) {
		int x, y;
		cin >> x >> y;
		cout << f[x][y] << '\n';
	}
}
```

-----------

#### 树形背包2

[树上背包2 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/270)

##### 发散点

- 改变数据特点。

  n - > 500000

  m - > 100

##### solve

使用和上面树形背包1的问题解决技巧。同时基于问题，只关注规模的小于等于m的规模的问题。

状态迁移还是一样的。

 [平方复杂度的树形dp.md](平方复杂度的树形dp.md) 类似这一个证明方法，可以完成对问题的证明。

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int inf = -1E9;


vector<int> e[N];
int w[N] , siz[N];
int f[N][110];
int n;

void dfs(int u) {
	siz[u] = 0;
	//然后应该怎么办呢？
	for (auto v : e[u]) {
		dfs(v);
		vector<int> temp (min(siz[u] + siz[v] + 1 , 101) , inf );
		for (int i = 0; i <= siz[u] && i <= 100; i++)
			for (int j = 0; j <= siz[v] && (i + j) <= 100 ; j++) {
				temp[i + j] = max(temp[i + j] , f[u][i] + f[v][j]);
			}
		siz[u] += siz[v];
		for (int i = 0; i < (int)temp.size(); i++) {
			f[u][i] = temp[i];
		}
	}
	siz[u]++;
	for (int i = min(siz[u] , 100); i >= 1; i--) {
		f[u][i] = f[u][i - 1] + w[u];
	}
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int  q;
	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		int x; cin >> x;
		e[x].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
	}
	dfs(1);
	while (q--) {
		int  u , m;
		cin >> u >> m;
		cout << f[u][m] << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 树上背包3

[树上背包3 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/271)

就是经典的树上背包问题。
严格控制复杂度为$O(N\times M)$

##### solve

如果参照之前的方法。（或者是一般泛化物品的方法)由于m比较大。并且无法对合并dp数组的长度进行优化。所以用前面的思想行不通。

以下是一种很神奇的方法。利用dfs序。将问题转换成一个线性问题。如下：

1. 求出当前树的dfs序列。
2. 定义$r_i$表示跳过i节点为根节点的子树，的第一个节点。
3. 定义$f_{i , j}$表示考虑dfs序中$[i , n]$这一段的节点。选的重量和不超过j的点集的最大权值和，并且要求这个点集不存咋一个点选了。但它在点集中的祖先没有被选的i情况。

状态转移方程：
$$
f_{i , j}=max(f_{r_i,j},f_{i+1,j-w_i}+v_i)
$$

5. 初始化： f\[n + 1][1...j] = -oo;

##### code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1010, M = 10010;
const int inf = 1<<29;

vector<int> son[N];

int n, m, tot, l[N], r[N], id[N];
int dp[N][M], a[N], w[N];

void dfs(int u) {
	l[u] = ++tot;
	id[tot] = u;
	for (auto v : son[u]) {
		dfs(v);
	}
	r[u] = tot;
}

int main() {
	scanf("%d%d",&n, &m);
	for (int i = 2; i <= n; i++) {
		int f;
		scanf("%d", &f);
		son[f].push_back(i);
	}
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++)
		scanf("%d", &w[i]);
	dfs(1);
	for (int j = 1; j <= m; j++) dp[n + 1][j] = -inf;
	for (int i = n; i >= 1; i--) {
		int u = id[i];
		for (int j = 0; j <= m; j++) {
			dp[i][j] = dp[r[u] + 1][j];
			if (j >= w[u])
				dp[i][j] = max(dp[i][j], dp[i + 1][j - w[u]] + a[u]);
		}
	}
	for (int i = 0; i <= m; i++) {
		if (dp[1][i] >= 0) printf("%d\n", dp[1][i]);
		else printf("0\n");
	}
}
```

##### 生长思考

1. 第一次碰到的关于，将树的dfs序找出来。然后在利用dfs序处理问题的图论问题。（可能强连通分量，相关定理算其中一个）。
2. 该问题的方法思想 ， 比较特殊少见。

#### 总结以及拓展

1. 距离相关问题，进行树形dp时也会出现相关的结论。
   1. 在树上找一个连通块。满足任意两点之间的距离不超过d。使得权值和最大，权值可能为负数。
   2. 在树上找一个点集，满足任意两点之间的距离不小于d。使得权值和最大，权值可能为负数。
2. 合并的dp域，和子树的节点数相关。那么就会有类似的结论。



-----------

### 树上路径1

[树上路径1 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/272)

关注现象：

1. 对于一颗树。一个节点，它的儿子的子树是互不干扰的。

#### solve1

多加入一维状态转移。


状态定义:  

1. $f_{i,j}$表示第i个节点选择j路径的最大权重。
2. $g_{i , j}$表示$v_i$子树下。集合{所选择的路径没有交集，路径不超过子树范围}的最大权重和。

转移方程：

1. 关于f的计算

<img src="image-20230218162512294.png" alt="image-20230218162512294" style="zoom: 67%;" />

2. 关于g的计算



#### solve2

只考虑两点的lca处的情况。

状态

1. $f_i$表示i子树下，不外延选择的路径和。

状态转移如下

<img src="image-20230218164616698.png" alt="image-20230218164616698" style="zoom: 67%;" />

<img src="image-20230218171608252.png" alt="image-20230218171608252" style="zoom:67%;" />

#### coding技巧

关于状态计算：

1. 考虑逐步计算。从根部出发，每次拓展一次点。变化量为$dp_v -sdp_u$
2. 每一次计算，得到的新状态都满足目标状态。这样最终就可以计算处$dp_u$了。

关于lca处理：

1. 由于n比较小。所以可以使用暴力的寻父亲的方法。
2. 当然常见的倍增法，也是居家必备的。

#### 复杂度计算：

每一个路径上的节点经历一次。每一个节点经历一次。总复杂度是$O(n*m)$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2E3 + 10;

vector<int> son[N];
vector<array<int , 3>> path[N];

int dep[N] , f[N] , lca[N];
ll dp[N] , sdp[N];

void dfs(int u) {
	for (auto v : son[u]) {
		dfs(v);
		sdp[u] += dp[v];
	}
	dp[u] = sdp[u];

	for (auto p : path[u]) {
		ll tmp = sdp[u];
		int x = p[0];
		while (x != u) {
			tmp += sdp[x] - dp[x];
			x = f[x];
		}
		x = p[1];
		while (x != u) {
			tmp += sdp[x] - dp[x];
			x = f[x];
		}
		tmp += p[2];
		dp[u] = max(tmp , dp[u]);
	}
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	for (int i = 2; i <= n; i++) {
		cin >> f[i];
		son[f[i]].push_back(i);
		dep[i] = dep[f[i]] + 1;
	}

	for (int i = 1; i <= m; i++) {
		int x , y , w;
		cin >> x >> y >> w;
		int u = x , v = y;
		while (x != y) {
			if (dep[x] > dep[y]) x = f[x];
			else y = f[y];
		}
		path[x].push_back({u , v , w});
	}
	dfs(1);
	cout << dp[1] << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### 生长思考

- 这种逐步构造式计算的思路。非常巧妙。
- 关于当前暴力方法下，求取lca
- 第二个方法是第一个方法的子集，$g_i$依然是用这种方法计算。所以放心偷懒即可。
  - 但是第一个方法，给予一个解的结构关注的角度。拆成两个状态来转移。

### 树上路径二

[树上路径2 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/273)

#### 变化

1. 路径必然是孙子指向祖先
2. 树上的每一个点至少被覆盖一次。

#### solve

1. 定义状态

​		$f_{i , j}$表示从i,开始，把子树填满，并且上升打到深度j的最小的花费权重。

2. 状态转移方程如下图：
3. 初始化。
   1. 遍历以u为孙子的路径。更新$dp_{u , w}$因为后面对于这个dp。乍一看下面子树没有满，感觉非常违反定义。但是模拟一下发现。更新的dp，还要和儿子的dp组合。如果儿子的dp存在。是不违反定义的。

<img src="%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84.png" alt="树上路径" style="zoom: 25%;" />



#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;


const ll inf = 1LL << 60;
const int N = 2E3 + 10;
vector<int> son[N];
vector<array<int , 2>> path[N];
ll dp[N][N];
int depth[N];
int n , m;

//lenu节点的深度。
void merge(ll *a , ll *b , int len) {
	static ll sufa[N] , sufb[N];
	sufa[len + 1] = inf;
	sufb[len + 1] = inf;
	for (int i = len; i >= 1 ; i--) {
		sufa[i] = min(sufa[i + 1] , a[i]);
		sufb[i] = min(sufb[i + 1] , b[i]);
	}
	for (int i = len; i >= 1; i--)
		a[i] = min(sufa[i] + b[i] , sufb[i] + a[i]);
}


void dfs(int u) {
	for (int i = 1; i <= depth[u] ; i++)dp[u][i] = inf;
	//怎么初始化？
	for (auto p : path[u]) {
		dp[u][depth[p[0]]] = min(dp[u][depth[p[0]]] , 1LL * p[1]);
	}
	for (auto v : son[u]) {
		dfs(v);
		merge(dp[u] , dp[v] , depth[v]);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);


	cin >> n >> m;
	depth[1] = 1;
	for (int i = 2; i <= n; i++) {
		int x; cin >> x;
		son[x].push_back(i);
		depth[i] = depth[x] + 1;
	}
	for (int i = 1; i <= m; i++) {
		int u , v , w;
		cin >> u >> v >> w;
		path[v].push_back({u , w});
	}
	dfs(1);
	if (dp[1][1] < inf)
		cout << dp[1][1] << '\n';
	else cout << -1 << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 生长思考：

1. 编写策略上： 树形dp总是有一项工作是，合并儿子和父亲的dp数组。这里写成一个merge函数。可以减少代码量。意义明确简洁，相当舒适。
2. 前缀和优化的例子。

-----------

### 树上连通块

[树上连通块 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/274)



#### 题目简介

给定一个点，求出包含该点的连通块的个数，答案对$m(2 <= m <= 10^9)取模$。$1 <=n <= 10^5$

#### solve

1. 先考虑一个最简单的dp问题。只是求一个点。

   1. 定义状态$f_i$表示的是，以i为根的子树中连通块的个数（不包含节点数为0的情况）。

   2. 状态转移方程;
      $$
      f_i = (f_{son_1}+1)\times (f_{son_2}+1)\times....\times(f_{son_i}+1)
      $$

2. 

3. 考虑要求所有点：

   1. 考虑简单的换根dp.，每次换根计算出更新的dp值

      1. 暴力。$O(deg*deg)$  - > $O(n^2)$

      2. 对父亲的dp值直接 除法。（m不一定是质数，无法计算出逆元）

换根dp优化实现方法：
      1. 维护儿子的前缀积，后缀积。局部修改问题。直接考虑前后缀的情况。

下面是一些困惑：

1. 换根dp的顺序是什么？

​		随意找一个点作为根，发现不能处理父亲的情况。作为子树的贡献情况。换根的前提是，待选根的父亲作为子树的方案贡献已经求		出来。	

2. 换根的过程中 ， 节点的dp要出现什么变化？

​		 节点的dp不需要变化。再开一个dp2用来表示，该节点的父亲作为其余节点构成的子树的的父亲时 ， 其子树的连通块种类（不包···		括0的情况）。

​		 关于dp2的转移方程：	
​      1. 对于深度为1的节点，就是兄弟节点的（dp + 1）相乘。为什么要加一（因为可以考虑不选）。
​      2. 对于深度不为1的节点，就是兄弟节点乘上父亲的(dp2  +  1)。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E5 + 10;
int  n , mod;
vector<int> son[N];
ll dp[N] , dp2[N] , ans[N];

void dfs(int u) {
	dp[u] = 1;
	for (auto v : son[u]) {
		dfs(v);
		dp[u] = dp[u] * (dp[v] + 1) % mod;
	}
}

void dfs2(int u) {
	int m = son[u].size(); if (m == 0) return ;
	static ll pre[N] , suf[N];

	pre[0] = 1;
	for (int i = 1; i <= m; i++) {
		int v = son[u][i - 1];
		pre[i] = pre[i - 1] * (dp[v] + 1) % mod;
	}
	suf[m + 1] = 1;
	for (int i = m; i >= 1; i--) {
		int v = son[u][i - 1];
		suf[i] = suf[i + 1] * (dp[v] + 1) % mod;
	}
	for (int i = 0; i < m; i++) {
		int v = son[u][i];
		dp2[v] = pre[i] * suf[i + 2] % mod;
		if (u != 1) dp2[v] = dp2[v] * (dp2[u] + 1)  % mod;
	}
	for (auto v : son[u]) {
		ans[v] = (dp2[v] + 1) * dp[v] % mod;
		dfs2(v);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> mod;
	for (int i = 2; i <= n ; i++) {
		int x; cin >> x;
		son[x].push_back(i);
	}
	dfs(1);
	dfs2(1);
	ans[1] = dp[1];
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 生长思考

1. 换根dp也有一定的模式：
   1. 比方说，专门开一个dp2表示节点的父亲作为其余节点构成的根时，所定义的指标函数的解。

--------------

## 题目集合

#### ICPC Nanjing 2021 H, Crystalfly

[ICPC Nanjing 2021 H, Crystalfly - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/295)

#### 题目简介

从根节点往下走，当到达一个节点时，可以把该节点上地所有蝴蝶抓走。

但是当到达一个节点时，相邻节点上的蝴蝶就会被惊动，并且在$t_i$秒后飞走（1<=$t_i$<=3）

求出最大的可抓蝴蝶个数（假设时间无限）

####  solve

考察从根部往下走：

1. 可以采取两种策略：

   1.  1 - 》 2  - 》 3 
   2.  1 - 》 2 —》 1 - 》2

   如果选择了1.那么2子树全部处理完再回来才是更优策略。因为回到1之后 1 之后，那些儿子的蝴蝶都已经飞走了。利用返回的时间，不如在2子树中考虑其它的策略。

2. <img src="%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84-1677329918045-5.png" alt="转换" style="zoom: 25%;" />

求出每种子树作为这三种结构之一的最优解。

由于三种子树之间的关系是互相转移的。所以只需要求出$f$的结构即可。
$$
第一种方案:\\
g_v + \sum f_{son!=v}\\
=\sum(f_{son}) + max(a_{sons})
$$

$$
\\第二种方案：\\
h_{i} + g_{j} + \sum f_{sons} - f_{i} - f_{j}\\
= \sum f_{sons} + max(h _i - f_i + max(剩下的，t=3的最大的权值。))；
$$

==转移实现==

1. 第一种方案：每个节点贡献一次。记。记录两个变量。总花费是$O(n)$

2. 第二种方案：
   1. 暴力枚举$a_i,a_j$。如果节点的度数非常的大，花费的复杂度将会高达$O(n^2)$
   2. 优化的角度是。
      1. 记录下最大与次大的$a_i$。
      2. 所有的方案都是从这两个之中选的。
      3. 枚举i ， 然后看是否为最大，如果是就选择次打。否则为最大。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

ll a[N];
int t[N];

void work(int testNo)
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) cin >> t[i];

	vector<vector<int>> son(n + 1);
	for (int i = 1; i < n; i++) {
		int u , v; cin >> u >> v;
		son[u].push_back(v); son[v].push_back(u);
	}
	vector<ll> f(n + 1 , 0)  , h(n + 1 , 0) ;

	function<void(int , int)> dfs = [&](int u , int fa) -> void{
		ll sum = 0;
		ll ma = 0;
		for (auto v : son[u]) if (v != fa) {
				dfs(v , u);
				sum += f[v];
				ma = max(ma , a[v]);
			}

		f[u] = sum + ma;
		pair<ll , int> mx1{0 , 0} , mx2{0 , 0};
		for (auto v : son[u]) if (v != fa && t[v] == 3) {
				pair<ll , int> mx3 = {a[v] , v};
				if (mx3 > mx2) mx2 = mx3;
				if (mx2 > mx1) swap(mx1 , mx2);
			}

		for (auto v : son[u])if (v != fa) {
				ll temp = sum + h[v] - f[v] ;
				if (v == mx1.second) temp += mx2.first;
				else temp += mx1.first;
				f[u] = max(f[u] , temp);
			}
		h[u] = sum + a[u];
	};
	dfs(1 , 0);
	cout << f[1] + a[1] << '\n';

}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### 生长思考：

1. 对于最大位，次位置。
   1. 仅仅记录大小是错误的。同时应该记录位置。因为最大次大这两个，在儿子集合中的（t = 3）子集中选取。子集之外也有等大的。会造成影响。充要的方法是，记录儿子标号，利用儿子标号来记录。
2. dls是怎么探求问题的解空间的？
   1. 从最小的状态开始。枚举出状态。

---------

### M-Monster Hunter

[M-Monster Hunter_第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（南京） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/10272/M)

#### 题目简介

1. 很多个monster由父子关系，组成了一棵树。如果想要消灭一个monster。首先要将其父亲消灭。

2. 每一个monster都有一个生命值。

3. 消灭一个monster的花销如下：

$$
sum = hp_i +\sum hp_{j:j必须是活着的妖怪}
$$

可以对整颗子树，使用m次魔术。使用0花销选择消灭掉一个妖怪。

#### solve

==状态定义==

定义状态$dp[i][j]$表示在i子树下使用j次魔术，消灭该子树上所有点的花费。发现迁移不了，因为转移过程中，我们同时也要关注当前的儿子有没有被消灭掉。

1. 考虑加多一维，表示当前子树的根有没有使用魔法。0，表示没有被删除。1表示已经被删除了。

==状态转移方程==

经典的一个树形背包问题：
$$
关于dp[u][0..m][0]\\
dp[u][i][0] + dp[v][j][1] -> (min)  temp[i + j][0];\\
dp[u][i][0] + dp[v][j][0] -> (min)  temp[i + j][0];
$$

$$
关于dp[u][0...m][1]\\
dp[u][i][1] + dp[v][j][0] - > (min) temp[i + j][1]\\
dp[u][i][1] + dp[v][j][1] + a[v]- > (min) temp[i + j][1]\\\\
迁移完成之后：\\
dp[u][1...i][1]+=a[u];\\
$$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll oo = 1LL << 60;
const int N = 2E3 + 10;
vector<int>son[N];
int size[N];
ll dp[N][N][2] , a[N];

// 0 .表示什么？有没有使用魔法。有没有消灭掉

void dfs(int u) {
	//怎么转移。还出现了其它一些问题。那么到底是什么问题呢？
	//应该怎么初始化/
	//状态定义是什么？完全没有头绪。
	dp[u][1][0] = 0;
	dp[u][0][0] = oo;
	dp[u][1][1] = oo;
	dp[u][0][1] = a[u];
	size[u] = 1;

	for (auto v : son[u]) {
		dfs(v);
		vector<vector<ll>> tmp(size[u] + size[v] + 1 , vector<ll>(2 , oo));
		for (int i = 0; i <= size[u]; i++)
			for (int j = 0; j <= size[v]; j++) {
				tmp[i + j][0] = min(dp[u][i][0] + min(dp[v][j][0] , dp[v][j][1]) , tmp[i + j][0]);
				tmp[i + j][1] = min(dp[u][i][1] + dp[v][j][0] , tmp[i + j][1]);
				tmp[i + j][1] = min(dp[u][i][1] + dp[v][j][1] + a[v] , tmp[i + j][1]);
			}
		size[u] += size[v];
		for (int i = 0; i <= size[u]; i++) {
			dp[u][i][0] = tmp[i][0];
			dp[u][i][1] = tmp[i][1];
		}
	}
}

void work(int testNo)
{
	int n;
	cin >> n ;
	for (int i = 1; i <= n; i++) son[i].clear();
	for (int i = 2; i <= n; i++) {
		int f; cin >> f;
		son[f].push_back(i);
	}
	for (int i = 1; i <= n; i++)cin >> a[i];
	dfs(1);
	for (int i = 0; i <= n; i++) {
		cout << min(dp[1][i][0] , dp[1][i][1]) << " \n"[i == n];
	}
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 生长思考

1. 自己一些偏见。浮出了水面。

   总是在想，做树形dp时候。根节点总是要最后处理。而这里，根节点的贡献一开始就已经选择了。

   偏见来源： [树上背包.md](..\..\树上背包\树上背包.md)  （树上背包1）

   本质上都是树形背包问题，但是为什么对于根节点的贡献却有两种相反的处理？

2. 在dp过程中。dp[u]有滚动数组的意味。它的子问题是。根节点加上前i个儿子子树结构中。分配j魔法的合法结构的最优解。

3. 考虑初始化，dp数组最终意义是我们一开始定义的。但是为了合并儿子节点的dp数组。计算过程中 ， 存储结构可能呈现不一样的定义。如上树上背包1.合并过程中的意义是，将j个节点分配个0...i儿子的连通块的最大权值和。

   在合并完成之后，再进行处理。然后回到了最初的定义。

-----------

[Problem - K - Codeforces](https://codeforces.com/gym/102769/problem/K)

#### 简介

给定一棵树：
根节点处有无数支军队。不断地，可以使用一个单位地时间，将一支军队转移到相邻地节点。问至少要花费多少地时间，使得每一个节点都被军队遍历过。



#### solve

1. 考察最终的答案。最终每一支军队都将会分布在叶子节点处。



问几个问题：

探究解空间：

1. 一颗树的节点会被怎样遍历？

   考虑每一个儿子子树的遍历情况。

   1. 没有军队停留在树的叶子下：

   2. 至少一个军队进入：军队停留在叶子上。
   3. 如果至少一支军队停留，那么每一支军队都将停留在子树的叶子节点下。



状态定义：

$f_{u , 0/1}$分别表示，有没有下派军队情况下 , 处理以u为根的子树的最小代价。

状态转移方程为：

$f_{u，0} = \sum(f_{v,0} +2)$

$f_{u,1}$ 若干$f_{v,1} ,f_{v , 0}$的组合。同时注意至少有一个$f_{v,1}$ 

#### code (dfs版本)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

vector<int> e[N];
int dp[N][2];
int dep[N];


void dfs(int u) {
	dp[u][0] = 0;
	dp[u][1] = dep[u];
	for (auto v : e[u]) {
		dep[v] = dep[u] + 1;
		dfs(v);
		dp[u][1] = min({dp[u][1] + dp[v][0] + 2, dp[u][0] + dp[v][1] , dp[u][1] + dp[v][1]});
		dp[u][0] += dp[v][0] + 2;
	}
}


void work(int testNo)
{

	int n; cin >> n;
	for (int i = 1; i <= n; i++) e[i].clear();
	for (int i = 2; i <= n; i++) {
		int x;
		cin >> x;
		e[x].push_back(i);
	}
	dfs(1);
	cout << "Case #" << testNo << ": "  << min(dp[1][1] , dp[1][0])  << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

#### code2(常数优化版本)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;

int dp[N][2];
int dep[N];
int fa[N];
void work(int testNo)
{

	int n; cin >> n;
	for (int i = 2; i <= n; i++) {
		cin >> fa[i];
		dep[i] = dep[fa[i]] + 1;
	}
	for (int i = 1; i <= n; i++) {
		dp[i][0] = 0;
		dp[i][1] = dep[i];
	}
	for (int v = n; v > 1; v--) {
		int u = fa[v];
		dp[u][1] = min({dp[u][1] + dp[v][1] , dp[u][1] + dp[v][0] + 2, dp[u][0] + dp[v][1]});
		dp[u][0] += dp[v][0] + 2;
	}
	cout << "Case #" << testNo << ": "  << dp[1][1]  << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

----------

[Problem - F - Codeforces](https://codeforces.com/contest/1551/problem/F)

#### 简介

考察节点数量大小为k ， 并且节点之间距离相等的若干子集。计算出方案的总个数。



#### solve

考察方案。发现所有的合法方案。其实就是每一个节点到一个中心点的距离相等。

1. 考虑枚举这一个中心点。重新构造一棵树。

每一个方案中 ， 每一颗子树 只能选取一个点。并且深度相同。

2. 枚举选取点的深度。



==状态设计==

$dp_{i , j}$ 表示从前i个子树中，选取j个节点的方案个数。

==状态转移方程==
$$
dp_{i， j} = dp_{i - 1,j} + dp_{i - 1 , j}*sum[v]
$$
其中$sum[v]$表示 v 为根的子树中深度为枚举深度的节点数量。

==时间复杂度分析==

枚举根节点的花费： $N$

求出各个子树某深度的节点个数; $N*N$

枚举深度 $N$

每一次枚举儿子： $N$

每一次更新dp数组：$K$

综上，看上去，总的复杂度是$O(N^3k)$

但是事实上，儿子的深度的值域和儿子的个数有关。如果子树的某深度下的节点树为0.不需要更新。

每一次枚举儿子，合并更新的次数，应该是。每个子树中，每个深度处理一次。

所以总的次数是$N$次

所以总的复杂度为$O(N^2k)$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E2 + 10;
const ll mod = 1E9 + 7;

ll sum[N][N];
int dep[N];
vector<int> g[N];
int n , k , w;
ll dp[N];

void dfs(int u , int  par ) {
    for (int i = 0; i <= n; i++)sum[u][i] = 0;
    sum[u][dep[u]] ++ ;
    for (auto v : g[u])if (v != par) {
            dep[v] = dep[u] + 1;
            dfs(v , u);
            for (int i = 1; i <= n; i++) {
                sum[u][i] += sum[v][i];
            }
        }
}

ll rundp(int u) {
    for (int i = 0; i <= k; i++) dp[i] = 0;
    dp[0] = 1;
    for (auto v : g[u]) {
        if (sum[v][w] == 0)continue;
        for (int i = k; i >= 1; i--) {
            dp[i] = (dp[i] + dp[i - 1] * sum[v][w]) % mod;
        }
    }
    return dp[k];
}


void work(int testNo)
{
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        g[i].clear();
    }
    for (int i = 1; i < n; i++) {
        int x , y;
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }

    ll ans = 0;
    if (k == 2) {
        cout << 1LL * n*(n - 1) / 2 << '\n';
        return ;
    }
    for (int i = 1; i <= n; i++) {
        dep[i] = 0;
        dfs(i , 0);
        // cout << "test: " << i << '\n';
        // for (int j = 1; j <= n; j ++)
        //     cout << sum[i][j] << " \n"[j == n];

        for (int j = 1; j <= n; j ++) {
            w = j;
            ans = (ans + rundp(i)) % mod;
        }
    }
    cout << ans << '\n';
}


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t; cin >> t;
    for (int i = 1; i <= t; i++)work(i);
}
```

---------

[D - Marking (atcoder.jp)](https://atcoder.jp/contests/abc290/tasks/abc290_d)

#### 简介

给定 D    和     N。初始  x = 0;标记0已经经过

不断进行下列的操作：

1. x - > (x + D) % N;
2. while( mark[D] ) x++;
3. mark x;

查询第k个被标记的数字。



#### solve

[Editorial - Toyota Programming Contest 2023 Spring Qual B（AtCoder Beginner Contest 290）](https://atcoder.jp/contests/abc290/editorial/5812)

首先观察到（或者记录总结一个结论。）

定义 A  ， B 为正整数。  g = gcd (A  ,  B);

$A = ag , B = bg$

$\left \{0 , B\%A ,2B\%A....(a-1)\%A \right \} =\left \{ 0 , g ,2g,3g....(a-1)g \right \} $

##### 举例子

$$
A = 12 = ag , B = 9 = bg\\
a = 4 , b = 3 ,g = 3
$$

对于第一个运算数列如下：

0   ,   9   ,   6   ， 3    

对于第二个运算数列如下：   

0  ， 3    6    9

##### 推论

当gcd = 1时。0  ....   .....  （N - 1）D逐渐会将$[0,N)$每一个数字填满。

当gcd > 1时。

定义$f(i) = i*D\%A$



1. 当$0<=i<a$  ， $f(i)$两两不同。

2. 当$i = a \quad a*A = a*g * b = Ab$ . $f(i)=0$.该点已经被标记 x++

   x = 1；

3. 当$ a<= i < a+g$ 

   显然相当于上一次地集合往前面挪一遍。

4. 将a次分为一轮。每一次等距的一些数字往后不断的挪一步。直到所有都填满。

综上

$f(k) = (k-1)/a + (k - 1)D\%N$

#### 生长思考

1. 总结别然总结规律的角度：

​		k - 1将数字投到 0 .... a-1 这样的划分中。是一个技巧。当计数从1开始 ， 同时涉及 mod运算 , 将1 ....k块化分成若干连续len块 ， 并且要求对于整一块中，它们的mod 值 连续上升。此时考虑投射到 0 ..... k的值域。

2. 第二部分 ， 不用取mod。因为余的部分，自然取模。结果为0.

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

ll gcd(ll x , ll y) {
	return (x == 0) ? y : gcd(y % x , x);
}

void work(int testNo)
{
	ll n , d , k;
	cin >> n >> d >> k;
	ll  g = gcd(n , d);
	ll  a = n / g;
	k --;
	cout << k / a + k*d % n << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/

```



------------

[E - Make it Palindrome (atcoder.jp)](https://atcoder.jp/contests/abc290/tasks/abc290_e)

#### 简介

对于一个数组。统计所有子数组变成回文数组的最小花费。

#### solve

对于一个数组，变成回文数组的最优方案是，配对不一样就改一个。

例如:  1 2 3 1 2 3	$3$

1. 根据容斥，我们假设每一个配对都要改。

   	然后总贡献为：

$$
\sum_{i= 1}^{n}(N - i + 1)\times \left \lfloor \frac{i}2{}  \right \rfloor
$$

		这样直接通过$O(N)$求出即可。

2. 同去匹配项的总贡献：从最短的串开始，串两头逐步向两边拓展。贡献次数为
   $$
   \min(l , N - r + 1);
   $$

3. 记录下相同的位置，然后尝试推导出一些结论。快速的计算出每一对的贡献：用双指针对于同一个数字的记录数组上移动。

   然后发现了贡献的统计方法：
   $$
   pos[low] < N - pos[high] + 1; \\
   说明 low .... high 中的每一个与low对应的数字，贡献都为 pow[low]\\
   同理可以推出high 的贡献。\\
   从起点开始，逐渐把所有的贡献计算完成。\\
   $$

![树上路径](problems/atcoder/%25E7%25AE%2597%25E6%25B3%2595%25E8%25AE%25BE%25E8%25AE%25A1%25E6%2580%259D%25E6%2583%25B3/%25E5%2589%25AA%25E6%259E%259D/%25E6%25A0%2591%25E4%25B8%258A%25E8%25B7%25AF%25E5%25BE%2584.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2E5 + 10;

vector<int> pos[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n ;
	cin >> n;
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		int x; cin >> x;
		pos[x].push_back(i);
		ans += 1LL * (n - i + 1) * (i / 2);
	}
	for (int i = 1; i <= n; i++) {
		ll low = 0 , high = pos[i].size() - 1;
		while (low < high) {
			if (pos[i][low] < n - pos[i][high] + 1) {
				ans -= (high - low) * pos[i][low];
				low++;
			}
			else {
				ans -= (high - low) * (n - pos[i][high] + 1);
				high --;
			}
		}
	}
	cout << ans << '\n';

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```