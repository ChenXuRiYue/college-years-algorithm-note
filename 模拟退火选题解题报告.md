
# [JSOI2004] 平衡点 / 吊打XXX
## 题目描述

如图，有 $n$ 个重物，每个重物系在一条足够长的绳子上。

每条绳子自上而下穿过桌面上的洞，然后系在一起。图中 $x$ 处就是公共的绳结。假设绳子是完全弹性的（即不会造成能量损失），桌子足够高（重物不会垂到地上），且忽略所有的摩擦，求绳结 $x$ 最终平衡于何处。

**注意**：桌面上的洞都比绳结 $x$ 小得多，所以即使某个重物特别重，绳结 $x$ 也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。

![](https://cdn.luogu.com.cn/upload/pic/148.png)

## 输入格式

文件的第一行为一个正整数 $n$（$1\le n\le 1000$），表示重物和洞的数目。

接下来的 $n$ 行，每行是 $3$ 个整数 $x_i, y_i, w_i$，分别表示第 $i$ 个洞的坐标以及第 $i$ 个重物的重量。（$-10000\le x_i,y_i\le10000, 0<w_i\le1000$）

## 输出格式

你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结 $x$ 的横坐标和纵坐标。两个数以一个空格隔开。

# 样例 1

### 样例输入 #1

```
3
0 0 1
0 2 1
1 1 1
```

### 样例输出 #1

```
0.577 1.000
```

## solve

**建立模型：**

1. 定义（x , y）为变量 ， 表示问题背景下的坐标（x , y）处。

2. 定义 $f(x , y)$ 表示点(x ， y)处受到的合力大小。

   目标为找到 $f(x , y) = 0$的解。即最小化目标函数。（合力的大小 ， 大于等于0）
3. 约束条件， x  , y皆为实数。

目标函数修正：

经过多次调整 ， 目标函数多次尝试如下：

1. $f_{x , y}$ ， 表示做功势能之和。
2. $g_{x , y}$ ， 表示合力。 

比较两种目标函数下的实现，发现相差无几。



**初始解选定：**
对所有点做一个点位置做一个平均作为初始解。显然是很合理的。一些简单的情况，如两点，一点等都是答案。 

**初温选定：**

1. ==定义一个充分大的值。==
2. 均匀抽样一组状态，以各状态目标值得方差为初值。
3. 随机产生一组状态，确定两两状态间的最大目标值差，根据差值，利用一定的函数确定初温度。
    根据经验，选取一个足够高，同时可以在较短时间内完成搜索的初温度。

这里根据经验，以及多组测试，选择3000为温度。

**温度更新函数：**

1. ==$t_{k + 1} = a\times t_k\quad  , k\ge 0 ,0 \lt a\lt 1$==
2. $t_k = \frac{K - k}{K}t_0$ , K 是总次数



**状态产生函数：**
基于当前领域结构内以一定的概率得到一个可以遍布全部解空间的候选解。

比较下面两种随机的方式：

```cpp
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
P next = res + P((rnd() % MAX * 2 - MAX) * T, (rnd() % MAX * 2 - MAX) * T);
```

```cpp
srand((unsigned int)time(NULL));
P next = res + P((rand() * 2 - RAND_MAX) * T, (rand()  * 2 - RAND_MAX) * T);
```
两种方式都有以下基本特点：
1. 两种方式都是随机的。
2. 两种方式的邻域范围都和温度的大小有关。随着温度的变小，邻域（二维平面下是一个圆），半径越来越小。

但是第一种方式下的搜索效果是非常不理想的。
**理由如下**
第一种方式的语法是完全随机的 （随机值域相当大，可能满足正太分布，但是取一个小mod数之后，就完全随机了。）
第二种方式，其数的大小（0 ... RAND_MAX）满足正态分布。 第一种方式的随机方式，使得这种近似于全局搜索。因此效果非常不理想。

**状态接受函数：**

$P = min(1 , e^{\frac{-\Delta c}{t}})$

**内循环终止准则设计：**

满足抽样稳定准则： 常见的准则有：

1. 检验目标函数的均值是否稳定。
2. 连续若干步的目标值变化较小。
3. ==按照一定的步数抽样。==

选取第3种，容易控制搜索时间。

**外循环终止准则设计：**

常见的原则有：

1. ==零度法.==
2. 循环总数控制法。
3. 基于不改进规则的控制法。
4. 接受概率控制法。

### 简单数据捏造：

**text 1**

in

```txt
3
0 0 1
0 2 1
1 1 1
```

out

```txt
0.577 1.000
```

**text 2**

in

```txt
4
0 0 1
0 2 1
2 2 1
2 0 1
```

out

```txt
1.000 1.000
```

**text 3**

![null (3)](null%20(3).png)

in 

```txt
16
0 0 1
1 0 1
2 0 1
3 0 1
4 0 1
4 1 1
4 2 1 
4 3 1
4 4 1
3 4 1
2 4 1
1 4 1
0 4 1
0 3 1
0 2 1
0 1 1
```

out

```txt
2.000 2.000
```

### code

**模拟退火SA**

```cpp
#include<iostream>
#include<vector>
#include<random>
#include<chrono>
#include<functional>
#include<iomanip>
using namespace std;

using db = double;

/*随机数接口。*/
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());

#define dbg cerr << res.x << " " << res.y << " " << __LINE__ << "\n";

const db EPS = 1E-15;
const int N = 10;
const int  MAX = RAND_MAX;

/*定义矢量：*/
struct P {
	db x, y;

	P() {}
	P(db _x, db _y) : x(_x), y(_y) {}

	P operator+(P p) { return { x + p.x , y + p.y }; }
	P operator-(P p) { return { x - p.x , y - p.y }; }
	P operator*(db d) { return { x * d , y * d }; }
	P operator/(db d) { return { x / d , y / d }; }

	db abs2() { return x * x + y * y; }
	db abs() { return sqrt(abs2()); }
	P unite() { return *this / abs(); }
};


/*模拟退火主要过程：*/
P SA(vector<pair<P, db>>& p) {
	/*目标函数， 定义为合力该点处最小*/
	function<db(P)> f = [&](P x) {
		P JoinForces = { 0 , 0 };
		for (auto t : p) {
			JoinForces = JoinForces + (t.first - x).unite() * t.second;
			//cerr << JoinForces.x << " " << JoinForces.y << "\n";
		}
		//cerr << __LINE__ << " " << JoinForces.abs() << "\n";
		return JoinForces.abs() * 114514;

	};
	function<db(P)> g = [&](P x) {
		double sum = 0;
		for (auto t : p) {
			P d = x - t.first;
			sum += d.abs() * t.second;
		}
		return sum;
	};
	/*保存当前的状态*/
	P res = { 0 , 0};
	//cerr << res.x << " " << res.y << "\n";
	/*定义初始状态：*/
	int n = p.size();
	for (auto& t : p) {
		res = res + t.first;
	}
	res = res / n;
	/*定义初始温度*/

	db T = 3000;
	/*由于采用的是零度法，防止精度导致死循环问题，定义略大于0的量。*/
	/*外层循环 ， 零度法*/
	// cerr << "最终合力为:  " << f(res) << "\n";

	db recw = f(res);;

	while (T > EPS) {
		/*内层循环 , 按照一定的步数取样*/
		// for (int i = 0; i < N; i++) {
		/*状态产生函数 ， 全局生半径为MAX的邻域附近的一个解;*/
		// P next = res + P((rnd() % MAX * 2 - MAX) * T, (rnd() % MAX * 2 - MAX) * T);
		P next = res + P((rand() * 2 - RAND_MAX) * T, (rand()  * 2 - RAND_MAX) * T);

		//cerr << next.x << " " << next.y << "\n";
		double cur = f(next);
		db Delta = cur - recw;
		/*更优则立刻更新*/
		if (Delta < EPS) {
			res = next;
			recw = cur;
		}
		else {
			/*计算出接受概率*/
			// cerr << Delta << "\n";
			db ReciveProbability = exp(-Delta / T);
			/*随机一个概率， 用来判断是否当前的概率*/
			// db sample = 1.0 * (rnd() % MAX) / (MAX - 1);
			db sample = 1.0 * rand();

			// cerr << __LINE__ << ReciveProbability << " " << sample << "\n";
               // 简单对式子处理， 避免精度问题。
			if (sample < ReciveProbability * RAND_MAX) {
				res = next;
				recw = cur;
			}
		}
		// dbg;
		// }
		T = 0.996 * T;
		/*计算状态接收概率:*/
		// cerr << "最终合力为： " << f(res) << "\n";
	}
	// cerr << "最终状态的合力： " << f(res) << "\n";
	return res;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n;
	cin >> n;
	vector<pair<P, db>> p(n);
	for (int i = 0; i < n; i++) {
		cin >> p[i].first.x >> p[i].first.y >> p[i].second;
	}
	srand((unsigned int)time(NULL));
	P res = SA(p);
	cout << fixed << setprecision(3);
	cout << res.x << " " << res.y << "\n";
}
```

**用于捏造其它数据的标程：**

选题并不是NP问题，也可以找到三分，二分， 计算几何的解法： 这些解法下得到的解是最优解，可以据此写个对拍来检验上述模拟退火算法的正确性：

==数据随机生成器：==

```cpp
#include<bits/stdc++.h>
using namespace std;

mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());

int main() {
	// freopen("input.txt", "r", stdin);
	freopen("data.txt", "w", stdout);

	int n = rnd() % 20;
	cout << n << endl;
	for (int i = 0; i < n; i++) {
		int x , y , w;
		x = rnd() % 100;
		y = rnd() % 100;
		w = rnd() % 100;
		cout << x << " " << y << " " << w << endl;
	}
}
```

对了几次拍之后，发现答案搜索到达的答案都是正确的。

==三分==

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<queue>
typedef double DB;
using namespace std;
DB ly, ry, x[1005], y[1005], w[1005];
int n;
DB dis(DB a, DB b, DB c, DB d)
{
	return sqrt((c - a) * (c - a) + (d - b) * (d - b));
}
DB work(DB X, DB Y)
{
	DB num = 0;
	for (int i = 1; i <= n; ++i)
		num += w[i] * dis(X, Y, x[i], y[i]);
	return num;
}
DB thre(DB X)//三分Y
{
	ly = -10000.0;
	ry = 10000.0;
	for (int i = 1; i <= 100; ++i)
	{
		DB del = (ry - ly) / 3.0;
		DB m1 = ly + del;
		DB m2 = ry - del;
		DB w1 = work(X, m1);
		DB w2 = work(X, m2);
		if (w2 < w1) ly = m1;
		else ry = m2;
	}
	return work(X, ly);
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
		scanf("%lf%lf%lf", &x[i], &y[i], &w[i]);
	DB lx = -10000.0;
	DB rx = 10000.0;
	for (int i = 1; i <= 100; ++i) //三分X
	{
		DB del = (rx - lx) / 3.0;
		DB m1 = lx + del;
		DB m2 = rx - del;
		DB w1 = thre(m1);
		DB w2 = thre(m2);
		if (w2 < w1) lx = m1;
		else rx = m2;
	}
	printf("%.3lf %.3lf", lx, ly);
	return 0;
}
```

==计算几何解法：==

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-9;
int sign(double a){return a<-eps?-1:a>eps;}//带eps的实数比较
struct Point
{
    double x,y;
    Point(double xx=0,double yy=0){x=xx,y=yy;}
    Point operator+(Point p){return Point(x+p.x,y+p.y);}
    Point operator-(Point p){return Point(x-p.x,y-p.y);}
    Point operator*(double d){return Point(x*d,y*d);}
    Point operator/(double d){return Point(x/d,y/d);}
    double dot(Point p){return x*p.x+y*p.y;}//点乘
    double det(Point p){return x*p.y-y*p.x;}//叉乘
    double abs2(){return x*x+y*y;}
    double abs(){return sqrt(abs2());}
    Point unit(){return sign(abs())==0?Point(0,0):(*this)/abs();}//单位向量，注意0向量的情况
    Point rot90(){return Point(y,-x);}//旋转90度，用来把受力方向转变成半平面
}p[1005],last[1005],ans[1005];
int n,w[1005],top_last,top_ans;
double cross(Point p1,Point p2,Point q)
{
    return (p2-p1).det(q-p1);
}
int crossOp(Point p1,Point p2,Point q){return sign(cross(p1,p2,q));}//用于判断q是否在p1p2的左侧
Point isLL(Point p1,Point p2,Point q1,Point q2)//直线交点
{
    double x=(p2-p1).det(q2-p1);
    double y=(q1-p1).det(p2-p1);
    return q1+(q2-q1)/(x+y)*y;
}
void cut(Point q1,Point q2)//半平面切凸包
{
    top_ans=0;
    int n=top_last;
    for(int i=1;i<=n;i++)
    {
        Point p1=last[i],p2=last[i%n+1];
        int d1=crossOp(q1,q2,p1),d2=crossOp(q1,q2,p2);//看这两个点与半平面的位置关系
        if(d1>=0)ans[++top_ans]=p1;
        if(d1*d2<0)ans[++top_ans]=isLL(p1,p2,q1,q2);
    }
    for(int i=1;i<=top_ans;i++)last[i]=ans[i];
    top_last=top_ans;
}
void work()
{
    int m=top_last;
    Point o(0,0);
    for(int i=1;i<=m;i++)o=o+last[i];
    o=o/m;//求的中心点，不知道有没有更优的取法，反正这样能AC
    Point P(0,0);
    for(int i=1;i<=n;i++)
        P=P+(p[i]-o).unit()*w[i];//p是受力方向
    if(P.abs()<=eps)//update
    {
    	printf("%.3lf %.3lf\n",o.x,o.y);
    	exit(0);
	}
    P=o+P.rot90();
    cut(o,P);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%lf%lf%d",&p[i].x,&p[i].y,&w[i]);
    last[1]=Point(-10000,-10000);
    last[2]=Point(10000,-10000);
    last[3]=Point(10000,10000);
    last[4]=Point(-10000,10000);
    top_last=4;
    for(int i=1;i<=60;i++)//二分
      work();
    printf("%.3lf %.3lf\n",last[1].x,last[1].y);
    return 0;
}
```
