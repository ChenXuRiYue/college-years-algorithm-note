---
字典树
用更加精确的概念学习
---



### 简介

又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

#### 应用

- 排序
- 统计、
- 处理前缀问题。

#### 数据结构内部方法：

==建树过程：==

insert()

1. 维护一个字符串集合。一一枚举字符串。
2. 从头节点开始，一层一层深入。（一个一个字符深入）
   1. 如果已经当前层字符已经存在，继续向前搜索。
   2. 如果当前没有，新建节点，并且指向当前节点。

==查询过程==

query()

1. 查询一个字符串的相关信息

   1. 是否存在
   2. 与维护字符集合的最大公共前缀。
   3. 当前查询字符串的个数。

==其它==
？？给队友就行。一般也不需要用到这更多的操作。

#### code

```cpp
const int N = 1E6 + 10;

struct node {
    int ch[26];//一般是26个字母小心出错。
    int cnt;    //当前节点以上前缀总和
} tree[N];
int tot;//管理记录节点。

void insert(string& s)
{
    //当前及检索的节点。
    int cur = 0;
    int len = s.size();
    for (int i = 0; i < len; i++)
    {
        int now = s[i] - 'a';
        if (tree[cur].ch[now] == 0)
        {
            tree[cur].ch[now] = ++tot;
        }
        cur = tree[cur].ch[now];
        tree[cur].cnt++;
    }
}

int query(string & s)
{
    int cur = 0;
    int len = s.size();
    int res = 0;
    for (int i = 0; i < len; i++)
    {
        int now = s[i] - 'a';
        if (tree[cur].ch[now] == 0 || tree[tree[cur].ch[now]].cnt < 2)return res;
        cur = tree[cur].ch[now];
        ++res;
    }
    return res;
}
/*
*1.注意维护什么信息。
*2.注意数组的大小。
*/
```



维护01序列的一个例子：

```cpp




// 注意数据的范围：
constexpr int N = 300000 * 31;
int cnt;
int trie[N][2];
// 字典树中trie对应状态下维护的key值。
int f[N][2];

// 新建节点： 只要工作是，初始化，以及返回新建节点的索引下标。
// 从而建立链表式的连接。

int newNode() {
	++cnt;
	trie[cnt][0] = trie[cnt][1] = 0;
	f[cnt][0] = f[cnt][1] = 0;
	return cnt;
}

void Trie_solve() {


	//初始化：
	cnt = 0;
	newNode();
	for (int i = 0; i < n; i++) {
		// x就是维护的01串。
		int x = a[i] ^ i;

		// 只需要考察29位置即可。因为必然是大于1E9得了。30 位的位权是：2E9.
		for (int j = 29 , p = 1; j >= 0; j--) {
			int v = x >> j & 1;
			/*后继性的检索信息。*/
			// 往下走。
			p = trie[p][v];
			if (!p) {
				break;
			}
		}
		for (int j = 29 , p = 1; j >= 0; j--) {
			int v = x >> j & 1;

			// 节点。发现当前前缀没有状态。
             // 1的前缀本质是空前缀。
			if (!trie[p][v]) {
				trie[p][v] = newNode();
			}

			p = trie[p][v];
			// 维护key
			// int &res = f[p][a[i] >> j & 1];
			// res = std::max(res, dp[i]);

		}
	}
}
```



   

