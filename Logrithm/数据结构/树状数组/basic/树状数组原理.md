### lowbit

#### 定义：

尾部的1000.串。0的个数可以为0.

#### 求法 ：

 `lowbit(x)=x&(-x);`(-x)其实是补码。

二进制的规律性质。是对模型充分感受后性质的挖掘。

### 树状数组

维护一个区间，支持操作： 单点加，查询前缀和。

可以做到O(log n)的复杂度。

存储形式是$c_1....c_n$的数组。

$c_i=\sum a_{i-lowbit(i)+1 ....i}$模拟一遍，情况如下：

![image-20230109155734424](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230109155734424.png)

模拟一遍，最后的结果如上。

---------------

#### one 查询操作。

对于 查询一段区间里面的值，

x

1. ans+=c[x];

2. x-=lowbit(x);
3. x==0退出否则回到第一步。

###### 原理如下

如下。假设区间为1....x

其中可以二进制表示。

比方说 为 10010011

可以通过  10010011+ 10010010 + 10010000 + 10000000 

​    1....10000000 +10000001....10010000+10010001....10010010.+10010011..10010011

其实就是贴着上界走。

###### code

```cpp
ll query(int x){
    ll sum=0;
    for(; x ; x-= x&(-x)){
        sum + = c[x];
    }
    return sum;
}
```



#### 修改操作

###### 原理

我们修改某一个点上地值。管理该点地所有区间都要进行修改。

那么c数组中的哪一个值管理了该点呢？

假设 x=10010

下面是不断寻父亲的序列。

 10100  -》  [10001,10100]

 11000  -》  [10001,11000]

100000 ->  [1,100000]

.......

如果当前已经出现了大于值的情况。

那么就及时的退出。

为什么？ 因为这点没有定义，我们构建的树只管理了存在定义的数组。虽然这个

c的定义是可以不断外延的。

###### code

```cpp
void modify(int x , ll d){
    for(: x <= n; x += x & (-x)){
        c[x]+=d; 
    }
}
```



#### 建树操作

最简单的方法是

对c{N]数组初始化为0

然后相当于在所有都为0的a数组上进行不断地修改数字地过程。

因此一边输入a[i].一边维护即可。

###### code

```cpp
const int N = 1E6 + 10;
int a[N];
ll c[N];
int n;

int init(){
    for(int i = 1; i <= n ; i++){
        cin >> a[i];
        modify( i , a[i]);
    }
}

```

#### 总模板

```cpp

using ll = long long;
const int N = 1E6 + 10;
int a[N];
ll  c[N];
int n;
//init地步骤灵活一点

ll query(int x){
    ll sum=0;
    for(; x ; x-= x&(-x)){
        sum + = c[x];
    }
    return sum;
}

void modify(int x , ll d){
    for(: x <= n; x += x & (-x)){
        c[x]+=d; 
    }
}

int init(){
    for(int i = 1; i <= n ; i++){
        cin >> a[i];
        modify( i , a[i]);
    }
}

```









