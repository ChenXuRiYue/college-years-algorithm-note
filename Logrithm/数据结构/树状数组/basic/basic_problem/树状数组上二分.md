https://www.luogu.com.cn/problem/P1168

向下扫描。不断地求取中位数。我们进行一个离散化类似于桶的思想。

用c数组记录数字的出现情况。那么向下扫描过程中。求取现在维护的集合的中位数。就变成了，在c中找到第一个前缀和小于k的边界。然后ans=k+1.

所以可以天然的用树状数组维护，并且在上进行二分操作。



```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int a[N];//元空间。
int n;
pair<int, int> dct[N]; //discretize.离散

void discretize() {
	for (int i = 1; i <= n; i++) {
		dct[i] = {a[i] , i};
	}
	sort(dct + 1 , dct + 1 + n);
	for (int i = 1; i <= n; i++) {
		a[dct[i].second] = i;
		//容易出错。
	}
}

int c[N];
//然后就是维护c[N]这个东西。
//这一个函数的不够熟练.前缀和小于等于k的u最后一个位置。如果是独立出现的。
//该解必定是目标解。但是我们应该怎么处理重复的情况。上面的逆序对是不做区分的
//因此这里可以做一个区分。
int query(ll x) {
	//查询第几大。
	int pos = 0;
	ll  t = 0;
	//18对应5e5
	//19对应1e6
	for (int i = 18; i >= 0; i--) {
		//t的水平一直是小于等于x的关系。
		if (pos + (1 << i) <= n && t + c[pos + (1 << i)] <= x) {
			pos += (1 << i);
			t += c[pos];
		}
	}
	// cout << pos << '\n';
	return pos;
}

void modify(int x , int d) {
	assert(x != 0);
	//访问所有的父亲节点。
	for ( ; x <= n; x += x & (-x)) {
		c[x] += d;
	}

}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	discretize();
	//现在的过程是扫描加处理。
	for (int i = 1 ; i <= n; i++) {
		modify(a[i], 1);
		// for (int i = 1; i <= n; i++)
		// 	cout << c[i] << ' ';
		//cout << '\n';
		if (i % 2) {
			//query((i + 1) / 2);
			cout << dct[query((i + 1) / 2 - 1) + 1].first << '\n';
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### 生长思考

- 将这个函数抽出来：

```cpp
//找到满足sum[i]<=x的边界。
int query(ll x) {
	int pos = 0;
	ll  t = 0;
	//18对应5e5
	//19对应1e6
	for (int i = 18; i >= 0; i--) {
		//t的水平一直是小于等于x的关系。
		if (pos + (1 << i) <= n && t + c[pos + (1 << i)] <= x) {
			pos += (1 << i);
			t += c[pos];
		}
	}
	// cout << pos << '\n';
	return pos;
}
```

