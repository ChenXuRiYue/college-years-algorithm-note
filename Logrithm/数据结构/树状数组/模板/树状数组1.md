### $\large BIT$

```cpp
class BIT {
public:
    ll c[(int)1E6 + 10];
    ll query(int x) {
        ll res = 0;
        for (; x ; x -= x & (-x))
            res += c[x];
        return res;
    }
    void modify(int x, ll d) {
        assert(x != 0);
        for (; x <= n; x += x & (-x)) {
            c[x] += d;
        }
    }
    int bineray_serach(ll x) {
        int pos = 0;
        ll  t = 0;
        //18对应5e5
        //19对应1e6
        for (int i = 18; i >= 0; i--) {
            //t的水平一直是小于等于x的关系。
            if (pos + (1 << i) <= n && t + c[pos + (1 << i)] <= x) {
                pos += (1 << i);
                t += c[pos];
            }
        }
        //dbg(pos)
        return pos;
    }
};
//树状数组求区间和公式：
//cout << (x + 1)*d1.query(x) - d2.query(x) - (x)*d1.query(x - 1) + d2.query(x - 1) << '\n';
//区间修改仔细点，前加后减。小心记错结论。
//求和问题非常容易溢出。
```

