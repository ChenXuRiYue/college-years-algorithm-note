# 路径最小值（启发式合并解法）

### 问题形式：

给一个n节点的树，每条边上有边权，给定q个询问u ， v 每次询问u  ， v上的最小值。

### solve

1. 首先是一个高明的贪心思路： 类似（krukals）算法：

   将边排序后，考虑慢慢的往考察访问一些边：维护已经得到的一系列的点集：

2. 当考察一条边之后： 对这些点集进行一个合并操作：

   1. 一些要求： 不能像普通的并查集一样进行一个简单的祖宗的合并。为了具体面向询问，必须具体的枚举到集合中涉及的所有问题。如果只是用简单的并查集，是不能自上而下精确定位到每一个集合中的元素的。必须对树所有点检查一遍祖宗。
   2. 采取启发式合并配合普通并查集的方法：
      1. 启发式合并： 通过枚举小的集合的点对应的询问，使得所有相关的询问被检索完，并且根据启发式合并的复杂度分析结果，每个查询问题，最多被访问log n复杂度次： 由于其访问当且仅当其端点被访问，合起来最多访问$2\times log(n)$遍。
      2. 并查集，可以快速从元素到集合标记的查询。启发式合并解决了，更细节的，从标记到元素的信息的维护与查询。

### code

```cpp
vector<array<int , 3>> edge;
// 维护集合中的询问。
vector<array<int , 2>> que[N];
int ans[N] , belong[N];
vector<int> vec[N];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , q;
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int u , v , w;
		cin >> u >> v >> w;
		edge.push_back({w , u , v});
	}
	for (int i = 1; i <= n; i++) {
		vec[i].push_back(i);
		belong[i] = i;
	}

	sort(edge.begin() , edge.end() , greater<array<int , 3>> ());
	// 然后维护集合以及询问。
	for (int i = 0; i < q; i++) {
		int u , v;
		cin >> u >> v;
		que[u].push_back({i , v});
		que[v].push_back({i , u});
	}
	for (auto[w , u , v] : edge) {
		// 然后对两个集合进行询问合并。
		// 确定到两个父亲节点。
		u = belong[u]; v = belong[v];
		if (vec[u].size() > vec[v].size()) swap(u , v);
		// 然后进行合并。
		// 首先基于询问进行一次合并。
		for (auto [id , to] : que[u]) {
			if (ans[id] != 0) continue;
			if (belong[to] == v) {
				ans[id] = w;
			} else {
				que[v].push_back({id , to});
			}
		}
		for (auto w : vec[u]) {
			vec[v].push_back(w);
			belong[w] = v;
		}
		que[u].clear();
		vec[u].clear();
	}
	for (int i = 0; i < q; i++) {
		cout << ans[i] << "\n";
	}
}
```

