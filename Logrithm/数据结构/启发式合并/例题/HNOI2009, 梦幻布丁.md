# HNOI2009, 梦幻布丁

[HNOI2009, 梦幻布丁 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/15/problem/816)

n个布丁摆成一行，进行m次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。
例如颜色分别为1,2,2,1的四个布丁一共有3段颜色。



## solve

维护各种布丁的集合： 合并的过程中，使用启发式合并的思想，合并小的布丁集合到大的布丁集合。

关键：

1. 合并集合：

   1. 看上去布丁颜色转变是单向的。选择更小的集合并入更大集合的操作是否可行？

      ：： 无论是哪个方向上的并入，最终布丁的颜色整体颜色结构不变。
      
      数组a上标记和颜色的标号一直保持1对1映射。这意味着：
      
      1. x ， y合并时，用 tag[x] 和用tag[y] 的最终效果是一样的。即可以使用启发式合并的方法。

2. 维护段数的方法：

   1. pre，颜色改变前的段数。
   2. 颜色改变：怎么维护颜色数目的变化？
   
   如下代码： 是一个trick。类似扫描的思想，维护块的变化。

## code

```cpp
int a[N];
vector<int> pos[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pos[a[i]].push_back(i);
	}
	int ans = 0;
	for (int i = 1; i <= n + 1; i++) {
		ans += a[i] != a[i - 1];
	}
	for (int i = 0; i < m; i++) {
		int op; cin >> op;
		if (op == 2) {
			cout << ans - 1 << "\n";
		} else {
			int x, y;
			cin >> x >> y;
			if (pos[x].size() > pos[y].size())
				pos[x].swap(pos[y]);
			if (x == y || pos[y].empty()) continue;

			int col = a[pos[y][0]];
			for (auto p : pos[x]) {
				// 怎么处理出这种段的变化？
				ans -= (a[p] != a[p - 1]) + (a[p] != a[p + 1]);
				a[p] = col;
				ans += (a[p] != a[p - 1]) + (a[p] != a[p + 1]);
				pos[y].push_back(p);
			}
			pos[x].clear();
		}
	}
}
```



































