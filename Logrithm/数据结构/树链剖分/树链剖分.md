# 树链剖分：

## 原理

将子树划分成若干的链进行管理：

1. 长链剖分
   1. 找子树最深的儿子，来形成链。

### 重链剖分

剖分方法：找最重的儿子（子树节点数最多），其连边划分为重边。

性质：

1. 从一个点往上走，子树大小翻倍。即最多只经过$O(log(n))$轻边。
2. 两个点之间的路径，被$O(log(n))$ 级别的轻边分割。于是，至多有$O(log (n))$段的划分。

![image-20230716104130770](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230716104130770.png)



因此维护的信息就是，上下纵横几段重边。

1. 某个点向上如果在重链上，记录该重链的链头。

### 树链剖分例题：

#### 树链剖分求LCA

观察重链剖分后的树形结构：两点的LCA无非以下两种情形：

1. 临近LCA 的两条相关边中，两边都是轻边，或有且仅有一条重边。其启发是，两个点都暴力的往上跳。



```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = (int)1E6 + 10;
vector<int> e[N];
int n , m;
int l[N] , r[N] , id[N];
int sz[N] , hs[N] , dep[N] , fa[N] , top[N] , tot;

void dfs1(int u , int f) {
	sz[u] = 1;
	hs[u] = -1;
	dep[u] = dep[f] + 1;
	fa[u] = f;

	for (auto v : e[u]) {
		if (v == f) continue;
		dfs1(v , u);
		sz[u] += sz[v];
		// 记录重儿子。
		if (hs[u] == -1 || sz[v] > sz[hs[u]]) {
			hs[u] = v;
		}
	}
}
// dfs序以及链头的位置。
void dfs2(int u , int t) {
	top[u] = t;
	l[u] = ++tot;
	id[tot] = u;
	if (hs[u] != -1) {
		dfs2(hs[u] , t);
	}
	for (auto v : e[u]) {
		if (v != fa[u] && v != hs[u]) {
			dfs2(v , v);
		}
	}
	r[u] = tot;
}
int LCA(int u , int v) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) v = fa[top[v]];
		else u = fa[top[u]];
	}
	if (dep[u] < dep[v]) return u;
	else return v;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	for (int i = 1; i < n; i++) {
		int u , v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs1(1 , 0);
	dfs2(1 , 1);
	int m; cin >> m;
	for (int i = 0; i < m; i++) {
		int u , v;
		cin >> u >> v;
		cout << LCA(u , v) << "\n";
	}
}
```

