# 李超线段树

参考博客：

[算法｜李超线段树初步（算法讲解+例题） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/64946571?utm_id=0)
[李超线段树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/li-chao-tree/)

## 算法介绍：

李超线段树是一种用于维护平面直角坐标系内线段关系得数据结构。它常被用来处理这样一种形式得问题：

> 给定一个平面直角坐标系，支持动态插入一条线段，询问从某个位置（x , +oo）能看到得第一个叫线段（即给定一条竖线x = k ， 问这条竖线于所欲线段得最高得交点。）



### solve

线段树维护每个点得最优势线段：
当插入一个线段时： 有以下几种情况：

对于修改，我们先把线段的值域分割到线段树的区间上，每次访问一个完整的包含在线段值域中的区间时：

1. 若当前区间还没有记录最优势线段，则记录最优势线段并返回。
2. 若当前区间的最优势线段被插入的线段完全覆盖，则把最优势线段修改为被插入线段并返回。
3. 若当前区间的最优势线段把被插入线断完全覆盖，则直接返回。
4. 若当前区间最优势线段与被插入线段有交，则先判断哪条线段在当前区间更优，并把更劣的线段下传到交点所在子区间。（交点两边的部分被这两条线段分别控制，而我们已经让在中点更优的那条线段作为区间最优势线段，因此更劣的那条线段只有可能在交点所在子区间超过当前区间的最优势线段）

### problems：

**板题：**
[P4097 [HEOI2013\] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4097)

**一些细节：**

1. 斜率计算出现了卡精度的问题： 自己定义一个判断大小关系的运算：如下：

```cpp
pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
```

或者重新定义一个比较运算如下：

```cpp
//防止精度问题导致相等关系的误判：
inline int check(double x , double y) {
	if (abs(x - y) < eps) return 0;
	else if (x < y) return -1;
	else return 1;
}
```

2. 直线相关的问题：

   1. 直线类定义：

      ```cpp
      struct line {
      	// 斜率 ， y上得交点纵坐标：
      	double k, b;
      	// 值域
      	int l, r;
      	// 当前节点上是否有纵坐标存在：
      	// 表示当前线段的编号：
      	int id;
           // 当前节点所代表的区间是否有优势直线：
      	int flag;
      } seg[4 * maxn]; //线段树的定义
      ```

      

      

   2. 求斜率：即添加直线时的信息记录：归于add函数：

   ```cpp
   line add(int x0, int y0, int x1, int y1) {
   	line now;
   	// 特判垂直：
   	now.id = ++cnt;
   	if (x0 == x1) {
   		now.k = 0;
   		now.b = max(y0, y1);
   	}
   	else {
   		now.k = 1.0 * (y1 - y0) / (x1 - x0);
   		now.b = y0 - now.k * x0;
   	}
   	now.l = x0;
   	now.r = x1;
   	now.flag = 1;
   	return now;
   }
   ```

3. 给定点，求直线上的纵坐标：求两直线的交点：

   ```cpp
   inline double calc(line a, int pos) {
   	return a.k * pos + a.b;
   } //计算某条线段在某一个横坐标的纵坐标值
   inline int cross(line a, line b) {
   	// 向下取整：
   	return floor((a.b - b.b) / (b.k - a.k));
   } //求两条线段交点的横坐标
   ```




**线段树部分：**

1. 使用过程中，主要修改的地方是：
   1. 直线中维护的信息：这里维护了编号，做多一点事情，但其实是差不多的。
   2. 

```cpp
// 自定义取最优运算函数，代替max
pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
//插入：
void modify(int now, int l, int r, line k)
{
	if (k.l <= l && r <= k.r) {
		// 当前线段覆盖区间;
		int resl = check(calc(k , l) , calc(seg[now] , l));
		int resr = check(calc(k , r) , calc(seg[now] , r));
		// 1. 当前区间上没有优势线段：直接标记即可：
		if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
		// 2. 考虑左右边界的情况，
		// 2.1 如果新插入线段左右边界都高： 说明更优：
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id , k.id);
		}
		// 类似相等的情况：
		// 2.2有相交：
		else if (resl == 1  || resr == 1) {
		int resl = check(calc(k, l), calc(seg[now], l));
		int resr = check(calc(k, r), calc(seg[now], r));
		if (not seg[now].flag) { seg[now] = k; }
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id, k.id);
		}
		else if (resl == 1 || resr == 1) {
			int mid = (l + r) / 2;
			// 中间位置的比较：
			int resmid = check(calc(k , mid) , calc(seg[now] , mid));
			if (resmid == 1) {
				line tmp = k; k = seg[now]; seg[now] = tmp;
			} else if (resmid == 0) {
				// 刚好在中点相交：
				if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
				else modify(now << 1 | 1 , mid + 1 , r , k);
				return;
			}

			// 交点在两侧：
			// 判断在哪一侧上：
			resmid = check(cross(k , seg[now]) , mid);
			if (resmid == -1) modify(now << 1, l, mid, k);
			else modify(now << 1 | 1, mid + 1, r, k);
		}
		}
		// 2.3 原来标记的线段更优：不做任何处理.
	}
	// 不覆盖区间，继续分割：
	else {
		int mid = (l + r) >> 1;
		if (k.l <= mid) modify(now << 1, l, mid, k);
		if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
	}
}

// 查询：
pair<double, int> query(int now, int l, int r, int x)
{
	//定位点：
	if (l == r)
		return { calc(seg[now], x) , -seg[now].id };
	else {
		// 不断下放置：
		int mid = (l + r) >> 1;
		pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
		if (x <= mid) {
			return dcmp(ans, query(now << 1, l, mid, x));
		}
		else
			return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
	}
}
```



#### **code1**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define fsio ios::sync_with_stdio(false);cin.tie(0);
#define double long double

const int inf = (int)1E9 + 7;
const ll INF = (long long)1E18 + 7;
const int N = 40000;
const int mod1 = 39989;
const int mod2 = 1E9;
const double eps = 1E-12;

const int maxn = mod1;
int cnt;
struct line {
	// 斜率 ， y上得交点纵坐标：
	double k, b;
	// 值域
	int l, r;
	// 当前节点上是否有纵坐标存在：
	// 表示当前线段的编号：
	int id;
	int flag;
} seg[4 * maxn]; //线段树的定义

pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
	// 表示接近相等
	double d = x.first - y.first;
	if (abs(d) < eps) {
		x.second = max(x.second , y.second);
	} else if (d < 0) {
		x = y;
	}
	return x;
}
inline double calc(line a, int pos) {
	return a.k * pos + a.b;
} //计算某条线段在某一个横坐标的纵坐标值
inline int cross(line a, line b) {
	// 向下取整：
	return floor((a.b - b.b) / (b.k - a.k));
} //求两条线段交点的横坐标
inline int check(double x , double y) {
	if (abs(x - y) < eps) return 0;
	else if (x < y) return -1;
	else return 1;
}
void modify(int now, int l, int r, line k)
{
	if (k.l <= l && r <= k.r) {
		// 当前线段覆盖区间;
		int resl = check(calc(k , l) , calc(seg[now] , l));
		int resr = check(calc(k , r) , calc(seg[now] , r));
		// 1. 当前区间上没有优势线段：直接标记即可：
		if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
		// 2. 考虑左右边界的情况，
		// 2.1 如果新插入线段左右边界都高： 说明更优：
		else if (resl == 1 && resr == 1) {
			seg[now] = k;
		}
		else if (resl == 0 && resr == 0) {
			seg[now].id = min(seg[now].id , k.id);
		}
		// 类似相等的情况：
		// 2.2有相交：
		else if (resl == 1  || resr == 1) {
			int resl = check(calc(k, l), calc(seg[now], l));
			int resr = check(calc(k, r), calc(seg[now], r));
			if (not seg[now].flag) { seg[now] = k; }
			else if (resl == 1 && resr == 1) {
				seg[now] = k;
			}
			else if (resl == 0 && resr == 0) {
				seg[now].id = min(seg[now].id, k.id);
			}
			else if (resl == 1 || resr == 1) {
				int mid = (l + r) / 2;
				// 中间位置的比较：
				int resmid = check(calc(k , mid) , calc(seg[now] , mid));
				if (resmid == 1) {
					line tmp = k; k = seg[now]; seg[now] = tmp;
				} else if (resmid == 0) {
					// 刚好在中点相交：
					if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
					else modify(now << 1 | 1 , mid + 1 , r , k);
					return;
				}

				// 交点在两侧：
				// 判断在哪一侧上：
				resmid = check(cross(k , seg[now]) , mid);
				if (resmid == -1) modify(now << 1, l, mid, k);
				else modify(now << 1 | 1, mid + 1, r, k);
			}
		}
		// 2.3 原来标记的线段更优：不做任何处理.
	}
	// 不覆盖区间，继续分割：
	else {
		int mid = (l + r) >> 1;
		if (k.l <= mid) modify(now << 1, l, mid, k);
		if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
	}
}


// 查询：
pair<double, int> query(int now, int l, int r, int x)
{
	//定位点：
	if (l == r)
		return { calc(seg[now], x) , -seg[now].id };
	else {
		// 不断下放置：
		int mid = (l + r) >> 1;
		pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
		if (x <= mid) {
			return dcmp(ans, query(now << 1, l, mid, x));
		}
		else
			return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
	}
}

line add(int x0, int y0, int x1, int y1) {
	line now;
	// 特判垂直：
	now.id = ++cnt;
	if (x0 == x1) {
		now.k = 0;
		now.b = max(y0, y1);
	}
	else {
		now.k = 1.0 * (y1 - y0) / (x1 - x0);
		now.b = y0 - now.k * x0;
	}
	now.l = x0;
	now.r = x1;
	now.flag = 1;
	return now;
}

int main() {
	fsio;
	int n;
	cin >> n;
	int lastans = 0;
	for (int i = 1; i <= n; i++) {
		int op; cin >> op;
		if (op == 0) {
			int k;
			cin >> k;
			int x = (k + lastans - 1) % mod1 + 1;
			// cout << x << "\n";
			cout << (lastans = -query(1, 1, N, x).second) << '\n';
		}
		else {
			int a, aa, b, bb;
			cin >> a >> aa >> b >> bb;
			int x0 = (a + lastans - 1) % mod1 + 1;
			int y0 = (aa + lastans - 1) % mod2 + 1;
			int x1 = (b + lastans - 1) % mod1 + 1;
			int y1 = (bb + lastans - 1) % mod2 + 1;
			// 如果有垂直得线应该怎么处理？
			// cout << x0 << " " << y0 << " " << x1 << " " << y1 << "\n";
			if (x0 > x1)swap(x0, x1), swap(y0, y1);
			// 1. 解决垂直线：
			// 2. 求出关于该线段的信息：
			// line now;
			modify(1, 1, N, add(x0, y0, x1, y1));
		}
	}
}
/*
6
1 1 2 5 6
1 1 2 3 4
1 1 3 2 2
1 1 2 2 3
1 1 1 5 8
0 2
*/
```

这个精度更稳一点：并且码风不错：但是似乎被一组数据hack了：

```cpp
#include <iostream>
#include <string>
#define MOD1 39989
#define MOD2 1000000000
#define MAXT 40000
using namespace std;
typedef pair<double, int> pdi;

const double eps = 1e-9;

int cmp(double x, double y) {
  if (x - y > eps) return 1;
  if (y - x > eps) return -1;
  return 0;
}

struct line {
  double k, b;
} p[100005];

int s[160005];
int cnt;

double calc(int id, int d) { return p[id].b + p[id].k * d; }

void add(int x0, int y0, int x1, int y1) {
  cnt++;
  if (x0 == x1)  // 特判直线斜率不存在的情况
    p[cnt].k = 0, p[cnt].b = max(y0, y1);
  else
    p[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), p[cnt].b = y0 - p[cnt].k * x0;
}

void upd(int root, int cl, int cr, int u) {  // 对线段完全覆盖到的区间进行修改
  int &v = s[root], mid = (cl + cr) >> 1;
  if (cmp(calc(u, mid), calc(v, mid)) == 1) swap(u, v);
  int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));
  if (bl == 1 || (!bl && u < v)) upd(root << 1, cl, mid, u);
  if (br == 1 || (!br && u < v)) upd(root << 1 | 1, mid + 1, cr, u);
}

void update(int root, int cl, int cr, int l, int r,
            int u) {  // 定位插入线段完全覆盖到的区间
  if (l <= cl && cr <= r) {
    upd(root, cl, cr, u);
    return;
  }
  int mid = (cl + cr) >> 1;
  if (l <= mid) update(root << 1, cl, mid, l, r, u);
  if (mid < r) update(root << 1 | 1, mid + 1, cr, l, r, u);
}

pdi pmax(pdi x, pdi y) {  // pair max函数
  if (cmp(x.first, y.first) == -1)
    return y;
  else if (cmp(x.first, y.first) == 1)
    return x;
  else
    return x.second < y.second ? x : y;
}

pdi query(int root, int l, int r, int d) {  // 查询
  if (r < d || d < l) return {0, 0};
  int mid = (l + r) >> 1;
  double res = calc(s[root], d);
  if (l == r) return {res, s[root]};
  return pmax({res, s[root]}, pmax(query(root << 1, l, mid, d),
                                   query(root << 1 | 1, mid + 1, r, d)));
}

int main() {
  ios::sync_with_stdio(false);
  int n, lastans = 0;
  cin >> n;
  while (n--) {
    int op;
    cin >> op;
    if (op == 1) {
      int x0, y0, x1, y1;
      cin >> x0 >> y0 >> x1 >> y1;
      x0 = (x0 + lastans - 1 + MOD1) % MOD1 + 1,
      x1 = (x1 + lastans - 1 + MOD1) % MOD1 + 1;
      y0 = (y0 + lastans - 1 + MOD2) % MOD2 + 1,
      y1 = (y1 + lastans - 1 + MOD2) % MOD2 + 1;
      if (x0 > x1) swap(x0, x1), swap(y0, y1);
      add(x0, y0, x1, y1);
      update(1, 1, MOD1, x0, x1, cnt);
    } else {
      int x;
      cin >> x;
      x = (x + lastans - 1 + MOD1) % MOD1 + 1;
      cout << (lastans = query(1, 1, MOD1, x).second) << endl;
    }
  }
  return 0;
}
```

[P4254 [JSOI2008\] Blue Mary 开公司 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4254)

### **灵活应用：**

斜率dp优化：

[「杂谈」关于斜率优化维护凸包 - do_while_true - 博客园 (cnblogs.com)](https://www.cnblogs.com/do-while-true/p/15404389.html)

### 板子

```cpp
struct line {
	// 斜率 ， y上得交点纵坐标：
	double k, b;
	// 值域
	int l, r;
	// 当前节点上是否有纵坐标存在：
	// 表示当前线段的编号：
	int id;
	int flag;
}; //线段树的定义

line add(int x0, int y0, int x1, int y1) {
	line now;
	// 特判垂直：
	now.id = ++cnt;
	if (x0 == x1) {
		now.k = 0;
		now.b = max(y0, y1);
	}
	else {
		now.k = 1.0 * (y1 - y0) / (x1 - x0);
		now.b = y0 - now.k * x0;
	}
	now.l = x0;
	now.r = x1;
	now.flag = 1;
	return now;
}
const int maxn = mod1;
struct LiChaoSegementTree {
	line seg[maxn * 4];
	pair<double , int> dcmp(pair<double , int> &x , pair<double , int> y) {
		// 表示接近相等
		double d = x.first - y.first;
		if (abs(d) < eps) {
			x.second = max(x.second , y.second);
		} else if (d < 0) {
			x = y;
		}
		return x;
	}
	inline double calc(line a, int pos) {
		return a.k * pos + a.b;
	} //计算某条线段在某一个横坐标的纵坐标值
	inline int cross(line a, line b) {
		// 向下取整：
		return floor((a.b - b.b) / (b.k - a.k));
	} //求两条线段交点的横坐标
	inline int check(double x , double y) {
		if (abs(x - y) < eps) return 0;
		else if (x < y) return -1;
		else return 1;
	}
	void modify(int now, int l, int r, line k)
	{
		if (k.l <= l && r <= k.r) {
			// 当前线段覆盖区间;
			int resl = check(calc(k , l) , calc(seg[now] , l));
			int resr = check(calc(k , r) , calc(seg[now] , r));
			// 1. 当前区间上没有优势线段：直接标记即可：
			if (!seg[now].flag)seg[now] = k, seg[now].flag = 1;
			// 2. 考虑左右边界的情况，
			// 2.1 如果新插入线段左右边界都高： 说明更优：
			else if (resl == 1 && resr == 1) {
				seg[now] = k;
			}
			else if (resl == 0 && resr == 0) {
				seg[now].id = min(seg[now].id , k.id);
			}
			// 类似相等的情况：
			// 2.2有相交：
			else if (resl == 1  || resr == 1) {
				int resl = check(calc(k, l), calc(seg[now], l));
				int resr = check(calc(k, r), calc(seg[now], r));
				if (not seg[now].flag) { seg[now] = k; }
				else if (resl == 1 && resr == 1) {
					seg[now] = k;
				}
				else if (resl == 0 && resr == 0) {
					seg[now].id = min(seg[now].id, k.id);
				}
				else if (resl == 1 || resr == 1) {
					int mid = (l + r) / 2;
					// 中间位置的比较：
					int resmid = check(calc(k , mid) , calc(seg[now] , mid));
					if (resmid == 1) {
						line tmp = k; k = seg[now]; seg[now] = tmp;
					} else if (resmid == 0) {
						// 刚好在中点相交：
						if (k.k < seg[now].k) modify(now << 1 , l , mid , k);
						else modify(now << 1 | 1 , mid + 1 , r , k);
						return;
					}

					// 交点在两侧：
					// 判断在哪一侧上：
					resmid = check(cross(k , seg[now]) , mid);
					if (resmid == -1) modify(now << 1, l, mid, k);
					else modify(now << 1 | 1, mid + 1, r, k);
				}
			}
			// 2.3 原来标记的线段更优：不做任何处理.
		}
		// 不覆盖区间，继续分割：
		else {
			int mid = (l + r) >> 1;
			if (k.l <= mid) modify(now << 1, l, mid, k);
			if (mid < k.r)  modify(now << 1 | 1, mid + 1, r, k);
		}
	}


// 查询：
	pair<double, int> query(int now, int l, int r, int x)
	{
		//定位点：
		if (l == r)
			return { calc(seg[now], x) , -seg[now].id };
		else {
			// 不断下放置：
			int mid = (l + r) >> 1;
			pair<double, int> ans = { calc(seg[now], x) , -seg[now].id };
			if (x <= mid) {
				return dcmp(ans, query(now << 1, l, mid, x));
			}
			else
				return dcmp(ans, query(now << 1 | 1, mid + 1, r, x));
		}
	}
} tree;
/*
主要修正过程:
1. add修改
2. 维护信息修改
3. 查询函数返回时，其运算修改：
*/




```

100行的板子：其实应该是80行：







