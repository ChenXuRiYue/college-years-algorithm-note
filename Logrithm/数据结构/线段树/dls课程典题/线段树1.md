http://oj.daimayuan.top/course/15/problem/654
除了一些实现bug。
代码写的很臭；
主要看几份代码
#### 比较以及生长

1. 代码长度上，为什么能够做到两倍：
因为自己没有写多了一些其它的懒惰标记维护。
另外，关于递归后，处理两个儿子时。其实进行的是两个区间信息的合并操作。这个操作在build和modify，change 都存在。
所以可以进行一个封装。加法封装。
一般而言，线段树只是管理者一个区间。因此不太需要引入一个类。面向过程即可。
目标是理解这种封装角度，以及在这种高度封装的模板上完成迁移，信息维护利用等等。
数据结构 应该这样学。用这样一套东西，面对新问题的时候知道该删哪改哪。这样就理解了数据结构的成员，行为。

##### 关于节点的定义：

线段树节点的定义。

```cpp
struct info{
    int minva;
    int micnt;
};
    
struct node{
    info val;
    type lazy;//懒惰标记
};
```





#### 当前问题dls的代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 201000;

int n, q;
int a[N];

struct info {
	int minv, mincnt;
};

info operator + (const info &l, const info &r) {
	info a;
	a.minv = min(l.minv, r.minv);
	if (l.minv == r.minv) a.mincnt = l.mincnt + r.mincnt;
	else if (l.minv < r.minv) a.mincnt = l.mincnt;
	else a.mincnt = r.mincnt;
	return a;
}

struct node {
	info val;
} seg[N * 4];

// [l, r]

void update(int id) {
	seg[id].val = seg[id * 2].val + seg[id * 2 + 1].val;
}

void build(int id, int l, int r) {
	if (l == r) {
		seg[id].val = {a[l], 1};
	} else {
		int mid = (l + r) / 2;
		build(id * 2, l, mid);
		build(id * 2 + 1, mid + 1, r);
		update(id);
	}
}

// 节点为id，对应的区间为[l, r]，修改a[pos] -> val
void change(int id, int l, int r, int pos, int val) {
	if (l == r) {
		seg[id].val = {val, 1};
	} else {
		int mid = (l + r) / 2;
		if (pos <= mid) change(id * 2, l, mid, pos, val);
		else change(id * 2 + 1, mid + 1, r, pos, val);
		// 重要‼️
		update(id);
	}
} 
// [ql, qr]表示查询的区间
info query(int id, int l, int r, int ql, int qr) {
	if (l == ql && r == qr) return seg[id].val;
	int mid = (l + r) / 2;
	// [l, mid] , [mid + 1, r]
	if (qr <= mid) return query(id * 2, l, mid, ql, qr);
	else if (ql > mid) return query(id * 2 + 1, mid + 1, r, ql,qr);
	else {
		// qr > mid, ql <= mid
		// [ql, mid], [mid + 1, qr]
		return query(id * 2, l, mid, ql, mid) + 
			query(id * 2 + 1, mid + 1, r, mid + 1, qr);
	}
}

int main() {
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		int ty;
		scanf("%d", &ty);
		if (ty == 1) {
			int x, d;
			scanf("%d%d", &x, &d);
			change(1, 1, n, x, d);
		} else {
			int l, r;
			scanf("%d%d", &l, &r);
			auto ans = query(1, 1, n, l, r);
			printf("%d %d\n", ans.minv, ans.mincnt);
		}
	}
}
```





#### 典型求区间和的问题：dls code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 201000;

int n, q;
int a[N];

struct node {
	int minv;
} seg[N * 4];

// [l, r]

void update(int id) {
	seg[id].minv = min(seg[id * 2].minv, seg[id * 2 + 1].minv);
}

void build(int id, int l, int r) {
	if (l == r) {
		seg[id].minv = a[l];
	} else {
		int mid = (l + r) / 2;
		build(id * 2, l, mid);
		build(id * 2 + 1, mid + 1, r);
		update(id);
	}
}

// 节点为id，对应的区间为[l, r]，修改a[pos] -> val
void change(int id, int l, int r, int pos, int val) {
	if (l == r) {
		seg[id].minv = val;
	} else {
		int mid = (l + r) / 2;
		if (pos <= mid) change(id * 2, l, mid, pos, val);
		else change(id * 2 + 1, mid + 1, r, pos, val);
		// 重要‼️
		update(id);
	}
} 
// [ql, qr]表示查询的区间
int query(int id, int l, int r, int ql, int qr) {
	if (l == ql && r == qr) return seg[id].minv;
	int mid = (l + r) / 2;
	// [l, mid] , [mid + 1, r]
	if (qr <= mid) return query(id * 2, l, mid, ql, qr);
	else if (ql > mid) return query(id * 2 + 1, mid + 1, r, ql,qr);
	else {
		// qr > mid, ql <= mid
		// [ql, mid], [mid + 1, qr]
		return min(query(id * 2, l, mid, ql, mid), 
			query(id * 2 + 1, mid + 1, r, mid + 1, qr));
	}
}

int main() {
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		int ty;
		scanf("%d", &ty);
		if (ty == 1) {
			int x, d;
			scanf("%d%d", &x, &d);
			change(1, 1, n, x, d);
		} else {
			int l, r;
			scanf("%d%d", &l, &r);
			printf("%d\n", query(1, 1, n, l, r));
		}
	}
}
```



#### 我的臭代码

```cpp
//维护区间中最小值出现的次数
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2E5 + 10;


//信息不够紧凑。
int a[N];
//维护信息
int mi[N << 2]; //维护区间中的最小值。
int c[N << 2]; //维护最小值出现的次数。
//修改管理。

int lz[N << 2];//懒惰标记。


//传递子树的信息。
//收集子树的信息。

//建树函数里面主要完成几种功能。
//一直往下递归。
//返回子区间信息
//整理两个子区间信息。称为合并操作。
void build(int no , int l , int r)
{
	if (l == r) {
		c[no] = 1;
		mi[no] = a[r];
		return;
	}
	int mid = (l + r) >> 1;
	build(no << 1, l, mid );
	build(no << 1 | 1, mid + 1, r);
	if (mi[no << 1] == mi[no << 1 | 1])
	{
		c[no] = c[no << 1] + c[no << 1 | 1];
		mi[no] = mi[no << 1];
	}
	else if (mi[no << 1] < mi[no << 1 | 1])
	{
		c[no] = c[no << 1];
		mi[no] = mi[no << 1];
	}
	else
	{
		c[no] = c[no << 1 | 1];
		mi[no] = mi[no << 1 | 1];
	}
}

void pd(int no, int l, int r) // 区间信息管理的节点编号。//左右区间。
{
	int mid = (l + r) >> 1;
	lz[no << 1] = lz[no << 1 | 1] = lz[no];
	c[no << 1] = (mid - l + 1);
	c[no << 1 | 1] = (r - mid);
	mi[no << 1] = mi[no << 1 | 1] = lz[no];
	lz[no] = 0;
}

void set_tag(int no , int l, int r, int k)
{
	lz[no] = k;
	mi[no] = k;
	c[no] = r - l + 1;
}
void modify(int no, int l, int r, int ql, int qr, int k)
{
	if (l >= ql && r <= qr)
	{
		set_tag(no, l, r, k);
		return;
	}
	if (lz[no]) {pd(no, l, r);}
	int mid = (l + r) >> 1;

	if (l <= qr && mid >= ql)
		modify(no << 1, l, mid, ql, qr, k);
	if ( mid + 1 <= qr && r >= ql)
		modify(no << 1 | 1, mid + 1, r, ql, qr, k);

	//进行更新：
	if (mi[no << 1] == mi[no << 1 | 1])
	{
		mi[no] = mi[no << 1];
		c[no] = c[no << 1] + c[no << 1 | 1];
	}
	else if (mi[no << 1] < mi[no << 1 | 1])
	{
		mi[no] = mi[no << 1];
		c[no] = c[no << 1];
	}
	else
	{
		mi[no] = mi[no << 1 | 1];
		c[no] = c[no << 1 | 1];
	}
}



//感觉这个查询不大方便。
//其实就是分成若干个块最终会分为若干个块。怎么处理这若干个块的信息呢？
//简单return一个int并不可以。因为合并的选择的时候要关注两个量。
//直接在全局里面定位两个？
struct node {
	int mi;
	int sum;
};
node query(int no  , int l, int r , int ql , int qr)
{
	if (l >= ql && r <= qr)
	{
		return {mi[no], c[no]};
	}
	if (lz[no])
		pd(no, l, r);
	int mid = (l + r) >> 1;

	node res = {int(1E9 + 10), 0};

	if (l <= qr && mid >= ql)
		res = query(no << 1, l, mid, ql, qr);
	if (mid + 1 <= qr && r >= ql)
	{
		node temp = query (no << 1 | 1, mid + 1, r , ql , qr);
		if (temp.mi == res.mi)
			res.sum += temp.sum;
		else if (temp.mi < res.mi)
			res = temp;
	}
	return res;
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i];

	build(1, 1, n);
	for (int i = 1; i <= m; i++)
	{
		int ty, x, y;
		cin >> ty >> x >> y;
		if (ty == 1)
		{
			modify(1, 1, n, x, x, y);
		}
		else {
			auto ans = query(1, 1, n, x, y);
			cout << ans.mi << ' ' << ans.sum  << '\n';
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

