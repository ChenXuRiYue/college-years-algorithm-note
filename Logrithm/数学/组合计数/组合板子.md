**组合数板子**

一共提供了四种求组合数的方法：资料来源于acwing

### **第一种方法：**性质+递推+预处理：

将组合数得计算分解为小规模得问题实现：
$$
C_{r}^{n} = C_{r-1}^{n}+C_{r-1}^{n-1}
$$
最小规模得子问题如$C_{r}^{0},C_{r}^{1}$已知（容易计算。）

然后就可以把所有情况求出来：

#### code

```cpp
const int N_c = 3E3;
const int mod = 1E9 + 7;
int c[N_c][N_c];
void C_init() {
    for (int i = 1; i < N_c; ++i) {
        c[i][0] = c[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
        }
    }
}
//注意范围
//小心me
```

#### tips

1. 数组范围允许。

#### 第二种方法： 逆元+预处理+组合数定义

#### basic

$$
C_{n}^{a}=\frac{n!}{(n-a)!\times b!}
$$

可以考虑先将分母得阶乘法求出。然后求出其逆元（由于mod是一个质数，逆元可以通过费马小定理求出。）

综上：时间复杂度：

$n+alog(a)$: 

[AcWing 886. 求组合数 II-数论-C++ - AcWing](https://www.acwing.com/solution/content/22076/)

#### code

```cpp
using ll = long long;
mod数 ， 数组大小相等？
const int N_c = 2E5 + 10;
const int mod = 1e9 + 7;

int fac[N_c] , infac[N_c];
ll quickly_pow(ll x, ll n, ll p)
{
	ll res = 1;
	while (n > 0)
	{
		if (n & 1)res = res * x % p;
		x = x * x % p;
		n >>= 1;
	}
	return res;
}
void init() {
	fac[0] = infac[0] = 1;
	for (int i = 1; i < N_c; i++)
	{
		fac[i] = 1LL * fac[i - 1] * i % mod;
		infac[i] = 1LL * infac[i - 1] * quickly_pow(i, mod - 2, mod) % mod;
	}
}
int c(int a , int b) {
	return 1LL * fac[a] * infac[b] % mod * infac[a - b] % mod;
}
/*
*记得初始化。
*/
```

