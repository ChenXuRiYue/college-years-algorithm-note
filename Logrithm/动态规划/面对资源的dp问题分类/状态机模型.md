### $\large basic$

- 状态机
  - 对研究对象抽象出有限状态。刻画有限状态，以及状态转换的理论工具。
- 状态机与动态规划：
  - 对于背包问题，面对一个物品，就是选与不选。只有两种状态。解方案比较简单。就是连续的简单的二叉树。
  - 对于更复杂的决策过程，对于资源（具体为一个物）它们对答案的贡献，比较复杂：比如说问题可以构造


-----



### $problem\_sets$

#### $\Large first大盗阿福$

```txt
阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。
这条街上一共有 N 家店铺，每家店中都有一些现金。
阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。
作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。
他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？
```

```txt
f[i]表示，窃取前i就家银行众多之中的最优方案。
f[1]=a[1];
f[2]=a[2];
f[i]=max(f[i-2]+a[i],f[i-1]);
```

####  $code:$

```cpp
    f[1] = a[1];
    f[2] = max(a[2], a[1]);
    for (int i = 3; i <= n; i++)
        f[i] = max(f[i - 1], f[i - 2] + a[i]);
```

##### 用y总的状态机模型来理解该问题；

- 对于一个子问题，想到一个集合。解就是该集合的最优解。

- 对于一个子问题，用一些椭圆之类的曲线来表示这些集合等。来辅助想象计算。
- 理解上述模型， $f_{i,{0,1}}$分别是关于$f_{i}$的两个状态。分别表示有没有选择尾部。其实就是借助状态机，进一步的描述了着当前集合中的方案。那么迁移如下：

$$
f_{i,1}=f_{i,0};\\
f_{i,0}=f_{i,1};\\
$$





----

#### $\Large second设计密码$

```txt
你现在需要设计一个密码 S，S 需要满足：

S 的长度是 N；
S 只包含小写英文字母；
S 不包含子串 T；
例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。

请问共有多少种不同的密码满足要求？
由于答案会非常大，请输出答案模 109+7 的余数。
```



#### $\Large third股票买卖IV$

##### 简介

```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
给定一个长度为N的数组，表示一个股票在第i天的价格，现在最多可以完成K笔交易。
不能同时进行多笔交易。（必须在再次购买之前售掉之前的股票）一次买入卖出合为一笔交易。 
```

##### 状态机模型分析

```
关注选择主体的状态机模型。
选到第i个的时候，已经有一系列的方案。
但是有两大类。
现在手上已经有股票了，现在没有股票。
手上有股票的手上的最多的钱。
手上没股票的手上最多的钱。
如果不用考虑当前的
f[i][1]->f[i-1][0]-a[i],f[i-1][1];
f[i][0]->f[i-1][1]+a[i].f[i-1][0];两种状态转移。
同时还要考虑当前正在进行了多少次交易。
f[i][j][1]->f[i-1][j][1],f[i-1][j-1][0]-a[i]
f[i][j][0]->f[i-1][j][0],f[i-1][j-1]+a[i];
```

##### 关键解决问题：

- 初始化问题：
  - 当前数组应该初始化为什么？
    - $0？$
    - $-inf$
  - 具体的看看迁移的情况？
    - 怎么快速的去看这种迁移的情况？
    - 表格作图法让不存在的状态必定被淘汰。
- 状态迁移问题。
  - 什么时候算第几轮交易？
    - 其实就是状态的设计问题：$f_{i,j,o/1}$表示在i天之前进行过j次的完整交易。$0/1$表示当前手上是否有股票。

##### $code$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;
int inf = -1e8 + 10;
int f[maxn][110][2];
int a[maxn];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, k;
    cin >> n >> k;
    // fill(f, f + sizeof(f), inf);
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= k; j++)
            f[i][j][1] = f[i][j][0] = inf;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    f[0][0][0] = 0; //表示第一天的时候。的选择情况。
    int ans = 0;
    for (int i = 1; i <= n; i++)     //
        for (int j = 0; j <= k; j++) //有几种情况，如果不是第一天买。
        {
            f[i][j][0] = f[i - 1][j][0];
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j][0] - a[i]);
            if (j)
                f[i][j][0] = max(f[i][j][0], f[i - 1][j - 1][1] + a[i]);
        }
    for (int i = 0; i <= k; i++)
        ans = max(ans, f[n][i][0]);
    cout << ans << '\n';
}
```

##### 生长思考

- 把握解空间的问题：
  - 细分为各种具体的子问题：
    - $f_{i,j,0/1}$表示当前前面已经进行了$j次$，当前是否持有股票的子问题的最优解。如果当前$j>=1$那么和前面更小的子问题$f_{i-1,j-1,0/1}$有关。当为0时，当前的问题就是最小的子问题。直接就可以知道解。$f_{i,0,0}=0,f_{i,0,1}=-a[i]$;
- 当前的初始化问题：
  - 所有不存在的状态，也就是没有解决的无意义的子问题，就让它为负无穷。这样我们的迁移求解过程就可以看作是有效状态一步一步向前解决更大规模子问题的过程。

##### 更新使用滚动数组优化。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 10;
const int inf = -1e8;

int f[maxn][2];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, k;
    cin >> n >> k;
    for (int i = 0; i <= k; i++)
        f[i][1] = f[i][0] = inf;
    f[0][0] = 0;
    for (int m, i = 1; i <= n; i++)
    {
        cin >> m;
        for (int j = k; j >= 0; j--)
        {
            f[j][1] = max(f[j][1], f[j][0] - m);
            if (j)
                f[j][0] = max(f[j][0], f[j - 1][1] + m);
        }
    }
    int ans = 0;
    for (int i = 0; i <= k; i++)
        ans = max(f[i][0], ans);
    cout << ans << '\n';
}
```

------

#### $\Large fourth 买卖股票V$

```txt
给出股票的N天的价格情况。
可以选择在第几天买卖
现在有两个限制：
第一个限制：  一次只能进行一次交易；
第二个限制：  进行交易之后，有一个冷冻期：就是刚卖完股票之后的第二天不可以再次购买股票：
```

- 与前面相比，一个人可能出现的状态变得更多，关系变得更加复杂。

##### 状态图进行分析：

- 状态详细分析：

  - 不持股票，没有在冷冻期；
  - 不持股票，当前在冷冻期。
  - 持有股票。

- 状态表示 

  $f_{i，0/1/2}$分别表示三种状态。

- 状态转移方程：

$$
如果不是第一次交易\\
f_{i,j,0}=max(f_{i-1,0},f_{i-1，2});\\
f_{i,1}=max(f_{i-1,1},f_{i-1,0}-a_i);\\
f_{i,j,2}=f_{i-1,1}+a_i;\\
对于不存在的状态所有都设置为-inf;\\
$$

##### $code$

```cpp
#include <bits/stdc++.h>
using namespace std;
void MAIN();
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
const int maxn = 1e5 + 10;
typedef long long ll;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------
int f[maxn][3];
int inf = -1e8;

void MAIN()
{
    int n;
    cin >> n;
    int k = (n >> 1) + 1;
    for (int i = 0; i <= k; i++)
        for (int l = 0; l < 3; l++)
            f[i][l] = inf; //初始化；
    f[0][0] = 0;
    for (int i = 1, m; i <= n; i++)
    {
        cin >> m;
        f[i][0] = max(f[i - 1][0], f[i - 1][2]);
        f[i][1] = max(f[i - 1][0] - m, f[i - 1][1]);
        f[i][2] = f[i - 1][1] + m;
    }
    int ans = 0;
    ans = max(ans, max(f[n][0], f[n][2]));
    cout << ans << '\n';
}
```

##### code滚动数组来进行优化：

```cpp
#include <bits/stdc++.h>
using namespace std;
void MAIN();
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
const int maxn = 1e5 + 10;
typedef long long ll;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------
int f[2][3];
int inf = -1e8;

void MAIN()
{
    int n;
    cin >> n;
    int k = (n >> 1) + 1;
    f[1][2] = f[1][1] = f[0][1] = f[0][2] = f[1][0] = inf;
    f[0][0] = 0;
    int now = 0;
    for (int i = 1, m; i <= n; i++)
    {
        now ^= 1;
        cin >> m;
        f[now][0] = max(f[now^1][0], f[now^1][2]);
        f[now][1] = max(f[now^1][0] - m, f[now^1][1]);
        f[now][2] = f[now^1][1] + m;
    }
    int ans = 0;
    ans = max(ans, max(f[now][0], f[now][2]));
    cout << ans << '\n';
}
```

#### $\large 最终总结生长思考：$

- 面向的问题背景:

  - y总引入状态机模型是面向一些选择的策略性问题的模型；

  - 对于选择到某一个阶段，有多种方案，其中一些方案的状态（某种属性，上一个选择了什么，一个方案选择了多少个等等一系列的问题。）
  - 当一类方案，在做出一些选择之后，这一类方案又转入下面的状态。

- 状态机模型对解决这一类问题的效力;

  - 更好的把握住状态之间关系；
  - 保证了子问题分析全面性；
  - 保证转移方程的正确性。

  







