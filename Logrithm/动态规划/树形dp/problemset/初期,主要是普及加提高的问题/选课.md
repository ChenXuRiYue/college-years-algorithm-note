##### 地址

[选课](https://www.luogu.com.cn/problem/P2014)

###### 简述

##### [CTSC1997] 选课

###### 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？

## 输入格式

第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \leq N \leq 300$ , $1 \leq M \leq 300$ )

接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \leq {k_i} \leq N$ , $1 \leq {s_i} \leq 20$）。

## 输出格式

只有一行，选 $M$ 门课程的最大得分。

## 样例 #1

### 样例输入 #1

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 样例输出 #1

```
13                                                                                       
```



##### 分析

- $d_{i,j}$表示，第i个节点为根的子树下，选择j门课能得到的最大学分。
- 假设更小规模的问题已经求出(子节点作为根子树的相关问题已经求解。)
- 尝试从一些问题中，计算得到，$d_{i,j}$；

```txt
d[i][h][j]表示，j门课以内，选择前h个子节点的方案得到的最大学分数。
当考虑选择第k个子节点中的某一个方案时候。这个方案m门课。选或者不选。
最优的方案中必然考虑
选-》满足两个标准的集合（1.属于前k-1个子树的方案。2.方案加起来不超过j-m门课集合。）我们只关注最大值，就是d[i][k-1][j-m];
不选-》d[i][k-1][j];
滚动数组优化得d[i][j-m],d[i][j];
假定d[i][0][0...j]存在，使用上面的状态迁移方式：第一步迁移中d[i][1][0..j]得到的都是真值。只选了一件且保证学分最多。

总结；
1.先递归计算出子节点的最优解。
2.根据上述顺序，进行更大子问题的求解。顺序。先枚举子节点，再枚举门数（0...m门即可。）
 d[i][j]=max(d[i][j],d[i][j-1]+d[u][1],....d[i][j-k]+d[u][k])(k<=j);
3.最后所有树的节点都已经求出，但是由于问题背景是一个森林。所以还要对每一棵树的根进行动态规划。和上述的动态规划方式一样。
```

##### code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 333;

//  树结构
struct node
{
    int to;
    int next;
} e[maxn << 1];
int head[maxn], tot;
void add(int x, int y)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
} //只需要关注到，新增加节点的位置指标即可。

int f[maxn][maxn], w[maxn]; //指标函数，每一个课的学分。
int n, m;
int dp[maxn];

void dp_on_tree(int now)
{
    for (int u = head[now]; u; u = e[u].next)
    {
        dp_on_tree(e[u].to);
        for (int j = m; j >= 1; j--)
            for (int k = 1; k <= j; k++) //表示第几个。
                f[now][j] = max(f[now][j], f[now][j - k] + f[e[u].to][k]);
    }
    for (int i = m; i >= 1; i--)
        f[now][i] = f[now][i - 1] + w[now];
}

int main()
{
    vector<int> rot; //存储树根的结构；
    cin >> n >> m;
    for (int i = 1, a; i <= n; i++)
    {
        cin >> a >> w[i];
        if (a)
            add(a, i);
        else
            rot.push_back(i);
    }
    for (auto i : rot)
        dp_on_tree(i);
    for (auto i : rot)
        for (int j = m; j; j--)
            for (int k = 1; k <= j; k++)
                dp[j] = max(dp[j], dp[j - k] + f[i][k]);
    cout << dp[m] << '\n';
}
```





