#### 地址

- (不算典型的树形$dp$，但是沾边。在树上的一些处理。利用前一层的结果，做一些推导。)

[族谱树](https://www.luogu.com.cn/problem/P7103)

#### 简介

- 给定一棵树
- 多次询问，同一层节点的最近公共祖先。

###### $20min$

```txt
first
由于用stl实现的邻接表常数比较大，考虑自定义一个数组存储起来的一个链表，来保存树结构。

解法一：
如果是普通的lca问题，一次查询复杂度将是logn.
但是同一层中，由于有非常多的节点，一次查询将会是nlogn
总的来说复杂度达到了      n*n*logn
直接完蛋；

树形dp的想法：
？？？？
之前遇到的大多是计算给定一个量的问题：
（快乐指数，和节点的选择有关。保留苹果树，和边的选择有关，二叉树加分，和节点的分布形式以及权有关。）
节点里面都有相关的权，而这一些量和节点的权，位置等等相关。子问题更好确立，且子问题的解就是一个量，也很好好保存，状态迁移方程，直接由简单的式子表示。
现在不一样。
```

###### 题解

- 要想得到正解，必须在当前题中挖掘性质。
- 关于性质
  - 定义$lca(k),表示第k层的公共祖先.deepth(u)表示以u为根的子树的最大深度$

$$
lca(k)=u，\\
利用上面的信息研究第k+1层的情况。\\
1.\quad lca(k+1)只可能出现在u为根的子树中。\\
2.\quad 根据子树的儿子来判定是lca(k+1)\\
$$

- 综上
  - 先计算出每一个节点作为根的子树的最大深度；
  - $lca(1)=1,lca(2)=1$;
  - 若已经确定了第$k$层的情况。继续确定第$k+1$层
    - 如果$lca(k)=u$. 
    - 有两个以上的儿子$w$,满足$depth(w)>=k+1$。那么$lca(k+1)=u$.
    - 没有一个满足上条件。此时最深也就只有$k$层。
    - 有一个记为$w$满足上条件。$lca(k+1)$出现在该子树中继续重复上步骤，知道出现第一个情况，没有儿子节点满足。

#### code

```cpp
#include <bits/stdc++.h>
using namespace std;


const int maxn = 5e6 + 10; //这里定
int ans[maxn];             //第几层的答案。
int depth[maxn];           //某个节点的参加。
int depth1[maxn];
int tem[maxn];
//
struct edge
{
    int no; //表示儿子。
    int next;
} e[maxn];
int head[maxn], tot; // total

void add(int x, int y)
{
    e[++tot].no = y;
    e[tot].next = head[x];
    head[x] = tot;
}
int dfs(int now) //第一遍先求出深度。
{
    depth[now] = depth1[now];
    for (int i = head[now]; i; i = e[i].next)
        depth1[e[i].no] = depth1[now] + 1, depth[now] = max(dfs(e[i].no), depth[now]);
    return depth[now];
}
// int dfs1(int now, int fa) //返回儿子的最大深度。
// {                         //一些非常细节的错误确实需要逐语句调试后才可发现。
//     depth[now] = depth1[now];
//     for (int i = head[now]; i; i = e[i].next)
//         depth[now] = max(depth[now], dfs1(e[i].no, now));
//     return depth[now];
// }
void dfs2(int k) //出ans计算第几层
{
    int la = 0;
    int sum = 0;
    for (int i = head[ans[k - 1]]; i; i = e[i].next)
        if (depth[e[i].no] >= k)
            sum++, la = e[i].no;
    if (sum == 0)
        return;
    if (sum == 1)
    {
        int aproach = la;
        while (sum <= 1)
        {
            if (depth1[aproach] == k)
                break;
            sum = 0;
            aproach = la;

            for (int i = head[aproach]; i; i = e[i].next)
                if (depth[e[i].no] >= k)
                    sum++, la = e[i].no;
        }
        ans[k] = aproach;
    }
    else
        ans[k] = ans[k - 1];
    dfs2(k + 1);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, q;
    cin >> n >> q;
    for (int i = 1, j; i <= n; i++)
    {
        cin >> j;
        add(j, i);
    }

    ans[1] = 1;
    depth1[1] = 1;
    dfs(1);
    dfs2(2);
    // for (int i = 1; i <= n; i++)
    //     cout << depth[i] << ' ';
    while (q--)
    {
        int k;
        cin >> k;
        cout << ans[k] << '\n';
    }
}
```



