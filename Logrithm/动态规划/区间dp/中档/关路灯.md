chenjiuri_guanludeng_qujiandpdd

https://www.luogu.com.cn/problem/P1220

#### 简介

- 大叔从某一点出发，开始关掉一条街上的路灯
- 关注两种属性，灯的功率，以及灯的位置。
- 大叔的移动速度为每秒钟1m.
- 尝试计算关完所有路灯的最小时间。

#### 20mins

- 区间dp或者搜索。没有什么思路。
  - 最小子问题。
  - 经历【c,c+1】的最小花费。
     - 直接可以计算。路程中的时间，以及乘上总功率。
     - 关于路程中得新增加花费问题可以通过段得功率和，以及行动得时间得到。
	- 设计子问题以及状态转移方程。
	   - 子问题，当前已经走完区间【i,j】,同时当前大叔在区间的左右侧的最小花费。

```cpp
#include <bits/stdc++.h>
using namespace std;

void MAIN();
int main()
{
    // ios::sync_with_stdio(false);
    // cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
typedef long long ll;
const int maxn = 2e5 + 10;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------

int x[0xfff];       //用来表示，每一个路灯的位置情况。
int w[0xfff];       //表示路灯的功率。
int f[100][100][2]; //指标函数。
int n, c;

int cal(int fi, int se, int now, int end) //计算相关大小。//需要用到什么参量区间左边点，区间右端点。起点终点。
{
    //起点终点。
    return (w[n] - (w[se] - w[fi - 1])) * abs(x[end] - x[now]); /*总功率乘以总时间*/
}

void MAIN()
{
    scanf("%d%d", &n, &c);
    // memset(f, 0x101, sizeof(f)); //这里有一个语法生长点
    // unsigned char *ptr = (unsigned char *)&f[0][0][0];
    // printf("%x", *ptr);
    // printf("%x", *(ptr + 1));
    // printf("%x", *(ptr + 2));
    // printf("%x\n", *(ptr + 3));
    // cout << f[1][1][0] << '\n';
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &x[i], &w[i]);
        w[i] += w[i - 1]; //其实这里是一个前缀和。
    }
    //初始化以及状态转移，设计相关的转移顺序。
    f[c][c][1] = f[c][c][0] = 0;
    for (int j = c; j <= n; j++)
        for (int i = j - 1; i > 0; i--)
        {
            f[i][j][0] = min(f[i + 1][j][0] + cal(i + 1, j, i + 1, i), f[i + 1][j][1] + cal(i + 1, j, j, i));
            f[i][j][1] = min(f[i][j - 1][0] + cal(i, j - 1, i, j), f[i][j - 1][1] + cal(i, j - 1, j - 1, j));
        }
    // printf("%d", &max(f[1][n][0], f[1][n][1]));
    cout << min(f[1][n][0], f[1][n][1]) << '\n';
}
```

#### 生长思考。

- 对于问题探究解空间。
  - 暴力枚举，当前状态中从左从右走一步进入下一个状态，知道把所有的路灯都关掉。
- 困惑是因为，没有感受到，这个迁移是否全面，准确。
  - 认识到，最终走完这一区间，终点只要关注终点在两端的一个结构即可。
  - 模拟一下。
  - 实践然后，模拟。
- 无论如何总之：
  - 最优对额结构上一步都是从两种解结构中迁移的。直接从两个端点到达目的点。
  - 区间性的一个路径问题，总是这样考虑走动的。
- 语法点的生长思考。
  - 对memset的认识更进一步。
    - 在语言点上做一个总结。
  - 使用c风格的输入输出。



