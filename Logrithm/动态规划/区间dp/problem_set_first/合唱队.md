#### 简介

```txt
对一个队伍
从第一个人检索，按照规则进行构造一个新的队伍：
如果当前的人比上一个人小放在右边，
如果当前的人比上一个人大放在队伍左边。

最终构造出来的队形明确：
初始队伍有多少种，可以构造出目标队伍？
```

#### $30mins$

```txt
处理一个小规模的子问题：
某一个小段构造有多少种初始的队列。
考虑最终的队伍的构建：
有两个迁移，1....n-1到n有多少种初始队列满足条件；
          2....n  到最终队列有多少种初始队列满足条件；
假设已经取得了小问题的解已经求出：
          发现应该更加细化问题，因为最后一步放在哪一边影响了，将要入队的对象和哪一个进行比较。影响了该解方           案是否可以接上去。
   f[i][j][0]以左边为尾，按照规则构造出的i---j初始化队列。
   f[i][j][1]以右边为尾，按照规则构造出i---j的初始化队列。
f[i][j][0]=(a[i]<=a[i+1]?f[i+1][j][0]:0)+(a[i]<=a[j]?f[i+1][j][1]:0);
f[i][j][1]=(a[j]>=a[i]?f[i][j-1][0]:0)+(a[j]>=a[j-1]?f[i][j-1][1]:0);
初始化问题：
    f[i][i][0]=1;
    注意只能初始化一个，否则会重复贡献；导致最终结果为两倍ans。
```

#### code

```cpp
#include <bits/stdc++.h>
using namespace std;

void MAIN();
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
typedef long long ll;
const int maxn = 1e3 + 10;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------

int f[maxn][maxn][2];
int a[maxn];
int mod = 19650827;

void MAIN()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        f[i][i][0] = 1;
        //f[i][i][1] = 1;
    }
    for (int i = 2; i <= n; i++)
        for (int j = 1, flag = n - i + 1; j <= flag; j++) //枚举区间起点；
        {
            int l = j, r = j + i - 1;
            f[l][r][0] = ((a[l] < a[l + 1] ? f[l + 1][r][0] : 0) + (a[l] < a[r] ? f[l + 1][r][1] : 0)) % mod;
            f[l][r][1] = ((a[r] > a[l] ? f[l][r - 1][0] : 0) + (a[r] > a[r - 1] ? f[l][r - 1][1] : 0)) % mod;
        }
    cout << (f[1][n][0] + f[1][n][1]) % mod << '\n';
}
```

#### 生长思考：

- 关于区间dp的理解；
  - 将大规模的问题分割为一些子问题：这一些子问题和小区间紧密相关。
- 区间问题常常出错点：
  - 对于区间右端点，左端点。误写，牛头不对马嘴。