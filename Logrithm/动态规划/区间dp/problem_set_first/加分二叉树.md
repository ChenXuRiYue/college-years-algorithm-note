#### $second$

###### [加分二叉树](https://www.luogu.com.cn/problem/P1040) 

- 简介

  ```txt
  计算的一颗二叉树的加分：具体规则如下
  左子树的加分*右子树的加分。
  如果子树为空，加分为1.
  叶子的加分为本身的分数。
  给出中序遍历：
  求满足所有该中序遍历的最大加分二叉树的最大加分和。
  并且输出前序遍历。
  ```

- 分析

  - 关于二叉树的几个概念，中序遍历，前序遍历。

  ```txt
  来源《数据结构辅导书》的遍历二叉树。
  遍历二叉树的实质是将二叉树进行线性化，即便里的结果是将非线性结构树中的节点排成一个线性序列。
  
  前序遍历：
  若二叉树为空，操作为空，否则：
  1.访问根节点：
  2.先序遍历左子树。
  3.先序遍历右子树。
  DLR
  
  中序遍历:
  若二叉树为空，操作为空，否则：
  1.中序遍历左子树：
  2.访问根节点：
  3.中序遍历右子树：
  
  后序遍历：
  若二叉树为空操作为空，否则：
  1.后续遍历左子树：
  2.后续遍历右子树：
  3.访问根节点：
  ```

- 惨痛教训—又读假题。

```txt
当一个中序确定时，并不代表着一棵树确定。每一个节点都可以作为二叉树的根。然后进一步分割，进一步确定其它的根。最终就完全确定，这一颗树的形状。

question，
当两个序都确定了是否就可以确定了一个树的形状？


可以认为区间dp问题。
解决的问题时 【1，n】的一个二叉树，并且使他的加分最大。

小规模问题  【l,r】->[l,k-1].[k+1,r].两种子树，两种个子树的最大加分。
规模前进   1 2 3---即可。最终可以得到f(1,n)的解。

求前序，记录每一个小区间的最优子树下的根。这样就可以确定一个具体的二叉树。
递归的完成。
```

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 40;
ll f[maxn][maxn]; //加分二叉树。
ll w[maxn];
int root[maxn][maxn];

void print(int x, int y)
{
    if (x > y)
        return;
    cout << root[x][y] << ' ';
    print(x, root[x][y] - 1);
    print(root[x][y] + 1, y);
}

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            f[i][j] = 1, root[i][j] = i; //针对一边界就是根部的情况。
    for (int i = 1; i <= n; i++)
    {
        cin >> w[i];
        f[i][i] = w[i];
    }
    for (int i = 2; i <= n; i++)             //枚举长度，
        for (int j = 1; j <= n - i + 1; j++) //枚举终点
            for (int k = j, tt = j + i - 1; k <= tt; k++)
            {
                ll temp = f[j][k - 1] * f[k + 1][tt] + w[k];
                if (temp >= f[j][tt])
                    f[j][tt] = temp, root[j][tt] = k;
            }
    cout << f[1][n] << '\n';
    print(1, n);
    cout << '\n';
}

```

###### 总结

- 这样一道不能算典型树形$dp$，按照这一种特殊情形之下，应该算区间$dp$。