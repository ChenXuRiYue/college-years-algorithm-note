#### 能量项链

[ad](https://www.luogu.com.cn/problem/P1063)

```txt
对于一串能量项链。
珠子有两个属性
头标记，尾标记。
相邻两颗珠子，第一颗珠子的尾标记等于另外一颗珠子的头标记。记为 h1 t1 t1 t2
两珠子合并时，释放出的能量等于 h1*t1*t2;
问怎么合并到最后一颗珠子使得释放出来的能量最大？
```

#### 20mins

- 首先做一步预处理，展开项链且使得，在手上面做动态规划于之等效。
- 考虑子问题，
  - $f_{i,j}:合并i到j的珠子，所得到的最大能量。$
  - 对于上述这个问题的方案可以划分为$[i,k],[k+1,j]$，上一步先合并的区间。对各个情况的子问题中解做max运算。
    - $f_{i,j}=max(f[i][j],f[i][k]+f[k+1][j]+w)$;
    - 对于$w$的计算，要注意各涉及的子问题上的一个具体方案。保持记录当前最有份方案的头尾标记jike。

#### code

```cpp
#include <bits/stdc++.h>
using namespace std;

void MAIN();
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
typedef long long ll;
const int maxn = 200 + 10;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------

int head[maxn][maxn], tail[maxn][maxn];
ll f[maxn][maxn];

void MAIN()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> head[i][i];
    for (int i = 1; i <= n; i++)
        tail[i][i] = head[i + 1][i + 1];
    // head,tail
    tail[n][n] = head[1][1];
    for (int i = n + 1; i <= 2 * n; i++)
    {
        head[i][i] = head[i - n][i - n];
        tail[i][i] = tail[i - n][i - n];
    }
    for (int len = 2; len <= n; len++)
        for (int low = 1, high = low + len - 1; high <= 2 * n; low++, high++)
            for (int mid = low; mid < high; mid++)
                f[low][high] = max(f[low][high], f[low][mid] + f[mid + 1][high] + head[low][low] * tail[mid][mid] * tail[high][high]);
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, f[i][i + n - 1]);
    cout << ans << '\n';
}
```

