https://www.luogu.com.cn/problem/P2679

chenjiuri_zichuanwenti

#### 20mins

- $f_{i,j,k}:当前1......i$这一段中，已经划分出k段的可以拼接成 1 .... j 的情况方案总数字。
- 转移方程：
  - 得关注是否为结尾才行。
  - 对于是否为结尾的情况的研究。
    - 专门开一个另外的结构来处理。记录一种特定的解
      - 这些解的尾部就是上一个字符。
      - $pre[j][k]$就可以满足需求。表示紧邻的，拼接成$B_{1...j}$的情况总数。
      - $f[j][k]$面向所有解。
    - 这样总的复杂度应该是$O(n*m^2)$
- 初始化：
  - 这个得先看转移方程的情况。
  - 从这上面一个角度看，$f_{0,0}=0$就是初始化。

-------------------------------------------

#### solve

- $f_{j,k}$就是所有符合题意得解。

- 计算问题（i，j，k）时：

  - 关注什么类型得解集？

  - 如果当前 i 和 j 之间不相等。那么就没有产生新的贡献。

    - 此时  $f_{i,j,k}=f_(i,j,k)$

  - 如果当前 i = j

    - 第一种解  ， 沿用之前的解。当前检查的字符不对答案进行贡献。
    - 第二种解   ， 新构造出的解。
      - 与前面的组成一块。
      - 在前提下进行枚举 1，2，3.....然后各种子状态规模问题的解。

    $$
    \forall p(A_{i-p}=B_{j-p},p=0.1.2.3.4...) \\
    sum_{i,j,k}=\sum ^{p+1}_{t=1}f_{i-t,j-p,k-1}
    $$

    - 另外的问题： sum怎么求？	
      - 挺复杂的，慢慢体会。

  

  

```cpp
#include <bits/stdc++.h>
using namespace std;

void MAIN();
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    MAIN();
}
typedef long long ll;
const int maxn = 2e5 + 10;
//------code-----٩(ˊωˋ*)و ------靓仔代码-----٩(ˊωˋ*)و ----talk is cheap , show me the code--------
ll f[210][210];
ll sum[210][210];
char a[1010], b[1010];
ll mod = 1000000007;
void MAIN()
{
    int n, m, ki;
    cin >> n >> m >> ki;
    cin >> a >> b;
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= 1; j--)
            for (int k = ki; k >= 1; k--)
            {
                f[j][k] = f[j][k] + (sum[j][k] = a[i - 1] == b[j - 1] ? sum[j - 1][k] + f[j - 1][k - 1] : 0); //第二种情况。就是长度相等。/
                f[j][k] %= mod;
            }
    cout << f[m][ki] << '\n';
}
```

