# 斜率优化DP

**问题背景：**
资源：若干个点：$(x_i , y_i)$
问题： 给定$a, b$ , 询问Max($ax_i + by_i$)
**solve**
可以将问题转换成，一个几何问题；在一个凸包上，移动一条斜率确定的直线，要求保证和点集有交集，寻找直线最大的y轴截距。（确定斜率直线和多边形的相切问题。）

##  problems
$\Large HNOI2008, 玩具装箱$
P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。
P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。
为了方便整理，P教授要求：

- 在一个一维容器中的玩具编号是连续的。
- 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。
制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。
### solve

**状态定义：**

$f_{i}$ 表示将1...i处理的最小代价：

**状态转移方程：**
$sum_i = sum_{i - 1} + c_i + 1$
$f_i = min(f_j + (sum_i - sum_j - L) ^ 2)$
![null (1)](null%20(1).png)
然后就转变成了一种斜率dp优化的形式：
一个方案对转移方程的贡献，受到其本身两个属性量的影响：如上有$f_j ， 和s_j$。进行一些等效变化，变成形如：$ax + by$的形式。其中$a , b$与i相关。 而x ， y都只与$j$的属性相关。
**问题1：分配x与y位置。**
$P_j = (s_j , s_j^2 + f_j)$
$k_i = -2\times s_i$

于是转换成了：$y - k\times x$ 的形式。

==生长== : 分配x , y可能影响了多边形凸壳 ， 以及下斜率的选择。综合从几何性质（dp过程中，凸壳维护的难度，斜率变化单调性等角度进行综合选择x ， y的选取。）

**问题2： 维护凸包**
观察出一些现象：发现每一次加点时，该点的横坐标是严格增加的。参考dls课程中凸壳的维护。可以通过不断地弹栈来维护凸壳。
**问题3： 确定最小值**
求解过程中，直线斜率不断增大。因此类似于一个点在凸包上滚动。可以使用单调队列维护，可能被切到的点。

**细节：**

1. 对L进行一个自增。将一些常量并入L ， 简化方程。
2. 初始化队列时要放入0。表示整个处理的方案点。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 1E6 + 10;
using db = double;
int n , L;
ll  f[N] , sum[N];
int que[N] , low , high;
inline ll X(int i) {
    return sum[i];
}
inline ll Y(int i) {
    return sum[i] * sum[i] + f[i];
}

inline ll K(int i) {
    return 2 * (sum[i] - L);
}
// bool check(int i , int j , ll k) {
// }
inline ll slope(int i , int j) {
    return (db)(Y(i) - Y(j)) / (X(i) - X(j));
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> L;
    L++;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        sum[i] = sum[i - 1] + x + 1;
    }
    /*初始化： 放入一个表示不选的点。该方案对应的点坐标就是0 ， 0*/
    low = high = 0;
    for (int i = 1; i <= n; i++) {
        ll k = K(i);
        while (low < high && slope(que[low] , que[low + 1]) <= k)
            low++;
        f[i] = f[que[low]] + (sum[i] - sum[que[low]] - L) * (sum[i] - sum[que[low]] - L);
        while (low < high && slope(que[high] , que[high - 1]) >= slope(i , que[high]))
            high--;
        que[++high] = i;
    }
    cout << f[n] << '\n';
}
```

-----

$\Large USACO2008 Mar, 土地购买$

![image-20230907095907924](image-20230907095907924.png)

### solve

![null (3)](null%20(3).png)

发现如果一个点的右上方有点，那么该点不用考虑。于是就转换成了类似上图的形式。

**状态定义：**
$f_{i}$ 处理完前i个点的最小代价。

**状态转移方程：**
$f_i = min(f(j - 1) + y_j \times x_i)$

**斜率dp优化：**

转移方程中，有两个独立的关于$f_{j - 1}$ j的属性是斜率dp的特征。 而$(i + j)^3$ 就显然不行。（i， j分别指的是和i ， j元素相关的属性量。）

对于斜率dp，点的映射方案的策略： 追求问题容易解决维护： 即转移过程中，加入的点的x坐标不断增大 ， 同时转移过程中查询的斜率也不断增大。

因此有下述转换：
$$
f_i = min(f(j -1) -x_i\times (-y_j))
$$
$X(j) : -y_i$
$Y(j): f(j - 1)$
$K(j) : x_i$

### code

```cpp
using db = double;
int n;
ll  f[N];
pair<int , int> p[N] , q[N];
int que[N] , low , high;
inline ll Y(int i) {return f[i];}
inline ll X(int i) {return -q[i + 1].second;}
inline ll K(int i) {return q[i].first;}
inline db slope(int i , int j) {
    return (db)(Y(i) - Y(j)) / (X(i) - X(j));
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x , y; cin >> x >> y;
        p[i] = {x , y};
    }
    sort(p + 1 , p + n + 1);
    /*对点预处理*/
    int m = 0 , mi = 0;
    for (int i = n; i >= 1; i--) {
        if (p[i].second <= mi) continue;
        mi = p[i].second;
        q[++m] = p[i];
    }
    reverse(q + 1 , q + m + 1);
    /*初始化： 放入一个表示不选的点。该方案对应的点坐标就是0 ， 0*/
    low = high = 0;
    for (int i = 1; i <= m; i++) {
        db k = K(i);
        while (low < high && Y(que[low + 1]) - Y(que[low]) <= k * X(que[low + 1]) - k * X(que[low]))
            low++;
        // f[i] = f[que[low]] + (sum[i] - sum[que[low]] - L) * (sum[i] - sum[que[low]] - L);
        f[i] = Y(que[low]) - k * X(que[low]);
        while (low < high && slope(que[high] , que[high - 1]) >= slope(i , que[high]))
            high--;
        que[++high] = i;
    }
    cout << f[m] << '\n';
}
```

