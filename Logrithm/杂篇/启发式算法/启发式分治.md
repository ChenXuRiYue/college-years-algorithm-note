这里只能称为启发式算法，而不是启发式合并。

# 好序列

一个序列被称为好序列的条件是，所有子区间都至少一个元素只出现了一次。给出一个序列，判断是否为启发好序列。

## solve

观察一些现象：

1. 首先关注一个序列中只出现了一次的元素。那么包含这个元素的区间都满足条件，于是只需要考虑其它的子区间。这样就可以将序列分成两个，继续进行check.
   1. 出现的问题：可能和快速排序一样，由于分的不均匀导致了总体的复杂度比较高。
2. 启发式的处理方法：
   1. 中间的唯一元素： 不需要比较快的找到该元素。
   2. 靠边的唯一元素， 花费比较小的代价去寻找。
   3. 这样用两种不同的方法寻找唯一元素，总的复杂度是$O(nlogn)$

**处理细节**

1. 找出唯一一次出现元素的方法：

   1. 指针记录相等元素上一次出现的位置，以及下一次出现的位置。（比较常见的一个结构。走投无路叠一些数据结构来处理的时候。可以考虑选择该数据结构。）

2. 启发式分治的实现：

   不单纯的从头到尾寻找中间元素（当前序列中只出现了一次的元素。）

   从两端一起for。下面有两种情况：

   1. 两端的元素比较快的就能找到这个元素。
   2. 寻找中间的元素对总的贡献的复杂度是接近$O(nlog n)$的。

   于是总体的复杂度是：

   $T(n) = T(x) + T(n - x) + O(min(x , n-x))$

   分析得： $T(n) = O(n\times log(n))$

   这个复杂度的证明方法： ？？



## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define fsio ios::sync_with_stdio(false);cin.tie(0);
const int N = (int)1E6 + 10;
const int inf = (int)1E9 + 10;
const ll INF = (long long)1E18 + 10;
int a[N] , pre[N] , suf[N];
bool solve(int l , int r) {
	if (l >= r) return true;
	for (int pl = l , pr = r; pl <= pr; pl++ , pr--) {
		if (pre[pl] < l && suf[pl] > r) {
			return solve(l , pl - 1) && solve(pl + 1, r);
		}
		if (pre[pr] < l && suf[pr] > r) {
			return solve(l , pr - 1) && solve(pr + 1 , r);
		}
	}
	return false;
}
bool solve() {
	int n;
	cin >> n;
	map<int , int> rec;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pre[i] = rec[a[i]];
		rec[a[i]] = i;
	}
	rec.clear();
	for (int i = n; i >= 1; i--) {
		if (rec[a[i]] == 0) {
			suf[i] = n + 1;
			rec[a[i]] = i;
		} else {
			suf[i] = rec[a[i]];
			rec[a[i]] = i;
		}
	}
	return solve(1 , n);
}
int main() {
	fsio
	int t; cin >> t;
	while (t--) {
		if (solve()) cout << "non-boring\n";
		else cout  << "boring\n";
	}
}
```





