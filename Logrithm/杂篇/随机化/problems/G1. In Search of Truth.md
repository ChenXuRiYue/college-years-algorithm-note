# G2. In Search of Truth (Hard Version)

[Problem - G2 - Codeforces](https://codeforces.com/contest/1840/problem/G2)

**The only difference between easy and hard versions is the maximum number of queries. In this version, you are allowed to ask at most $1000$ queries.**

This is an interactive problem.

You are playing a game. The circle is divided into $n$ sectors, sectors are numbered from $1$ to $n$ in some order. You are in the adjacent room and do not know either the number of sectors or their numbers. There is also an arrow that initially points to some sector. Initially, the host tells you the number of the sector to which the arrow points. After that, you can ask the host to move the arrow $k$ sectors counterclockwise or clockwise at most $1000$ times. And each time you are told the number of the sector to which the arrow points.

Your task is to determine the integer $n$ — the number of sectors in at most $1000$ queries.

It is guaranteed that $1 \le n \le 10^6$.

简易版和困难版的唯一区别在于最大查询次数。在这个版本中，您最多可以提出 $1000$个问题。

这是一个互动问题。

你正在玩一个游戏。圆圈被分成 $n$个扇形，扇形的编号按一定顺序从 $1$到 $n$。您在相邻的房间里，既不知道扇区的数量，也不知道它们的编号。还有一个箭头最初指向某个扇区。一开始，主持人会告诉你箭头指向的扇区的编号。之后，你可以要求主机逆时针或顺时针移动箭头 $k$ 个扇区，最多 $1000$ 次。每次都会告诉你箭头指向的扇区的编号。

你的任务是确定整数$n$--最多$1000$次查询的扇形数。

保证为 $1 \le n \le 10^6$。

### solve

[CF1840G2 In Search of Truth (Hard Version) - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/solution/CF1840G2)

### code

```cpp
const int N = 1E6 + 10;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
int ask(int x) {
	cout << "+ " << x << endl;
	cin >> x;
	return x;
}
void repose(int x) {
	cout << "! " << x << endl;
}
int vis[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int x;
	cin >> x;
	int mx = 0;
	for (int i = 1; i <= 333; i++) {
		x = ask(rnd() % 1000000000);
		mx = max(x , mx);
	}
	memset(vis , -1 , sizeof vis);
	vis[x] = 0;
	for (int i = 1; i <= 333; i++) {
		x = ask(1);
		if (vis[x] != -1) {
			repose(i);
			return 0;
		}
		vis[x] = i;
	}
	x = ask(mx);
	int ans = mx + 333;
	if (vis[x] != -1) {
		repose(ans - vis[x]);
		return 0;
	}
	while (true) {
		x = ask(333);
		ans += 333;
		if (vis[x] != -1) {
			repose(ans - vis[x]);
			return 0;
		}
	}
}
```