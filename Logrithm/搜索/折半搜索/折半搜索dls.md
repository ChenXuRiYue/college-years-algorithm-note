**折半搜索：**

其实双向dfs。这里得原理是： [双向搜索.md](..\DFS\双向搜索.md) 

由于复杂度不好控制 ， 基本已经在现代算法竞赛中绝迹了。但是其减少搜索规模得思想 ，角度要体会学习。

**生日悖论：**

基于图上得一个点：
对于一个点 ， 不断随机访问$\sqrt n$个点。期望上有一个点是相同的。

### 例题

**BSGS**求出指数方程：

问题形式：
$a^x \equiv  b(\% p)$ 

**思路**

1. x的可能范围是 $0...p-2$

将用$\sqrt p$的长度将定义域划分：

s , t表示快号 ， 以及块中的序号。那么有x = s*m + t

$a^{s*m + t} \equiv b (\% p)$

$(a^s)^m\equiv b*a^{-t}(\% p)$

然后枚举两边t可能出现的结果 ， 插入哈希表进行判断相等即可。

**背包**

经典的问题：上一个双向dfs的笔记中有。

 [送礼物.md](..\DFS\典型\送礼物.md) 

这里就折半从两边开始枚举所有结果 。
然后将两个二元组组成的集合。

1. 合并两个二元组集合即可。

*复杂度分析：*$O(2^{n/2})$

合并两个集合的方法：

1. 对每一组中排序，然后前缀和维护。双指针扫一遍即可。
2. 维护选择前i - 1个物品选取得到的集合。在这个集合上拓展出选择前i个的集合。然后拓展出新的一个有序的序列。复杂度分析：
   $O(2^0 + ..... + 2^{n/2})$得到两个有序的集合。然后同1前缀和 ， 双指针维护枚举即可。



#### 序列异或

[序列异或 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/30/problem/68)

#### solve

从折半的角度入手： 先处理a1 , a2。再对 a3 , a4 进行处理。
处理重复贡献： 
1. 认识到一种观念 ， 并非一定将a1 ,a2 计算完成之后 ， 才对答案进行贡献。统计过程中更新答案贡献。详细看代码的贡献转移细节。
```cpp
const int N = 1E4 + 10;
const int M = (1 << 20) + 10;
int a[N];
ll cunt[M];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	ll ans = 0;
	for (int b3 = 1; b3 <= n; b3++) {
		for (int b4 = b3 + 1; b4 <= n; b4++) {
			ans += cunt[a[b3] ^ a[b4]];
		}
		for (int b1 = 1; b1 < b3; b1++) {
			cunt[a[b1] ^ a[b3]]++;
		}
	}
	cout << ans << '\n';
}
```







