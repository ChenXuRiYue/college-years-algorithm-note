**装满的油箱**

##### 简介：

图上的求最小花费问题：涉及的一些概念如下：

1. N 个点 ， M条边。
2. 边权（点到点之间的油费。）
3. 点属性
   1. 点上可以加油。并且不同点（城市）上的油价不同。
4. 油量：对一辆车而言，其油箱的大小给出， 并且为 C。

#### 20mins

尝试不同的思路：

1. 普通bfs

   1. 从起点开始搜索。

   2. 基于状态，==发现==其余点。
   3. ~~尝试入队操作~~

   不能解决问题：理由如下：

   1. 不断发现其余点的过程中，其花费不一定为1。也不似双向队列面对的0 ， 1边权都有的模型。而是一系列的离散值。
   2. 油缸不一定加满，第一次发现的点的状态不一定满足最优状态。

2. 贪心：

   找到某一种最优策略的思路。不行：因为简单的关注当下的局部信息，不知道是否可达， 是否后续有更加便宜的油价。

3. 动态规划。

   **状态定义：$f_{u,w}$**

   到达u点还时还剩下w油的最小花费。

   转移顺序不太明确，类似于最短路算法，从已知最小状态进行更新。dijkstra算法。似乎不能算是动态规划。而是性质挖掘如下：

4. 优先队列bfs.

   定义状态：（u , w）表示到达u时还有w油的最小状态。每一次迁移之后，只有第一步是正解。因此使用单调队列维护，直到找到所有的解：

   复杂度约为：$(NC\times log(NC))\times Q$

   由于加了个log很可能会炸。$2\times10^8$

#### solve

正解就是第四种：

按照风格给出两种写法：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
#define fi first
#define se second

const int N = 1010 , C = 110;
vector<pii> g[N];
int d[N][C];
bool st[N][C];
int cost[N];

struct node {
	int d;
	int u;
	int c;
	bool operator<(const node& val)const {
		return d > val.d;
	}
};

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> cost[i];
	for (int i = 0; i < m; i++) {
		int u , v , w; cin >> u >> v >> w;
		g[u].push_back({v , w});
		g[v].push_back({u , w});
	}
	int q; cin >> q;
	// function<bool(const pii& , const pii&)> cmp = [](const pii & i , const pii & j)->bool{
	// 	return d[i.fi][i.se] > d[j.fi][j.se];
	// };
	while (q--) {
		int c , s , e; cin >> c >> s >> e;
		// priority_queue <pii , vector<pii> , function<bool(const pii& , const pii&)>> que(cmp);
		priority_queue<node>que;
		memset(d , 0x3f , sizeof d);
		memset(st , false , sizeof st);
		d[s][0] = 0;
		que.push({0 , s , 0});
		bool flag = true;
		while (que.empty() == false) {
			auto t = que.top(); que.pop();
			if (t.u == e) {flag = false; cout << t.d << '\n'; break;}
			if (st[t.u][t.c])continue;
			st[t.u][t.c] = true;
			if (t.c < c && d[t.u][t.c + 1] > d[t.u][t.c] + cost[t.u]) {
				d[t.u][t.c + 1] = t.d + cost[t.u];
				que.push({d[t.u][t.c + 1], t.u , t.c + 1});
			}
			for (auto [v , oil] : g[t.u]) {
				if (oil <= t.c && d[v][t.c - oil] > t.d) {
					d[v][t.c - oil] = t.d;
					que.push({t.d , v , t.c - oil});
				}
			}
		}
		if (flag) {
			cout << "impossible\n";
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
#define fi first
#define se second

const int N = 1E3 + 10;
struct node {
	int first;
	int second;
	int d;
};
vector<pii> g[N];
int d[N][110];
bool st[N][110];
int cost[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> cost[i];
	for (int i = 0; i < m; i++) {
		int u , v , w; cin >> u >> v >> w;
		g[u].push_back({v , w});
		g[v].push_back({u , w});
	}
	int q; cin >> q;
	auto cmp = [&](node & i , node & j) {
		return i.d > j.d;
	};
	while (q--) {
		int c , s , e; cin >> c >> s >> e;
		priority_queue < node , vector<node> , decltype(cmp)> que(cmp);
		memset(d , 0x3f , sizeof d);
		memset(st , 0 , sizeof st);
		que.push({s , 0 , 0});
		d[s][0] = 0;
		bool flag = true;
		while (que.empty() == false) {
			auto t = que.top(); que.pop();
			int u = t.fi , w = t.se;
			if (u == e) {flag = false; cout << d[u][w] << '\n'; break;}
			if (st[u][w])continue;
			st[u][w] = true;
			if (w < c && d[u][w] + cost[u] < d[u][w + 1]) {
				d[u][w + 1] = d[u][w] + cost[u];
				que.push({u , w + 1 , d[u][w + 1]});
			}
			for (auto [v , oil] : g[u]) {
				if (oil <= w && d[v][w - oil] > d[u][w]) {
					d[v][w - oil] = d[u][w];
					que.push({v , w - oil , d[u][w]});
				}
			}
		}
		if (flag) {
			cout << "impossible\n";
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 下面这一份非常像：

但是由于最大堆，最小堆管理上有点不同导致出错。见26行。lambda表达式的定义方式：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
#define fi first
#define se second

const int N = 1E3 + 10;
vector<pii> g[N];
int d[N][110];
bool st[N][110];
int cost[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> cost[i];
	for (int i = 0; i < m; i++) {
		int u , v , w; cin >> u >> v >> w;
		g[u].push_back({v , w});
		g[v].push_back({u , w});
	}
	int q; cin >> q;
	auto cmp = [&](pii & i , pii & j) {
		return d[i.fi][i.se] > d[j.fi][j.se];
	};
	while (q--) {
		int c , s , e; cin >> c >> s >> e;
		priority_queue < pii , vector<pii> , decltype(cmp)> que(cmp);
		memset(d , 0x3f , sizeof d);
		memset(st , 0 , sizeof st);
		que.push({s , 0});
		d[s][0] = 0;
		bool flag = true;
		while (que.empty() == false) {
			pii t = que.top(); que.pop();
			int u = t.fi , w = t.se;
			if (u == e) {flag = false; cout << d[u][w] << '\n'; break;}
			if (st[u][w])continue;
			st[u][w] = true;
			if (w < c && d[u][w] + cost[u] < d[u][w + 1]) {
				d[u][w + 1] = d[u][w] + cost[u];
				que.push({u , w + 1});
			}
			for (auto [v , oil] : g[u]) {
				if (oil <= w && d[v][w - oil] > d[u][w]) {
					d[v][w - oil] = d[u][w];
					que.push({v , w - oil});
				}
			}
		}
		if (flag) {
			cout << "impossible\n";
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```