**生日蛋糕**

[B-生日蛋糕_0x23 搜索-剪枝 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1015/B)

#### solve

1. 搜索框架是什么？

   往前枚举第i层。维护总体积以及上一层的半径高度。

2. 剪枝优化的角度。

   ​       从上到下标记为：1....dep -1

   1. 上下界限剪枝。确定两个状态变量的范围。
      $$
      R\in[dep,min(\sqrt{N-v},R_{dep+1}-1)]\\
      H\in[dep,min((N-v))/R^2,H_{dep+1}-1]
      $$
      

   2. 优化搜索顺序。倒叙搜索。

   3. 可行性剪枝：

      1. 什么情况时，必然无解？
         1. 更上层的状态贪心的选取最小：剩下的状态无论怎么构造，体积都不满足要求。

   4. 最优性剪枝：

      1. 如果当前已知的表面积已经大于等于已经搜索到的答案。
      2. 一些关于数学性质挖掘。如果已经确定了下体积，下面积。那么就可以找到最终体积的一个下界。与当前已经搜索到的最优答案进行比较，产生了剪枝的机会。

      $$
      体积情况\\
      V=n-v=\sum _{i=1}^{dep-1} r_i^2\times h_{i}^2\\
      侧面积情况：\\
      S=2\sum _{i=1}^{dep -1}r_i\times h_i \\
      S=\frac{2}{r_{dep}}\sum_{i=1}^{dep-1}h_{k}\times r_{k}\times r_{dep} \ge \frac{2}{r_{dep}}\sum_{i=1}^{dep-1}h_{i}*r_{i}^2\ge\frac{2(n-v)}{r_{dep}}
      $$

      $$
      s :当前表面积：\\
      \frac{2(n-v)}{r_{dep}}+s大于已经搜到的答案时就可以剪枝。
      $$

      

**更深刻的把握模型：**

搜索算法面对的状态可以看作一个多元组，其中每一元都是问题状态空间中的一个维度。

1. 针对每个维度与该维度的边界条件，加以缩放，推导，得出一个相应的不等式，来减少搜索树分支的扩张。
2. 对未来需要花费的代价需要进行预算。
3. 结合各维度的联系得到更加精准的剪枝。



#### code

高仿y总的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 30;
const int inf = 1E9;

int n , m;
//表示最小面积 ， 表示最小体积。
int mins[N] , minv[N];
int H[N] , R[N];//表示第i层的高度体积情况。
int ans = inf;

//dep当前的层数 , s当前的总体积。当前的总体积。
void dfs(int dep , int s , int v) {
	//终点情况
	//1.可行 —— 体积角度
	if (v + minv[dep] > n)return;
	//最优性剪枝
	if (s + mins[dep] >= ans) return;
	//最优性剪枝2
	if (2 * (n - v) / R[dep + 1]  + s >= ans) {return;}
	if (!dep ) {
		if (v == n)
			ans = s;
		return;
	}
	for (int r = min((int)sqrt(n - v) , R[dep + 1] - 1); r >= dep; r--)
		for (int h = min((n - v) / r / r , H[dep + 1] - 1); h >= dep; h--) {
			if (dep == m) s = r * r;
			H[dep] = h; R[dep] = r;
			dfs(dep - 1 , s + 2 * r * h , v + r * r * h);
		}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		minv[i] = minv[i - 1] + i * i * i;
		mins[i] = mins[i - 1] + 2 * i * i;
	}
	R[m + 1] = H[m + 1] = inf;

	dfs(m , 0 , 0);
	if (ans == inf) ans = 0;
	cout << ans << '\n';
}
```



