**送礼物**

[B-送礼物_0x24 搜索-迭代加深 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1016/B)

#### solve
其实是超大型的背包问题。子问题的重叠概率非常小，用双向搜索，对大部分进行考虑。

**复杂度分析**
直接体会，双向搜索的优越性：

1. 如果暴力直接搜索复杂度将会是：$2^{45}$

双向搜索：将数组分成两部分，分别对这两部分进行深搜。然后得到了一个结果：A数组保存了所有的结果：

1. 对这个数组进行排序。

第二次深搜：对于当前搜索出来的某一个值，二分上一次的数组情况。然后通过当前的数组情况进行一个二分，找到当前方案下一个最接近$2^{31}-1$的解。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = (1 << 24) + 10;
const ll mx = (1LL << 31) - 1;
int n , m;
int w[50];
int rec[N] , cnt = 0;
int k;
int ans = 0;

void dfs1(int u , int sum) {
	if (u == k) {
		rec[cnt++] = sum;
		return;
	}
	if ((ll)sum + w[u] <= m) {
		dfs1(u + 1 , sum + w[u]);
	}
	dfs1(u + 1 , sum);
}

void dfs2(int u , int sum) {
	if (u == n) {

		int id = upper_bound(rec , rec + cnt , m - sum) - rec - 1;
		if (id >= 0 && rec[id] + sum <= m)
			ans = max(ans , rec[id] + sum);
		return;
	}
	if ((ll) sum + w[u] <= m) {
		dfs2(u + 1 , sum + w[u]);
	}
	dfs2(u + 1 , sum);;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> m >> n;
	for (int i = 0; i < n; i++) {
		cin >> w[i];
	}
	sort(w , w + n , greater<int>());
	k = n / 2;
	dfs1(0 , 0);
	sort(rec , rec + cnt);
	cnt = unique(rec , rec + cnt) - rec;
	dfs2(k , 0);
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

