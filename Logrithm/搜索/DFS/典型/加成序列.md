**加成序列**

[170. 加成序列 - AcWing题库](https://www.acwing.com/problem/content/172/)

#### solve

观察这一个模型发现：

1. 用二进制的角度。先在数组中搞出1 2 4 8 16 32 64 利用上述的做多4个就可以组合出100 以内的所有情况。因此m小于等于14
2. 对于某一个节点，分支特别的多。下方的搜索框架，确定一个点，要枚举前面数组的所有的二元组。分支达到10000以上的级别

因此上述符合迭代加深擅长模型：

**步骤**

1. 搜索框架：
   1. 当前构造到了第几个数字。
   2. 利用当前已经构造出的序列来枚举下一个数。
2. 剪枝方案
   1. 顺序剪枝。从大到小枚举方案。
   2. 判断重复。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 110;

int n;
int path[N];
int depth = 1;

bool dfs(int dep) {
	if (dep == depth)
		return path[dep - 1] == n;
	vector<bool> rec(n + 1 , 0);
	for (int i = dep - 1; i >= 0; i--)
		for (int j = i; j >= 0 ; j--) {

			int t = path[i] + path[j];
			if (t > n || rec[t] || t <= path[dep - 1]) continue;
			rec[t] = true;
			path[dep] = t;
			if (dfs(dep + 1))return true;
		}
	return false;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	path[0] = 1;
	while (cin >> n , n) {
		depth = 1;
		while (!dfs(1)) {
			depth++;;
		}
		for (int i = 0 ; i < depth; i++) {
			cout << path[i] << " \n"[i == depth - 1];
		}
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

