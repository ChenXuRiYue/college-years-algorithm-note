**小猫爬山**
https://ac.nowcoder.com/acm/contest/1014/A

#### solve

数据范围比较小尝试枚举所有的可能。
1. 怎么暴力枚举？
   1. 单纯划分。比较困难 ， 因为管理每一组维护要比较大的花费。
   2. 关注结构更多的属性。枚举到第now个。并且前面的所有的猫已经分成了k组。（组的打标记方式并不会影响结果。因此直接枚举）
      1. 该角度，可以通过回溯，方便维护。并且有序枚举，是比较优秀的枚举方法；
2. 一些小优化：
   1. 顺序上进行优化：减少分支：
      1. 从重的猫先开始枚举。然后可以有效的减少初始的分支数目。这样可以更快的减去不合法解。
   2. 及时剪枝。如果当前枚举状态的cnt已经大于等于ans就没有必要继续枚举下去了。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int a[N] , c[N] , ans = N;
int  n , m;

void dfs(int now , int cnt) {
	if (now == n + 1) {
		ans = min(ans , cnt);
		return;
	}
	//剪枝
	if (cnt > ans) return;
	for (int i = 1; i <= cnt + 1 ; i ++) {
		if (c[i] + a[now] <= m ) {
			c[i] += a[now];
			dfs(now + 1 , cnt + (i > cnt));
			c[i] -= a[now];
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1 , a + 1 + n , greater<int>());
	dfs(1 , 1);
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

