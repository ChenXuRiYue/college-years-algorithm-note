# 多边形

[TOC]

## 基础概念：

1. 面积
2. 点包含
3. 凸包
4. 凹包
5. 旋转卡壳

**算法竞赛背景下，讨论的多边形：**

1. 简单多边形：
2. 凸多边形
### 面积

多边形面积公式：给定每一个点的坐标，有： 
$$
S=\frac{1}{2} \sum _{i =0}^{n -1} P_{i}\times P_{(i +1)\%n}
$$
方向规定为，逆时针方向。如果题意中没有给定正逆时针方向，则求出面积后取绝对值即可。

**简单证明：**

1. 对于凸多边形：叉积刚好是平行四边形面积。然后算一圈，相当于算出了两倍的面积。并且逆时针方向，其$sin\theta >0$ 。 如果不在中心点上，就有一个简单的容斥。
2. 对于简单多边形： 按照逆时针顺序连边，不断地求平行四边形，可以感受到一些容斥规律。加多了，在后面会减回来。反之 ， 减多了，后面求取过程中也会补回。

**严格证明**
可以通过格林公式证明。

#### 实现代码：

```cpp
db area(vector<P> ps){
	db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); 
	return ret/2;
}
```

### 点包含

**凸多边形：**

类似求正方形地顺序： 与响铃顶点连边，点之间的逆时针顺序和对应连边的逆时针顺序统一。

判断一个点是否在多边形内部的经典问题：

![凸边形点包含内部](%E5%87%B8%E8%BE%B9%E5%BD%A2%E7%82%B9%E5%8C%85%E5%90%AB%E5%86%85%E9%83%A8.png)

![外部](%E5%A4%96%E9%83%A8-1693302252079-3.png)

**简单多边形：** 

1. 射线法：

![null (1)](null%20(1).png)

一条线穿过多边形，往往会经过几个节点：
如果源点在内部，经过奇数个节点， 射点在外部经过偶数个节点。
但是有以下特殊情况：

![草稿](%E8%8D%89%E7%A8%BF.png)

如上： 有几种特殊情况：

1. 射线和多边形的一条直线重合。
2. 考察点就在线段或者节点中。
3. 射线经过的一些点刚好是一个角。

上述几种情况都不适应第一个结论：
有一种很高明的方法，可以处理掉上述所有情况：

**细节：**

**约定：**
1. 射线的方向是水平向右的。
2. u点纵坐标大于v点：

**方法：**
我们考虑将当前的考察点向下做一个无穷小的偏移：在点与点距离都确定的情况下。假定做了这些无穷小量的偏移之后，有以下现象：

**现象：**
1. 点的内外不会发生变化。
2. 如果点处于上述中的某一种情况，做出偏移之后就会被打破。
3. 显然不会有新的部分会进入上述情形：

但是事实上，这种偏移的细节实现起来是很麻烦的：

1. 无穷小量难以把握。
2. 精度问题。

但是我们可以定性的研究这种情况：在枚举这些边的过程中，如当前点刚好属于该边的下边界，则该点就判定为不属于当前边。如果刚好处于一个角上。会被判定为经过了两条边。相当于这个点对该边的判定没有影响。

**实现细节：**

1. 枚举一条边，同时注意射线的方向。这个可以通过求叉积确定符号来配合判定实现。

实现代码如下：

#### 实现代码：

```cpp
int contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside
	int n = ps.size(), ret = 0; 
	rep(i,0,n){
		P u=ps[i],v=ps[(i+1)%n];
		if(onSeg(u,v,p)) return 1;
		if(cmp(u.y,v.y)<=0) swap(u,v);
		if(cmp(p.y,u.y) > 0 || cmp(p.y,v.y) <= 0) continue;
		ret ^= crossOp(p,u,v) > 0;
	}
	return ret*2;
}
```

### 凸包

**严格定义：** 
图形学中的概念： 在一个实数[向量空间](https://baike.so.com/doc/6591614-6805393.html)V中，对于给定集合X，所有包含X的凸集的交集S被称为X的**凸包**。

**感性认知：**
刚好一个包住所有点的橡皮筋。（这显然是凸多边形的。）

**求凸包过程**

1. 上凸壳，下凸壳分开求。
2. 将点按照pair<int , int> 默认的顺序进行升序。
3. 将一个整体的问题转变为，点的资源逐渐变化，维护下凸壳的变化。

![草稿 (1)](%E8%8D%89%E7%A8%BF%20(1).png)

求完下凸壳之后 ， 求上凸壳。但是注意此时考察点的顺序是逆向的。这样有利于利用之前的栈结构。同时使得求出的多边形点的数组，正好是逆时针方向。

**补充：**

将凸壳分成两类：
1. 严格凸的： 共线情况要避免。即避免$\pi$
   1. 要注意点重复的情况。如果点重复会导致如下问题：

   

2. 非严格凸：

    ![草稿 (2)](%E8%8D%89%E7%A8%BF%20(2).png)

   这种情况下也会判对。因为点向量和任何向量共线。

#### code

```cpp
vector<P> convexHull(vector<P> ps) {
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
vector<P> convexHullNonStrict(vector<P> ps) {
	//caution: need to unique the Ps first
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
```



### 切凸多边形

给一条边，将凸多边形切成两边。求出这两块凸多边形：

**求解：**
按照点对于直线顺逆时针方向，分类成两块。

![草稿 (3)](%E8%8D%89%E7%A8%BF%20(3).png)

#### code

使用细节： 注意最后返回的是切线的逆时针方向上的多边形。所以切的时候，要注意切线边的方向：

```cpp
vector<P> convexCut(const vector<P>&ps, P q1, P q2) {
	vector<P> qs;
	int n = ps.size();
	rep(i,0,n){
		P p1 = ps[i], p2 = ps[(i+1)%n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if(d1 >= 0) qs.push_back(p1);
		if(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));
	}
	return qs;
}
```

### 旋转卡壳：

**问题描述**给定一个点集合 ， 找到欧几里得最远的两个点。

**求解**

1. 所求的两个点 ， 必定是分别分布于凸包上的：

![旋转凸壳关键1证明](%E6%97%8B%E8%BD%AC%E5%87%B8%E5%A3%B3%E5%85%B3%E9%94%AE1%E8%AF%81%E6%98%8E.png)

显然最长距离涉及的两个点，是在一系列两条平行线切多边形的切点中产生。只需要找出这些点对即可。

![草稿 (4)](%E8%8D%89%E7%A8%BF%20(4).png)

但是我们显然不可以枚举这么多种斜率的平行线：
**考虑减少一些规模**
1. 显然两个平行线都是经过顶点的。因此可以极大程度减少枚举的规模。再详细想想发现枚举的数量是N级别的。
2. 当我们将一组平行线考虑充分时：考虑旋转这组平行线。从如下一个过程中得到启发：

![草稿](%E8%8D%89%E7%A8%BF-1693365528283-2.png)

旋转地过程中找到哪一个先被卡，不停地更新当前两条直线中被卡地点对即可。这可以通过一个双指针实现。代码如下：

#### code

```cpp
#define rep(i, a, n) for (int i = a; i < n; i++)
db convexDiameter(vector<P> ps){
	int n = ps.size(); if(n <= 1) return 0;
	int is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;
	int i = is, j = js;
	db ret = ps[i].distTo(ps[j]);
	do{
		if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)
			(++j)%=n;
		else
			(++i)%=n;
		ret = max(ret,ps[i].distTo(ps[j]));
	}while(i!=is || j!=js);
	return ret;
}
```





## 板子

```cpp

#define rep(i, a, n) for (int i = a; i < n; i++)
db area(vector<P> ps){
	db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); 
	return ret/2;
}
 
/*点包含*/
int contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside
	int n = ps.size(), ret = 0; 
	rep(i,0,n){
		P u=ps[i],v=ps[(i+1)%n];
		if(onSeg(u,v,p)) return 1;
		if(cmp(u.y,v.y)<=0) swap(u,v);
		if(cmp(p.y,u.y) > 0 || cmp(p.y,v.y) <= 0) continue;
		ret ^= crossOp(p,u,v) > 0;
	}
	return ret*2;
}
  
vector<P> convexHull(vector<P> ps) {
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
vector<P> convexHullNonStrict(vector<P> ps) {
	//caution: need to unique the Ps first
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
db convexDiameter(vector<P> ps){
	int n = ps.size(); if(n <= 1) return 0;
	int is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;
	int i = is, j = js;
	db ret = ps[i].distTo(ps[j]);
	do{
		if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)
			(++j)%=n;
		else
			(++i)%=n;
		ret = max(ret,ps[i].distTo(ps[j]));
	}while(i!=is || j!=js);
	return ret;
}
  
vector<P> convexCut(const vector<P>&ps, P q1, P q2) {
	vector<P> qs;
	int n = ps.size();
	rep(i,0,n){
		P p1 = ps[i], p2 = ps[(i+1)%n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if(d1 >= 0) qs.push_back(p1);
		if(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));
	}
	return qs;
}

```
