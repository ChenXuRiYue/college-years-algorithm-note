几个例题，是将问题转换成缩点后的图（用双连通分量缩点）上的问题。

### $first$   USACO 2006 Jan, Redundant Paths

[USACO 2006 Jan, Redundant Paths - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/985)

#### solve

1. 发现在边双连通分量内部建边是没有意义的。

   在此启发之下，将图缩成一个，边双连通分量之间的树。

2. 于是转换成一个图上构造问题。分析得到每一个叶子（度数为1）都要搭一条边，融入边连通变量。发现最优的构造方法是，叶子叶子之间建立边。于是最优的操作是cunt_dag=1/2向上取整。

#### 实现
1. 缩图。
2. 计算度数为1的点。
#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

vector<pair<int , int>> g[N];
int dfn[N] , low[N] , tot , bel[N];
//无向图不可能存在横插边，所以不用开一个inv数组
stack<int> stk;

vector<int> e;
int n , m;
vector<int> cc[N];
int cnt;


void dfs(int u , int id) {
	dfn[u] = low [u] = ++tot;
	stk.push(u);

	for (auto temp : g[u]) {
		int v = temp.first;
		int id2 = temp.second;
		if (!dfn[v]) dfs(v , id2) , low[u] = min(low[u] , low[v]);
		else if (id != id2) low[u] = min(low[u] , dfn[v]);
	}

	if (low[u] == dfn[u]) {
		++cnt;
		while (true) {
			int v = stk.top(); stk.pop();
			bel[v] = cnt;
			cc[cnt].push_back(v);
			if (v == u)break;
		}
	}
}


void tarjan() {
	for (int i = 1; i <= n; i ++) {
		if (!dfn[i]) dfs(i , -1);
	}
	int ans = 0;
	for (int i = 1; i <= cnt; i++) {
		int cunte = 0;
		for (auto u : cc[i])
			for (auto temp : g[u]) {
				int v = temp.first;
				if (bel[u] != bel[v])cunte ++;
			}
		ans += (cunte == 1);
	}
	cout << (ans + 1) / 2 << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);


	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x , y;
		cin >> x >> y;

		g[x].push_back({y , i});
		g[y].push_back({x , i});
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### 生长

- 不需要引入inv变量。  inv变量记录是否在栈种。来防止横插边。

#### $second$  BLO

[POI 2008, BLO - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/986)

##### solve

关注图中的两种点： 割点和普通点。利用点双连通分量将图收缩。发现如果点作为子树的割点。那么当把点割掉之后，子树中的所有点都不再和其它点连通，此时可以计算出部分的贡献。
如果是一般点，贡献的改变只在于删除点。

##### code
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int n , m;

vector<int>e[N];
int dfn[N] , low[N] ,  id;
long long ans[N];
int sz[N];

void dfs(int u , int par) {
	dfn[u] = low[u] = ++id;
	sz[u] = 1;
	ans[u] = n - 1;//割舍走的点和其它的点匹配的贡献。
	int cut = n - 1;

	for (auto v : e[u]) {
		if (!dfn[v]) {
			dfs(v, u);
			low[u] = min(low[u] , low[v]);
			sz[u] += sz[v];
			if (low[v] >= dfn[u]) {
				//说明这个点对应于当前子树下，是一个割点。
				ans[u] += 1LL * sz[v] * (n - sz[v]);
				cut -= sz[v];
			}
		}
		else if (v != par) low[u] = min(low[u] , dfn[v]);
	}

	ans[u] += 1LL * cut * (n - cut);
}

void tarjan()
{
	dfs(1 , 0);
	for (int i = 1; i <= n; i++)
		cout << ans[i] << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### $Third:$ HNOI2012, 矿场搭建

利用点双连通分量，将图收缩。

挖掘性质。

- 如果不存在割点。那么要在图间设置两个入口。方案数用组合计算即可。
- 如果存在割点，缩点后，入度为1的节点都设置一个点（不能设置在割点处。）其实就是当前分量中只有一个节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
int n = 1E3 + 10;

bool work(int testNo)
{
	int T;
	scanf("%d" , &T);
	if (T == 0)
		return true;
	vector<vector<int>> g(n + 1);
	for (int i = 0; i < T; i++) {
		int x, y;
		scanf("%d%d", &x , &y);
		g[x].push_back(y);
		g[y].push_back(x);
	}
	vector<int> low(n + 1, 0) , dfn(n + 1 , 0) ;
	//记录点双连通分量。割点除外的点双连通分量。
	vector<vector<int>> cc;
	int id = 0;
	vector<int> cut(n + 1 , 0);
	stack<int> stk;

	function<void(int , int)> dfs = [&](int u , int par)->void{
		dfn[u]  = low[u] = ++id;

		stk.push(u);
		int ch = 0;

		for (auto v : g[u]) {
			if (!dfn[v]) {
				ch ++;
				dfs(v , u);
				low[u] = min(low[u] , low[v]);
				if (low[v] >= dfn[u]) {
					cut[u] = 1;
					vector<int>c;
					c.push_back(u);
					while (true) {
						int w = stk.top(); stk.pop();
						c.push_back(w);
						if (w == v)break;
					}
					cc.push_back(c);
				}
			}
			else if (v != par)
				low[u] = min(low[u] , dfn[v]);
		}

		if (par == 0 && ch <= 1)cut[u] = 0;
	};

	for (int i = 1; i <= n; i++)if (!dfn[i])
			dfs(i , 0);

	//然后分类讨论统计答案。
	//如果只有一个点双连通分量。那么就是2.
	//如果有多个就是每一个连通块都要放置一个连通分量。
	unsigned long long ans1 = 0 , ans2 = 0;
	if (cc.size() == 1) {
		ans1 = 2;
		int nn = cc[0].size();
		ans2 = 1ULL * (nn) * (nn - 1) / 2;
	}
	else {
		ans1 = 0;
		ans2 = 1;
		for (auto c : cc) {
			int ncut = 0;
			for (auto u : c) {
				ncut += cut[u];
			}
			if (ncut == 1) {
				ans1++;
				ans2 *= (1ULL * c.size() - 1);
			}
		}
	}
	printf("Case %d: %lld %lld\n" , testNo , ans1 , ans2);
	return false;
}


int main()
{
	int id = 0;
	while (true) {
		if (work(++id))break;
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/

```







