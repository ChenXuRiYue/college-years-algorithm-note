#### 概念简介
##### 割点

对于无向连通图，去掉一个点，连通图图不再连通。该点就是割点。
##### 割边
去掉一条边，连通图不再连通。该边就是割边。
##### 双连通分量
1. 点双连通
   图没有割点。
2. 边双连通
   图没有割边
3. 双连通性质：
   1. 点双连通中：任意两点有两条以上简单路径（不经过重复点的两条路径。）
   2. 边双连通中：任意两点之间有两条以上不经过重复边的简单路径。

找到一个极大的点集合，满足导出子图双连通，是双连通分量。
将每一个割边去掉后，剩下的不相交图集合，是边双连通分量。
同理推广到点连通分量的定义中。

##### 双连通分量缩点

1. 边双连通分量：
   去掉所有边即可。 
2. 去掉割点，然后再对割点进行一些操作。(一个割点可能在不同的点双连通分块里)

双连通分量的缩图。
1. 边双收缩完之后依然是树
2. 点双缩完之后是block tree 圆方树。
	给割点建立一个辅助点。

-------------
### 求双连通分量
#### 无向图上的边

无向图上的dfs树只有返祖边和树边。

#### Tarjan算法
##### $\large 现象$

dfs树中，某子树中返祖边和割边的关系。子树下的点不再有边跳到dfs序更小的点。于是根和父亲的点就是割边。

##### $\large 割边$

[割边 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/983)

1. 注意对两种特殊边的处理。自环没有影响。但是重边会影响一个点是否作为割边。
    重边的处理方法是，给这些边标记一些标号。
2. 算法步骤简述：
   1. 通过存储图的方式中：将每一条边打上标记。
   2. 用类似于tarjan的算法，关注返祖边。关注每一个点的子孙能够返祖到达的最低的dfn位置。
   3. 如果将一个点遍历完之后，发现子孙返祖的最大边就是自己。说明这个子树边连通。它与父亲的边就是割边。


###### 自己的写法

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

vector<pair<int , int>> g[N];
int dfn[N] , low[N] , tot;
//无向图不可能存在横插边，所以不用开一个inv数组

vector<int> ans;
int n , m;


void dfs(int u , int id) {
	dfn[u] = low [u] = ++tot;
	for (auto v : g[u]) {
		if (dfn[v.first] == 0) dfs(v.first , v.second);
		if (id != v.second) low[u] = min(low[u] , low[v.first]);
	}

	if (dfn[u] == low[u] && id != -1) {
		ans.push_back(id);
	}
}


void tarjan() {
	for (int i = 1; i <= n; i ++) {
		if (!dfn[i]) dfs(i , -1);
	}
	int size = ans.size();
	sort(ans.begin() , ans.end());
	cout << size << '\n';
	for (int i = 0; i < size; i++) {
		cout << ans[i] << " \n"[i == n];
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);


	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x , y;
		cin >> x >> y;

		g[x].push_back({y , i});
		g[y].push_back({x , i});
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

###### dls的写法

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 101000;
vector<pair<int, int>> e[N];

int dfn[N], low[N], idx, n, m;
vector<int> bridge;

void dfs(int u, int id) {
	dfn[u] = low[u] = ++idx;
	for (auto [v, id2] : e[u]) {
		if (!dfn[v]) {
			dfs(v, id2);
			low[u] = min(low[u], low[v]);
			if (dfn[v] == low[v]) bridge.push_back(id2 + 1);
		} else if (id != id2) {
			low[u] = min(low[u], dfn[v]);
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		e[u].push_back({v, i});
		e[v].push_back({u, i});
	}
	dfs(1, -1);
	sort(bridge.begin(), bridge.end());
	printf("%d\n", (int)bridge.size());
	for (auto x : bridge) printf("%d ",x);
	puts("");
}

```



###### 生长思考：

对比两个代码。主要差别是 ， low的定义方式以及，判断桥记录桥的环节。

1. 关于low的定义方式：

   自己写的一份。沿袭了ssc的代码板子。对于灭一个节点的low的意义是，可以通过路径返祖到达的最小dfs序的祖先。

   dls的代码，代表的是对于每一个点如果low小于dfn[u] ， 则代表了可以返祖。且是对于当前自己的子树上的返祖方式而言的。并且只用到了一次返祖边。

2. 因为这种和dfn有关的定义方式，和割点的求法相关。同时效果相同，所以追求统一。两份代码都使用了同一种写法。

关于桥的记录细节。对于一个点，它什么时候出现，并且已经计算完了low值。

1. 第一， 作为dfs(u , id)中的u。
2. 第二， dfs树种的父亲访问子节点的时候，对它进行dfs序后。

在第二个时间，不用特判，根处id不存在。

##### $\large 割点$

###### 关注现象

对于一颗子树，如果子树下的祖先边，不通过割点的返祖边的条件下（因为割点被割后，该点的边就不能用了。）不可以跳出子树外的祖先。那么子树的根就是割点。
- low ， 一次跳可以达到的最大距离。

特殊情形下的特判：对于根，如果根自由一个儿子，那么不作为割点。

##### $code$

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int n , m;

vector<int> g[N];
int cut[N]; // 记录是否为割点。
int dfn[N], low[N] , tot;

int size = 0;


void dfs(int u , int par) {
	dfn[u] = low[u] = ++tot;
	int sons = 0;
	for (auto v : g[u]) {
		if (dfn[v] == 0) {
			sons ++ ;
			dfs(v , u);
			low[u] = min(low[u] , low[v]);
			if (low[v] >= dfn[u])cut[u] = 1;
		}
		//为什么要判断重边？
		else {
			low[u] = min(low[u] , dfn[v]);
		}
	}

	if (u == 1 && sons <= 1)cut[u] = 0;
	size += cut[u];
}

void tarjan() {
	for (int i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i , 0);
	}
	cout << size << '\n';
	for (int i = 1; i <= n; i++)
		if (cut[i])cout << i << ' ';
	cout << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x , y;
		cin >> x >> y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

###### 生长思考：

- 是否要判断重复边？

  重边的计算，符合low的定义。没有影响。

- dfs下，每优化一个语句。都是非常大的常数优化。





