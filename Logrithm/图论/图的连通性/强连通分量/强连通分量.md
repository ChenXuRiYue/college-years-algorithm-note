### abstract

#### DFS 树上的边

1. Tree Edge(树边)
   就是树上的边
2. Back Edge(返祖边)
   子孙连向祖先的边。（不作为树边，是引入的边。）
3. Forward Edge (前向边)
   就是祖先直接到了子孙上的边，忽略了中间的一些点。
4. Cross Edges（横插边）
   除了1 2 3 的边

细节，边的形成和dfs方式有关。dfs树并不唯一确定。基于问题来研究。可能这不同的方式对解决问题有相同的效力。

#### scc

弱连通分量:     (基于无向图)

-----

强连通分量：（strongly connected component）(基于有相图)
u存在一条路径到达v .v存在一条路径到达u 则称u与v是强连通的.

- 性质:
  1. u->v , v->u.有环.相关环

把图分成若干块(分量) , 块之间的节点是强连通的.

------

### 求图的强连通分量:

(几级)理解证明 -- 大致观念 -- 黑盒

#### $first$ Tarjan 算法  (塔洋算法)

##### 关注现象以及方法

1. dfs过程中,如果找到了返祖边,前向边横插边.可以得到和对强连通分量相关的什么信息?
2. 处理方案.如果发现一个块不可能会成为其它强连通分量的一员,就及时切掉.

##### 总结实现
==$1$==.存储图:(一般除了网络流使用链表存储.其它的直接用vector即可.)
注意建图基于单向边.

```cpp
vector<vector<int>> g;
void solve()
{
	int n , m;
	cin >> n >> m;
	for(int i = 1 ; i <= m; i ++)
	{
		int u , v;
		cin >> u >> v;
		g[u].push_back(v);
	}
}
```
==$2$==. 使用一些结构,遍历过程中关注点的一些属性:

   1. `stack<int> stk`: 用来保存遍历dfs过程中依次经过的节点。
   2. `int dfn[N]`:	 dfs树。节点的dfs序为当前第几个被遍历到。
   3. `vector<vector<int>> ssc`每一个vector保存连通分量 。
   4. `int low[N]` 记录每一个节点的可达dfn最低点。
   5. `ins[N]`记录节点是否在栈中。

在遍历过程中，可能碰到一些边返祖（不返组就只能作为儿子。）一旦返祖，就会形成一个环。与该环上某一个的节点强连通的节点。都会成为与环上的点强连通。
1. 用low的第一个记录返祖边信息
那么怎么将这种环套环的节点整理放在一块呢？在dfs的过程中，如果一个点没有边返祖，并且已经拓展到了最大深度，那么这个点就作为连通分量。直接将它并入ssc即可。于是
2. 利用low记录圈上最顶层的点。
考察多种情况：
当遍历在回到这些点时，stk的top一大段连续的部分，都是强连通块上的点。
##### 板题

[强连通分量 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/943)

###### 板code
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

vector<vector<int>>g;
int dfn[N] , low[N] , bel[N], ins[N] , id;

vector<vector<int>> ssc;
stack<int>stk;

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);

	for (auto v : g[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v] , low[u]);
	}
	//说明已经没有收割的空间了：
	if (low[u] == dfn[u])
	{
		vector<int> s;
		while (true)
		{
			int v = stk.top();
			stk.pop();
			s.push_back(v);
			ins[v] = false;
			bel[v] = ssc.size();
			if (v == u)break;
		}
		sort(s.begin(), s.end());
		ssc.push_back(s);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	g.resize(n + 1);
	for (int i = 0; i < m; i ++)
	{
		int u , v;
		cin >> u >> v;
		g[u].push_back(v);
	}

	for (int  i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}
	sort(ssc.begin(), ssc.end());

	for (auto i : ssc) {
		for (auto j : i) {
			cout << j << ' ';
		}
		cout << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```
------------
#### kosaraju 算法

##### 关注现象

1. 关注dfs出栈的序：对于DAG ，出栈顺序是反图的拓扑序。
2. 把scc缩成一个点后，图变成一个有向无环图。
3. 最后一个出栈的点，其所在的连通分量，在缩完之后的树中是个源点（没有入度）。
   - 证明：反证法，假设搜了一次缩出来的一个图中。u所在的连通块有入度有入度，那么无论是从其它点开始搜还是从所在的块中的点开始搜，都是矛盾的。
##### 综合以及方法
于是可以发现所有可以到达u(最后一个出栈的点)的点都和u是同一个连通分量的。利用反图。可以找出所有的点。于是就找到u所在的连通分量之中。
每确定一个点都进行一次dfs，就可以逐步把所有的强连通分量确定。
##### 实现

1. 只需要一遍dfs即可，对dfs栈重利用。最后的复杂度也是$O(n)$。最丑的实现是，每次确定一个点都打一次标记。
	1. 对于一个图而言，无论从哪个根开始遍历最后的结果不会变。（反证法，我们首先确定了每种根的方式下开始遍历，最后得到的正确结果。于是两种结果之间一一映射，否则矛盾。）
	2. 于是第一次得到的栈中，去掉处理后的源点。剩下的顺序也是从某个点深搜的dfs出栈序。

##### 板code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

vector<vector<int>> e , erev;

vector<vector<int>> ssc;
vector<int> c;
bool vis[N];

vector<int>out;


void dfs(int u)
{
	vis[u] = true;
	for (auto v : e[u]) {
		if (vis[v])continue;
		dfs(v);
	}
	out.push_back(u);
}

void dfs2(int u) {
	vis[u] = true;
	for (auto v : erev[u]) {
		if (vis[v])continue;
		dfs2(v);
	}
	c.push_back(u);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	e.resize(n + 1);
	erev.resize(n + 1);
	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
		erev[y].push_back(x);
	}

	for (int i = 1; i <= n; i ++)
	{
		if (vis[i])continue;
		dfs(i);
	}
	memset(vis, false, sizeof(vis));
	reverse(out.begin(), out.end());
	for (auto u : out) {
		if (vis[u])continue;
		c.clear();
		dfs2(u);
		sort(c.begin(), c.end());
		ssc.push_back(c);
	}
	sort(ssc.begin(), ssc.end());
	for (auto i : ssc) {
		for (auto j : i)
		{
			cout << j << ' ';
		}
		cout << '\n';
	}
}
```
