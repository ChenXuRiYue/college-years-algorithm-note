解决这些问题，最重要的是转换的思想，关注解结构中强连通分量的情况。从而将问题转换成dag上的dp问题。





#### 例题1.受欢饮的牛

[HAOI2006, 受欢迎的牛 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/944)

找出有向图中所有点可达的汇点。

##### solve

尝试从强连通性的角度来看待问题。

1. 对于一个已经缩点的图中，缩点内部任意可达。
2. 如果存在一个汇点，汇点都将在一个强连通分量中。
   1. 对于两个汇点 u，v。作为汇点说明它们双向可达。
3. 汇点所在的缩点中，没有出边。

综上：
如果缩完点之后，找出每一缩点的出度为0的缩点数之和。
如果图中存在两个以上出度为0的缩点。
说明不存在汇点。

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

vector<vector<int>>g;
int dfn[N] , low[N] , bel[N], ins[N] , id;
vector<vector<int>> ssc;
stack<int>stk;
int n , m;
int cnt[N];//记录每一个分量的入度出度个数。

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);

	for (auto v : g[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v] , low[u]);
	}

	//说明已经没有收割的空间了：
	if (low[u] == dfn[u]) {
		vector<int> s;
		while (true) {
			int v = stk.top();
			stk.pop();
			s.push_back(v);
			ins[v] = false;
			bel[v] = ssc.size();
			if (v == u)break;
		}
		sort(s.begin(), s.end());
		ssc.push_back(s);
	}
}

void tarjan(){
	for (int  i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}
	sort(ssc.begin(), ssc.end());
	for (int u = 1; u <= n; u++) {
		for (auto v : g[u]) {
			if (bel[u] != bel[v]) {
				cnt[bel[u]]++;
			}
		}
	}
	int ans = 0;
	int tot = 0;
	for (int i = 0; i < ssc.size(); i++ ){
		if (cnt[i] == 0) {
			tot ++;
			ans += ssc[i].size();
		}
	}
	if (tot > 1)
		cout << 0 << '\n';
	else cout << ans << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	g.resize(n + 1);
	for (int i = 1; i <= m; i ++){
		int x, y;
		cin >> x >> y;
		g[x].push_back(y);
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



#### 例题二		最大半连通子图 - 洛谷

[P2272 [ZJOI2007\]最大半连通子图 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2272)

##### $ \large solve$
1. 该问题关注了点之间的可达性。一些点之间是强连通的，那么必然在最优方案一起出现。于是考虑对他们进行缩点，将连通分量作为一个点研究。
于是问题转换成了，在有点权的dag中求一条路使得路上的点权和最大，并且求出最优方案的方案数。

2. 转换得到的问题是dag上的一个dp问题，

    对于缩点后的图。
    $f_{i}$：从为起点向下的路的最大点权和。
    $w_{i}$：满足最大点权和的方案总数。
    $$
    f_{i} = max(f_{sons})+size[i];
    $$
    $$
    w_{i} = \sum (f_{son}==max(f_{sons}))*w_{i}.
    $$
------------
   		这里的方案不同，只能由点决定。所以要注意去除重边。

3. 状态转移的顺序上，不用再找起点再进行遍历。
   1. ssg得到的编号数组，就是dag上拓扑序的反序。
   2. tarjan的过程中，也进行状态转移。
4. 关于实现细节上

有两种风格的实现方式，其中。

1. 第一种是dfs完之后再dp。

​		因为求出强连通分量之后就得到了拓扑序的反序。

2. 第二种是一边dfs再一边dp

   tarjan算法在求出一个缩点之后，深度更大的缩点就被求出来了。意味着，小规模子问题，以及缩点的信息都已经求出。所以可以dp.

##### code first

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;


const int N = 1E6 + 10;


int f[N], w[N], vis[N];

int n, m, mod;

vector<vector<int>>e;
int dfn[N], low[N], bel[N], ins[N], id;

vector<vector<int>> ssc;
stack<int>stk;

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);

	for (auto v : e[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v], low[u]);
	}

	//说明已经没有收割的空间了：
	if (low[u] == dfn[u]) {
		vector<int> s;
		while (true) {
			int v = stk.top();
			stk.pop();
			s.push_back(v);
			ins[v] = false;
			bel[v] = ssc.size();
			if (v == u)break;
		}
		//sort(s.begin(), s.end());
		ssc.push_back(s);
	}
}

void tarjan()
{
	for (int i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}
	int T = 0, ans = 0, we = 0;
	for (int i = 0; i < ssc.size(); i++) {
		++T;
		f[i] = 0;
		w[i] = 1;
		vis[i] = T;
		for (auto u : ssc[i]) {
			for (auto v : e[u]) {
				if (vis[bel[v]] == T)continue;

				vis[bel[v]] = T;
				if (f[i] < f[bel[v]]) {
					f[i] = f[bel[v]];
					w[i] =  w[bel[v]];
				}
				else if (f[i] == f[bel[v]]) {
					w[i] = (w[i] + w[bel[v]]) % mod;
				}
			}
		}
		f[i] += ssc[i].size();
		if (f[i] > ans)  ans = f[i], we = 0;
		if (f[i] == ans) we = (we + w[i]) % mod;
	}
	cout << ans << '\n';
	cout << we << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m >> mod;
	e.resize(n + 1);
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### code_second

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;


const int N = 1E6 + 10;


int f[N], sum[N], vis[N];

int n, m, mod;

vector<vector<int>>e;
int dfn[N], low[N], bel[N], ins[N], id;

vector<vector<int>> ssc;
stack<int>stk;

int ans , way , T;

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);
	for (auto v : e[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v], low[u]);
	}
	//说明已经没有收割的空间了：
	if (low[u] == dfn[u]) {
		++T;
		int now = ssc.size();
		f[now] = 0 , sum[now] = 1;
		vector<int> s;
		vis[now] = T;
		while (true) {
			int v = stk.top();
			stk.pop();
			s.push_back(v);
			ins[v] = false;
			bel[v] = now;
			for (auto to : e[v]) {
				if (ins[to] == false && vis[bel[to]] != T)
				{
					vis[bel[to]] = T;
					if (f[bel[to]] > f[now])
						f[now] = f[bel[to]], sum[now] = 0;
					if (f[bel[to]] == f[now])
						sum[now] = (sum[now] + sum[bel[to]]) % mod;
				}

			}

			if (v == u)break;
		}
		f[now] += s.size();
		//sort(s.begin(), s.end());
		if (ans < f[now]) ans = f[now] , way = 0;
		if (ans == f[now]) way = (way + sum[now]) % mod;
		ssc.push_back(s);

	}
}

void tarjan()
{
	for (int i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}

	cout << ans << '\n';
	cout << way << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m >> mod;
	e.resize(n + 1);
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
	}
	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### 生长思考

1. 总是忽视在收缩后的图上进行处理。
2. 判断重边，这里使用了T变量的技巧。每一轮，对访问过的点，都复一个当前轮独特的标记。就是跟随迭代的变量T

---------------

#### 例题三 ATM

[APIO2009, ATM - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/23/problem/946)

##### 简介

给定有向图，求出一条单向路径（可以重复经过同一个点）规定终点为$x_1....x_n$中的一点。

求出点权和最大的方案。

##### thinking

1. 考察众多解，最优策略总是将强连通量内的点作为整体考虑。于是利用缩点，就见将问题转换成了一个dag上的dp问题。
2. 集中精力解决dp问题。

​		$dp$：表示从该点单向到达某一个酒吧的最短距离。

​				对于最小规模的子问题，如果点（缩点）内部没有酒吧。那么dp = -oo

​				如果本身就是酒吧，就设置为 val(该路口上的银行的钱。）

2. ##### 1 怎么统一转移？____

   初始化 dp = -oo;

   先考察儿子的方案。$dp = max(dp , dp[son].)$

   最后再考察自己作为终点的方案即

   $dp = max(dp , 0)$

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;


const int N = 1E6 + 10;
const int inf = 0x0ffffff;


ll dp[N], val[N];

int n, m, s, p;
bool bar[N];

vector<vector<int>>e;
int dfn[N], low[N], bel[N], ins[N], id, now;

stack<int>stk;

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);

	for (auto v : e[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v], low[u]);
	}

	//说明已经没有收割的空间了：
	if (low[u] == dfn[u]) {
		vector<int> s;

		ll sum = 0;
		++now;
		dp[now] = -inf;
		bool havebar = false;

		while (true) {
			int v = stk.top();
			stk.pop();
			s.push_back(v);
			ins[v] = false;
			bel[v] = now;

			sum += val[v];
			havebar |= bar[v];
			for (auto w : e[v]) {
				if (ins[w] == false && bel[w] != now)
					dp[now] = max(dp[now], dp[bel[w]]);
			}
			if (v == u)break;
		}
		//sort(s.begin(), s.end());

		if (havebar) {
			dp[now] = max(0LL, dp[now]);
		}
		dp[now] += sum;
	}
}

void tarjan()
{
	for (int i = 1; i <= n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}
	cout << dp[bel[s]] << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	e.resize(n + 1);
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
	}
	for (int i = 1; i <= n; i++)cin >> val[i];
	cin >> s >> p;
	for (int i = 1; i <= p; i++) {
		int x;
		cin >> x;
		bar[x] = true;
	}

	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



#### 例题四 所驼门王的宝藏

[P2403 [SDOI2010\]所驼门王的宝藏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2403)

依然是转换称dag然后求取最长路的问题。

##### $solve$

建图技巧：

1. 第一种联系，引入一个辅助点。这样用来减少边的个数 , 并且减少建边的花费。同一行，并且是第一种的点可以利用这个辅助点，实现资源共享，从而增加空间的利用率。
2. 第二种联系，同上，为每一列之间建立一个辅助点。
3. 第三种，由于最多7个，所以搜索建立边即可。

于是建立了一个原图点之间连通性等效的图。

dp

比较简单的dp类型。

但是注意统计的时候，要去除自己建立的辅助点的影响。

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int x[N], y[N], ty[N], cunt;

int ans = 0;


map<pair<int, int>, int> rec;
int idx[N], idy[N];
vector<vector<int>>e;

vector<int> c[N] , r[N];

stack<int> stk;
int bel[N * 2 + 10], low[N * 2 + 10], dfn[N * 2 + 10], ins[N * 2 + 10], cuntssc, id;

int dp[N * 2 + 10];
int n, R, C;

void dfs(int u) {
	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);
	for (auto v : e[u]) {
		if (dfn[v] == 0) dfs(v);
		if (ins[v]) low[u] = min(low[u], low[v]);
	}

	if (low[u] == dfn[u]) {
		cuntssc++;
		dp[cuntssc] = 0;
		int sum = 0;
		while (true) {
			int v = stk.top(); stk.pop();
			sum += (v <= n);
			bel[v] = cuntssc;
			ins[v] = false;
			for (auto w : e[v]) {
				if (ins[w] || bel[w] == cunt)continue;
				dp[cuntssc] = max(dp[bel[w]], dp[cuntssc]);
			}
			if (u == v) break;
		}
		dp[cuntssc] += sum;
		ans = max(dp[cuntssc], ans);
	}

}


void tarjan() {
	for (int i = 1; i <= cunt; i++) {
		if (dfn[i] == 0) dfs(i);
	}
	cout << ans << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> R >> C;
	for (int i = 1; i <= n; i++)
	{
		cin >> x[i] >> y[i] >> ty[i];
		rec.insert({ {x[i] , y[i]}, i });
		r[x[i]].push_back(i);
		c[y[i]].push_back(i);
	}
	cunt = n;

	e.resize(n * 2 + 10);
	for (int i = 1; i <= n; i++)
		if (ty[i] == 1) {
			int now = idx[x[i]];
			if (now == 0) {
				idx[x[i]] = now = ++cunt;
				for (auto v : r[x[i]])
					e[cunt].push_back(v);
			}
			e[i].push_back(now);
		}
		else if (ty[i] == 2) {
			int now = idy[y[i]];
			if (now == 0) {
				idy[y[i]] = now = ++cunt;
				for (auto v : c[y[i]])
					e[cunt].push_back(v);
			}
			e[i].push_back(now);
		}
		else {
			for (int dx = -1; dx <= 1; dx++)
				for (int dy = -1; dy <= 1; dy++) {
					if (dx == 0 && dy == 0)continue;
					if (rec[ {x[i] + dx, y[i] + dy}]) {
						e[i].push_back(rec[ {x[i] + dx, y[i] + dy}]);
					}
				}
		}

	tarjan();
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

















