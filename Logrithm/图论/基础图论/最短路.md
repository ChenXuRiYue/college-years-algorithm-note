#### 1.0  Dijkstra算法

##### 解决问题：

 图中一个点到其它点的最短路距离。

##### 算法思想简述：

主要是贪心策略，以及性质挖掘。

1. 当前轮中，找到与start距离最小的点。
2. 当前点的最短路已经计算完成。
3. 基于当前轮确定最短路的点，进行拓展。更新其它点的已知最短距离。
4. 开始新的一轮，直到所有点的最短路都确定。

##### 注意细节

1. 要求图中不存在负边。
   1. 如果图中存在负边，且存在负环。那么不可能存在最短路。
   2. 从已知最短路更新出来的路不是单调递增的。此时不能从当前轮已知最短路距离简单的找出一个点并入已知最短路的集合中。

##### code

1. 对于矩阵的初始化：

如果边不存在，关于边权的存储那么两个节点之间的边权设为无穷大。

2. 对于d[i]已知最短距离。d[0] = 0; 其他d[i] = INF;

```cpp
//const int oo = 0x0fffffff;//无穷大。一般自己的主程序模板自带。

int n;//边的编号。（小心变量重复。）

int g[N][N];//表示两个节点之间的边权。graph
bool v[N]; 	//表示节点当前最短路是否已知。

void dijkstra()
{
    fill(v , v + 1 + n, false);
    for(int i = 0; i < n; i++)d[i] = (i == 0 ? 0 : oo);
    for(int i = 0; i < n; i++)
    {
        int x, m = oo;
        for(int y = 0; j < n; j++)if(!v[y] && d[y] < m) m = d[x = y];
        v[x] = 1;
    	for(int y = 0; j < n; j++)d[y] = min(d[y] , d[x] + g[x][y]);
    }
} 
```

##### 生长：

1. 打印路程的问题：

   使用dijkstra算法和动态规划中的方案一致。从终点出发 ， 不断顺着d[i] + w\[i][j] == d[j]的边返回节点i.

   另外可以用空间换时间 ，开一个fa[x]来记录。（这里引入了一个松弛操作的概念来描述）。

   ```cpp
   if(d[y] > d[x] +  w[x][y]){
       d[y] = d[x] + w[x][y];
       fa[y] = x;
   }
   ```

2. 复杂度分析：显然是$O(n^2)$.

##### 复杂度优化（由$O(n^2) ->o(m*log(n))$

优化角度：

1. 集中精力优化未标号节点中的最小d值。

2. 存储结构：邻接表表示图：

##### 封装

```cpp
//边结构的存储
struct Edge {
    int from, to, dist;
    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};

const int oo = 1E9 + 10;
const int maxn = 2E5 + 10;//最大节点个数。
struct Dijkstra {
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn]; //保存了
    bool done[maxn];
    int d[maxn];        //s到各个点的距离
    int p[maxn];        //记录上一条弧

    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++)G[i].clear();
        edges.clear();
    }

    void AddEdge(int from, int to, int dist)
    {
        edges.push_back(Edge(from, to, dist));
        m = edges.size();
        G[from].push_back(m - 1);
    }

    //优先队列使用的结构。当然可以使用pair来储存。
    struct HeapNode {
        int u;
        int d;
        //优先最小堆
        //这里怎么那么奇怪？发现一些问题。
        //抛开习惯。大于小于不过只是函数名称。
        bool operator <(const HeapNode& rhs)const {
            return d > rhs.d;
        }
    };

    void dijkstra(int s)
    {
        priority_queue<HeapNode>que;
        for (int i = 0; i < n; i++)d[i] = oo;
        fill(done, done + n, false);
        que.push({ s , 0 });
        d[s] = 0;
        while (que.empty() == false)
        {
            int u = que.top().u;que.pop();
            if (done[u])continue;
            done[u] = true;
            //检查所有边进行更新
            for (auto i : G[u])
            {
                int v = edges[i].to;
                if (d[v] > d[u] + edges[i].dist)
                {
                    d[v] = d[u] + edges[i].dist;
                    p[v] = i;
                    que.push({ v , d[v] });
                }
            }
        }
    }

}dij;

/*
* 1.不要在局部函数中定义对象。
* 2.注意数据范围。考虑将int，改为ll.
* 3.改模板节点管理：节点的下标从0开始。注意是否输入统一。
*/
```

测试问题：https://www.luogu.com.cn/problem/P4779

#### Bellman-ford算法

##### 介绍

解决带负权的最短路问题：

##### 原理

1. 认识到一个事实：如果最短路存在，一定存在一个不含环的最短路。

2. 不含环则最短路最多只经过n-1个节点，可以通过n -  1轮松弛操作得到。

有种动态规划的味道在里头。

在第k轮，对于d[i]记录的是只经历0...k-1个节点的所有路径中的最短路。





##### code初版

```cpp
for(int i = 0; i < n; i++)d[i] = oo;
d[0] = 0;
for(int k = 0; k < n - 1; i++)
    for(int i = 0; i < m; i++)
    {
        int x = u[i] , y = v[i];
        if(d[x] < oo) d[y] = min(d[y] , d[x] + w[i]);
    }
```

##### 封装模板

```cpp
//边结构的存储
struct Edge {
    int from, to, dist;
    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};

const int oo = 0x7fffffff;
const int maxn = 5E5 + 10;//最大节点个数。
struct BellmanFord {
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn]; //保存了
    bool inq[maxn];
    int cnt[maxn];
    ll d[maxn];        //s到各个点的距离
    int p[maxn];        //记录上一条弧

    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++)G[i].clear();
        edges.clear();
    }

    void AddEdge(int from, int to, int dist)
    {
        edges.push_back(Edge(from, to, dist));
        m = edges.size();
        G[from].push_back(m - 1);
    }

    bool bellman_ford(int s)
    {
        queue<int>que;
        fill(inq, inq + n, false);
        fill(cnt, cnt + n, 0);
        for (int i = 0; i < n; i++)d[i] = oo;
        d[s] = 0;
        inq[s] = true;
        que.push(s);
        while (que.empty() == false)
        {
            int u = que.front(); que.pop();
            inq[u] = false ;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge& e = edges[G[u][i]];
                if (d[u] < oo && d[e.to] > d[u] + e.dist)
                {
                    d[e.to] = d[u] + e.dist;
                    p[e.to] = G[u][i];
                    if (!inq[e.to]) { que.push(e.to); inq[e.to] = true; }
                    if (++cnt[e.to] > n) return  false;
                }
            }
        }
        return true;
    }
}bellman;

/*
* 1.不要在局部函数中定义对象。
* 2.注意数据范围。考虑将int，改为ll.
* 3.改模板节点管理：节点的下标从0开始。注意是否输入统一。
* 4.记得init();
*/
```



#### Floyd

##### 解决问题：

处理多源最短路径问题；

##### 原理

动态规划：

定义$d_{i ，j}$表示只使用0...i的节点i,到j之间的最短距离。
状态转移方程为
$$
d_{k,i,j} = min(d_{k-1,i,j},d_{k-1,i,k}+d_{k-1,k,j});
$$
滚动数组优化后：
$$
d_{i,j} = min(d_{i,k}+d_{k,j})
$$

证明它的可行性：

1. 最初始的状态下：初始化就是正确的。显然是正确的。
2. 第k轮的时候。

$d_{k,i,j}=min(d_{k-1,i,j},d_{k-1,i,k}+d_{k-1,k,j})$

现有包含k的路径上。只需要关注i—>k，k->j的最短路。根据定义，假设使用了其它路径。替换任意一个都会更短。

##### code

```cpp
/*
*初始化:  d[i][i] = 0;
*无边:   d[i][j] = oo;
*ij有边：d[i][j] = w[i][j]
*/
for(int k =0; k < n; k++)
    for(int  i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
        	d[i][j] = min(d[i][j], d[i][k]+d[k][j]);	
```

多源最短路的理解问题：

[E - Souvenir.md](..\problems\atcoder\图论\最短路\E - Souvenir.md) 

