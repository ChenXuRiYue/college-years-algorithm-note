#### 最短路算法

##### kruskal算法。

这个算法比较简单。并且可以处理生成森林的问题。所以优先使用该算法。

对边进行一些排序，其副产品可以创造出一些价值：



##### 算法步骤

1. 给所有边排序。
2. 从小到大，考查每条边。如果加上生成树中不成环，就加上去。

反证法。如果不加上去这条边，得到了一个最优的生成树（森林）。加上这条边之后一定会出现一个环。

然后在这个环中减去任何一条边从新变成森林。至少有一条边的权值大于等于（u , v）的权值。



##### code

```cpp
const int N = 10010;
const int M = 1E6+10;
int p[N];
int id[M]; // 用来作为替身，定位大小；

int find(int x){return p[x] == x ? x : p[x] = find(p[x]);}

void unit(int x , int y)
{
    x = find (x);
    y = find (y);
    p[x] = y;
}

struct node{
    int u;
    int v;
    int w;
}e[M];

//当前已经处理好各条边；
ll kruskal()
{
    ll ans = 0;
    iota(p , p + n ,0);
    iota(id , id + m, 0);
    
    sort(id , id + m , [&](int x , int y){
        return e[x].w < e[y].w;
    });
    
    for(int i = 0; i < m; i++)
    {
        int now = id[i];
        int x = find(e[now].u);int y = find(e[now].v);
        if(x != y){ ans += e[now].w; p[x] = y;}
    }
    return ans;
}
```



入门问题：

1. 聪明的猴子：

https://www.luogu.com.cn/problem/P2504

一个性质。考察生成树的最大值的最小，出现在最小生成树中。

