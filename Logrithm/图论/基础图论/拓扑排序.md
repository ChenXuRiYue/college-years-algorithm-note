### 拓扑排序

- #### 解决问题

  - 判断有向无环图是否成环
  - 对一个有向无环图，建立给每一个节点建立一个序。满足，若从a可达b。有$order(a)<or(b)$.可根据实现，自由定义，大于或者小于的问题。

- 算法实现

  - 从入度为0的节点开始递归。对于一个节点（假设有父节点），要想经过该节点，必须经过其父节点，开始父节点的线程时，就已经把最高可分配序分配给父节点。保证定义中的关系。

  - 另外一种巧妙的算法：

    - 从0到n节点开始$dfs$
    - 对于一个点，只有把它的所有子节点分配序之后，再进行分配。保证$or(father)>or(son)$
    - 给每一个节点分好一个序之后。$reverse(or.brgin,or.end)$。这样保证了$or(father)<or(son)$.

    

###### 算法一的实现：

```cpp
```

##### 算法二的实现

```cpp
vector<int> order;
vector<vector<int>> g;
bool passed[maxn];
int pos[maxn];

void dfs(int u){
    passed[u] = true;
    for (auto i : g[u])
        if (!passed[i])
            dfs(i);
    order.push_back(u);
}

void topo()
{
    for(int i=0;i<n;i++)
    if(!passed[i])dfs(i);
    reverse(order.begin(), order.end()); //倒转。
}
```

##### 生长思考

1. 另外一种方法：
   1. 每一次不断的选取度数为0的节点：从图中删除一个节点，并且更新其它节点的度。这样不断地迭代，直到把所有地点求出来。

通过这个角度，更新是广度的，可以的关注图中的更多结构细节。

#### code

```cpp
	vector<int> topo;
	auto topo_sort = [&]()->void{
		queue<int> que;
		for (int i = 0; i < n; i++)if (deg[i] == 0) {
				que.push(i);
			}
		while (que.empty() == false) {
			int u = que.front(); que.pop();
			topo.push_back(u);
			for (auto v : g[u]) {
				deg[v]--;
				if (deg[v] == 0)que.push(v);
			}
		}
	};
	topo_sort();
	reverse(topo.begin() , topo.end());
```



st. [E - Find Permutation .md](..\..\..\problems\atcoder\图论\topo排序\E - Find Permutation .md) 
