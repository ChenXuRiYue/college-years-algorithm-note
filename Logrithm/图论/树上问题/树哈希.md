**树哈希**

#### 解决问题：

1. 快速判断树是否同构的问题：
    1. 同构的概念：对一棵树 ， 进行对同父亲的子树进行互换。进行若干次操作后，两颗树可以相等。那么称这棵树是同构的。



参考：[一种好写且卡不掉的树哈希 - 博客 - peehs_moorhsum的博客 (uoj.ac)](https://peehs-moorhsum.blog.uoj.ac/blog/7891)

#### 算法简介

关注树结构的属性： 定义一个哈希函数。
科学的定义一个哈希函数。
1. 根哈希函数，代表了当前子树的结构情况。
2. 哈希函数 ， 和子树的哈希函数联系。
  最终就是要降不同的子树结构不会落入同一个哈希值的概率。
  这里直接找一些大佬的哈希函数设计。

#### 入门问题

1. (https://codeforces.com/contest/1800/problem/G)

#### 板子

邓老师
```cpp

using ll = long long;
using Ull = unsigned long long;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
Ull bas = rnd();
//Ull bas = (Ull)1E18 + 7;
void work(int testNo)
{
	int n;  cin >> n;
	vector<vector<int>> e(n);
	for (int i = 1; i < n; i++) {
		int u, v; cin >> u >> v;
		u--; v--;
		e[u].push_back(v);
		e[v].push_back(u);
	}

	vector<Ull> h(n), f(n);
	function<Ull(Ull)> H = [&](Ull x) {
		return x * x * x * 19890535 + 19260817;
	};

	function<Ull(Ull)> F = [&](Ull x) {
		return H(x & (((1ll << 32) - 1))) + H(x >> 32);
	};

	function<void(int, int)> dfs = [&](int u, int par) {
		h[u] = bas;
//
		for (auto v : e[u]) if (v != par) {
				dfs(v, u);
				h[u] += F(h[v]);
//				rec[h[v]].push_back(v);
			}
		//cout << "no is " << u << " " << rec.size() << '\n';
		//通过节点的hash值情况进行一些哈希。
	};
}
```

