##### 树的存储

- 关于树的几个关键概念。
  - 树根。
  - 儿子
  - 树的边数（等于节点树减一）
  - 子树。

-  树的存储。
  - 邻接矩阵。
  - 邻接表。

---

###### 着重处理邻接表的储存管理问题。

#### $first---$利用$stl$中的$vector$来实现邻接表。

```cpp
#include<vector>
//声明。
vector<vector<type>> g;
//初始化。
g.resize(n+1);
//g[i].存储了和节点i相关的边。里面的元素，和i节点有连接的关系，
```

---

#### $second---$自己建立一个数据结构邻接表。相关行为要简洁，常数小。

- 一般的应用背景
  - 给出总边数。节点数知道了，总边数自然就知道了。
  - 某个节点的儿子数不知道。

- 最简单的写法。
  - 直接定义一个指针数组。数组上的每一个指针都代表着，管理相关节点的儿子族的头指针。也就是代表了一个链表。
  - 优化方法，再次定义一个数组，来存储每一链表的尾部地址。可以实现$O(1)$的插入。
  - 缺点：
    - ~~不够装逼~~。
    - $new运算，常数贡献比较大。$

---



- 其它写法，完全不沾边指针的概念。

  - $tips$
    - 用一个数组来存储节点。节点的地址，可以是当前的索引。该种关注角度也可以完成一个节点的元素的寻址问题。
    - 采用头部接入，就可以不关注尾部。$（事实上，笔者总是忽略从头部接入。反过来想一想，可以发是否可行。可以有突破性的发现。逆向思维。）$

  #### $code$

  ```cpp
  const int maxn=1e6+10;
  struct edge
  {
      int t, next;
  } e[maxn << 1];
  int tot, head[maxn];
  void add(int x, int y)
  {
      e[++tot].t = y;
      e[tot].next = head[x];
      head[x] = tot;
  }
  /////定义方式。
  //使用细节
  //遍历
  //fa: now的父节点。
  //now:节点。现在的任务是遍历当前的节点
  for(int i=head[x];i;i=e[i].next)
  if(e[i].t!=fa)//表示的当前就是子节点。
  {
      //stament
  }
  ```