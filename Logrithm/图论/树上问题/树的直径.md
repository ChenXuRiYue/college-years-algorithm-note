#### **树的直径**

#### **概念**
直径： 两点之间的最大距离。
#### 求直径的方法：
1. 树形dp求直接直径：
2. 两次bfs求直径：

#### 拓展

1. 给定一个点， 求出其与其它点之间的最大距离：
   1. 换根dp求法 ： 比较困难。
   2. 从直径上的两个点开始进行bfs。求出最大距离。

#### bfs方法下求

依然是下述的例题：

**jls代码**

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n;
    std::cin >> n;
    
    std::vector<std::vector<int>> adj(n);
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    std::vector<int> d(n, -1);
    auto bfs = [&](int x) {
        std::queue<int> q;
        d.assign(n, -1);
        q.push(x);
        d[x] = 0;
        
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            
            for (auto y : adj[x]) {
                if (d[y] == -1) {
                    d[y] = d[x] + 1;
                    q.push(y);
                }
            }
        }
        
        return std::max_element(d.begin(), d.end()) - d.begin();
    };
    
    int x = bfs(0);
    int y = bfs(x);
    auto dx = d;
    bfs(y);
    auto dy = d;
    
    std::vector<int> ans(n + 1);
    for (int i = 0; i < n; i++) {
        ans[std::max(dx[i], dy[i]) + 1] += 1;
    }
    ans[0] += 1;
    ans[dx[y] + 1] -= 1;
    for (int i = 1; i <= n; i++) {
        ans[i] += ans[i - 1];
    }
    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << " \n"[i == n];
    }
    
    return 0;
}
```







#### 例题：

**D. A Wide, Wide Graph**
[Problem - D - Codeforces](https://codeforces.com/contest/1805/problem/D)

 [换根dp求树直径.md](..\..\动态规划\树形dp\换根dp\换根dp求树直径.md) 

**换根dp处理给定一个点 ，到其它点的最大距离：**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
vector<int> g[N];
int d[N];
int pa[N];
int sum[N];
//子树深度
void dfs(int u, int fa) {
	d[u] = 0;
	for (auto v : g[u]) {
		if (fa != v) {
			dfs(v, u);
			d[u] = max(d[v] + 1, d[u]);
		}
	}
}
//换根部dp;
void dfs2(int u, int fa) {

	int sz = g[u].size();
	vector<int>pre(sz + 5, -1), suf(sz + 5, -1);
	d[u] = max(d[u], pa[fa] + 1);
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pre[i] = max(pre[i - 1], d[g[u][i - 1]]);
		}
		else pre[i] = pre[i - 1];
	}
	for (int i = sz; i >= 1; i--) {
		int v = g[u][i - 1];
		if (fa != v) {
			suf[i] = max(suf[i + 1], d[g[u][i - 1]]);
		}
		else suf[i] = suf[i + 1];
	}
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pa[u] = max({ pre[i - 1] , suf[i + 1] , pa[fa]}) + 1;
			dfs2(g[u][i - 1], u);
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n; cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	// for (int i = 1; i <= n; i++) {
	// 	cout << d[i] << " \n"[i == n];
	// }
	pa[0] = -1;
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) {
		sum[d[i] + 1]++;
	}
	// for (int i = 1; i <= n; i++) {
	// 	cout << d[i] << " \n"[i == n];
	// }
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + sum[i];
		cout << min(1 + sum[i], n) << " \n"[i == n];
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





