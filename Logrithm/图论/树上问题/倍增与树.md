#### 倍增与树

利用倍增的思想， 可以给树上的点建立父亲st表：
应用st表： 可以完成以下任务：

1. 最近公共祖先：

   原理： 可以用$2^0 ......2^{31}$这些二进制数字， 且每个数字只使用一次 ， 拼凑出所有的在范围内的数字。

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 500050;
const int LOGN = 18;

int par[LOGN + 1][N] , dep[N];
vector<int> g[N];

void dfs(int u , int fa) {
	par[0][u] = fa;
	dep[u] = dep[fa] + 1;
	for (auto v : g[u]) {
		if (v != fa) {
			dfs(v , u);
		}
	}
}

int query(int u , int v) {
	if (dep[u] > dep[v]) swap(u , v);
	int d = dep[v] - dep[u];
	for (int i = LOGN; i >= 0; i--) {
		if (d >= (1 << i)) {
			d -= (1 << i);
			v = par[i][v];
		}
	}
	if (u == v) return u;
	for (int i = LOGN; i >= 0; i--) {
		if (par[i][u] != par[i][v]) {
			u = par[i][u];
			v = par[i][v];
		}
	}
	return par[0][u];
}
int main() {

	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m , s;
	cin >> n >> m >> s;
	for (int i = 1; i < n; i++) {
		int u , v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(s , 0);
	for (int i = 1; i <= LOGN; i++)
		for (int j = 1; j <= n; j++) {
			par[i][j] = par[i - 1][par[i - 1][j]];
		}
	for (int i = 0; i < m; i++) {
		int u , v;
		cin >>  u >> v;
		cout << query(u , v) << "\n";
	}

}
```

2. 两点之间的路径最小值：

   http://oj.daimayuan.top/course/15/problem/793
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 201000;
const int LOGN = 18;

int n, q;
int dep[N], par[N][LOGN + 1], val[N][LOGN + 1];
vector<pair<int, int>> e[N];

void dfs(int u, int f) {
	dep[u] = dep[f] + 1;
	for (auto p : e[u]) {
		int v = p.first;
		if (v == f) continue;
		par[v][0] = u;
		val[v][0] = p.second;
		dfs(v, u);
	}
}
int query(int u, int v) {
	int ans = 1 << 30;
	if (dep[u] > dep[v]) swap(u, v);
	int d = dep[v] - dep[u];
	for (int j = LOGN; j >= 0; j--) if (d & (1 << j)) {
		ans = min(ans, val[v][j]);
		v = par[v][j];
	}
	if (u == v) return ans;
	for (int j = LOGN; j >= 0; j--) if (par[u][j] != par[v][j]) {
		ans = min(ans, min(val[u][j], val[v][j]));
		u = par[u][j];
		v = par[v][j];
	}
	ans = min(ans, min(val[u][0], val[v][0]));
	return ans;
}

int main() {
	scanf("%d%d",&n, &q);
	for (int i = 1; i < n; i++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		e[u].push_back(make_pair(v, w));
		e[v].push_back(make_pair(u, w));
	}
	dfs(1, 0);
	for (int j = 1; j <= LOGN; j++) {
		for (int u = 1; u <= n; u++) {
			par[u][j] = par[par[u][j - 1]][j - 1];
			val[u][j] = min(val[u][j - 1], val[par[u][j - 1]][j - 1]);
		}
	}
	for (int i = 1; i <= q; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		printf("%d\n", query(u, v));
	}
}
```

3. 路径上的最小点权值；
4. 第k祖先：略；



