[P3825 [NOI2017\] 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3825)

#### 简介

在几种地图上进行若干种比赛：

1. A B C 分别不能使用 a ，b , c类型的赛车
2. X 型三种赛车都可以使用。

给出若干限制：

格式如下：

 i   ， ty1   ,  j , ty2;

表示如果i使用了 ty类型的赛车 ， 那么j就要使用ty2类型的赛车。



#### solve

##### 首先考虑没有x的限制。

那么问题就转换成了典型的2 —SAT问题。

n个集合（某一场）每个集合有两种元素选择（可以选择的赛车类型只有两种。）然后给出若干个矛盾式子。表示某一些选择矛盾。

于是可以根据限制建立一个图：

1. 假设限制都符合题意。限制中为地图分配的赛车适合地图。

   $a=>b , !b=>!a$

2. 如果有题意限制。那这个限制意味着什么？

   1. 如果 ty1不符合，且ty2不符合。没有影响。

   2. 如果ty1符合 ， ty2不符合。不可以选择ty1。

      $a=>!a$

   3. 如果ty1不符合，ty2符合。那么，没有影响，不用建立边。

##### x限制下的情况。

1. 暴力做法

   枚举每一个特殊地图的情况。（枚举部分集合的选择）

   然后怎么处理这些枚举？

   1. 枚举

   2. 然后根据枚举影响建边的情况。如果限制违反了枚举。

      当然建立边的前提都是，这个场地是前面三种类型的场地。

      比方说i已经选了，刚好是ty1限制，j只能选择一个点。于是给j建立一条!j => j的边

      如果说j已经选了，刚好是限制。没有影响。如果并不是限制，那么i不能够选择ty1。

​		复杂度$O(3^d*(n + m))$

2. 复杂度优化

   对于x类型的点，可以枚举它们是只能选择AB类  ， AC类。然后合c类地图  ， b类地图一样建边即可。

   这样同样可以使用$2^d(N+M)$的复杂度计算出所有情况。

   怎么感受两种方式的等价性？

   如果暴力得到了一组解。那么在2的这种枚举的图之中必然也可以得到一组解。

##### 生长思考

1. 这种情况下，使用模运算来建模。

2. 有一种随机的方法。搜到就退出的技巧。这次是第一次遇到。

   如果不断地枚举，枚举到了1.9s依然搜索不了，就退出输出无解。



#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

string s; // 地图的类型；
int n , d , m ;
vector<array<int , 4>> rec;//这个是

const int N = 1E5 + 10;

vector<int> e[N];
int dfn[N] , low[N] , bel[N], ins[N] , id , cunt;

stack<int>stk;
char ans[N];

void dfs(int u) {

	dfn[u] = low[u] = ++id;
	ins[u] = true;
	stk.push(u);

	for (auto v : e[u]) {
		if (!dfn[v]) dfs(v);
		if (ins[v]) low[u] = min(low[v] , low[u]);
	}
	if (low[u] == dfn[u]) {
		cunt++;
		while (true) {
			int v = stk.top();
			stk.pop();
			ins[v] = false;
			bel[v] =  cunt;
			if (v == u)break;
		}
	}
}
void tarjan()
{
	id = cunt = 0;
	for (int  i = 0; i < 2 * n; i++) {
		if (dfn[i] == 0)
			dfs(i);
	}
}


bool check() {
	//首先进行建立边。
	for (int i = 0; i < 2 * n; i++) {
		e[i].clear();
		dfn[i] = 0;
		low[i] = 0;
	}
	//该函数的作用是，i场， ty类型汽车确定的顶点。
	function<int(int  , int)> getid = [&](int i , int ty) -> int {
		int t = s[i] - 'a';
		if (t == ty) return -1;
		//然后怎么寻找到他是作为第一个还是第二个？
		if (t == (ty + 1) % 3) return i * 2;
		if (t == (ty + 2) % 3) return i * 2 + 1;
		return -1;
	};

	//得到关注状态的点的id。
	for (int i = 0; i < m; i++) {
		//建图方法。
		//建图就是建立边，所以我们定位两个顶点。
		int f1 = getid(rec[i][0] , rec[i][1]);
		int f2 = getid(rec[i][2] , rec[i][3]);
		//现在是讨论多种建边情况。
		//不需要建边
		if (f1 != -1 && f2 != -1) {
			e[f1].push_back(f2);
			e[f2 ^ 1].push_back(f1 ^ 1);
		}
		else if (f1 != -1 && f2 == -1) {
			e[f1].push_back(f1 ^ 1);
		}
	}
	tarjan();

	for (int i = 0; i < n; i++) {
		if (bel[i * 2] == bel[i * 2 + 1])
			return false;
	}
	//尽量选dfn比较小的。即从前一个开始选起来
	for (int i = 0; i < n; i++) {
		if (bel[i * 2] < bel[i * 2 + 1]) {
			ans[i] = (s[i] - 'a' + 2) % 3 + 'A';
		}
		else ans[i] = (s[i] - 'a' + 1) % 3 + 'A';
	}

	cout << ans << '\n';
	return true;
	//天生我才必有用，千金散尽还复来。
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> d >> s >> m;

	vector<int> X;

	for (int i = 1; i <= m; i++) {
		int a , c;
		char b , d;
		cin >> a >> b >> c >> d;
		a-- , c --;
		//记录限制。
		rec.push_back({a , b - 'A' , c , d - 'A'});
	}

	//枚举d中的地图是哪一种类型？
	for (int i = 0; i < n; i++) {
		if (s[i] == 'x') X.push_back(i);
	}
	for (int S = 0; S < (1 << d); S ++ ) {
		for (int i = 0; i < d ; i++) {
			s[X[i]] = "ab"[S >> i & 1];
		}
		if (check()) return 0;
	}
	cout << "-1\n";
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

