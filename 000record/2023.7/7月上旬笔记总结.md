

# 七月上中旬 （多校前训练）

**阅读就是抛弃自己的一切意图与偏见，随时准备接收突如其来且不知来自何方的声音。**
**codeforces 刷题：**

1.  
2.  [F. The Boss's Identity.md](..\..\problems\codeforces\2000\模型\位运算\F. The Boss's Identity.md) 二分
    **构造：**
3.  [D. Walk on Matrix.md](..\..\problems\codeforces\1700\构造\位运算\D. Walk on Matrix.md) 
4.  [D. Tenzing and His Animal Friends.md](..\..\problems\codeforces\1900\图论建模\D. Tenzing and His Animal Friends.md)  ==证明未补充==
5.  [D. Circular Spanning Tree.md](..\..\problems\codeforces\2000\构造\图论\D. Circular Spanning Tree.md)  
6.  [D1. Domino (easy version).md](..\..\problems\codeforces\1700\构造\递归构造\D1. Domino (easy version).md)  ==咕咕 ， 怎么证明啊==

**动态规划：**

1. [E. Two Chess Pieces.md](..\..\problems\codeforces\1900\动态规划\树形dp\E. Two Chess Pieces.md)
2. [E. Tenzing and Triangle.md](..\..\problems\codeforces\2300\动态规划\E. Tenzing and Triangle.md) 
3. [D2. Zero-One (Hard Version).md](..\..\problems\codeforces\2000\动态规划\字符串模型\D2. Zero-One (Hard Version).md) ==有点东西没有证明出来==
4. [D1. Xor-Subsequence (easy version).md](..\..\problems\codeforces\1800\动态规划\位运算\D1. Xor-Subsequence (easy version).md) 
5. [Different Arrays.md](..\..\problems\codeforces\2000\动态规划\线性dp\数组模型\Different Arrays.md)  
6. [A2. Burenka and Traditions (hard version).md](..\..\problems\codeforces\1900\动态规划\位运算模型\A2. Burenka and Traditions (hard version).md) 

**图论**

1.  [M. Moving Both Hands.md](..\..\problems\codeforces\1800\图论\图的处理\二层图\M. Moving Both Hands.md)  

**字符串**

1.  [字符串哈希板子.md](..\..\Logrithm\string\字符串hash\字符串哈希板子.md)  ==怎么shi'yong

**补题：**

1. div2 882 ：  上述F
1. div1 + div2 884
1. 小白月赛76： 
   1.  [Kevin的矩阵.md](..\..\problems\nowcoder\小白月赛\根号枚举模型\Kevin的矩阵.md)  根号分治
1. atcoder abc  [D Peaceful Teams.md](..\..\problems\atcoder\搜索\D Peaceful Teams.md) ==一个bug没能解决==

**算法学习：**

1. 启发式合并：
   1.  [HNOI2009, 梦幻布丁.md](..\..\Logrithm\数据结构\启发式合并\例题\HNOI2009, 梦幻布丁.md) 
   2.  [启发式合并.md](..\..\Logrithm\数据结构\启发式合并\启发式合并.md)  
   3.  [最小路径(启发式合并解法).md](..\..\Logrithm\数据结构\启发式合并\例题\最小路径(启发式合并解法).md)
   4.  [启发式分治.md](..\..\Logrithm\杂篇\启发式算法\启发式分治.md) 
2. DSU on tree
   1.  [DSU on tree.md](..\..\Logrithm\数据结构\DSU on tree\DSU on tree.md) 
   2.  [E. Lomsat gelral.md](..\..\Logrithm\数据结构\DSU on tree\例题\E. Lomsat gelral.md)
   3.  [[IOI2011] Race.md](..\..\Logrithm\数据结构\DSU on tree\例题\[IOI2011] Race.md) =
3. [dfs序.md](..\..\Logrithm\图论\树上问题\dfs序.md) 
4. [树链剖分.md](..\..\Logrithm\数据结构\树链剖分\树链剖分.md) ==课程内容未学完==

# D. Rating System

[Problem - D - Codeforces](https://codeforces.com/contest/1845/problem/D)

## 题面翻译

给定一个长度为 $n$ 数列 $a$，保证每项都不为 $0$。初始时 $x=0$，然后对于 $1\le i\le n$，按顺序进行如下操作：

- 如果 $x\ge k$，则 $x\rightarrow \max(k, x+a_i)$，否则 $x\rightarrow x+a_i$。
  你需要求出 $k$，使得 $x$ 的值尽量大。

## solve

当选定一个k ， 并且rating恰好到达k之后 ：

1. 接下来连续的一段如负数的段和，等效于这段rating的变化操作无效。
   1. 于是找到最长的一段最大的负数段，其余的总和减去该段即为后续的rating变化.即，最终的答案是k + remain - 前缀（没有则表示0） ===> k + 最大后缀。
      关于k的选择：
1. 关注a数组的前缀和， 选择前缀和上数组的值作为k是更优的：
   1. 对于k迁移到离他最近的sum数组元素值， 效果不会更差：
      证明如下：
      1. 选择更大的元素： 
         
         两个的最大后缀其实是一样的。因此，此时k越大越好。
         如果只有更小的最近，说明，将k移动到该值，能保证其结果为更小的最近前缀和，结果不会更坏。
         补充： 注意

## 生长思考

1. 数组模型的关注角度，总是比较明确的。
   1. 前后缀。
   2. 选择前缀值为k。
   3. 策略的等效替换。

## code

```cpp
void work(int testNo)
{
	int n;
	cin >> n;
	vector<ll> a(n + 1) , pre(n + 1 , 0) , suf(n + 2 , 0);
	// 后缀加上最大前缀。
	ll ans = 0;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++) {
		pre[i] = a[i] + pre[i - 1];
	}
	for (int i = n; i >= 1; i--) {
		suf[i] = max(suf[i + 1] , pre[n] - pre[i - 1]);
	}
	ll mx = suf[1];
	for (int i = 1; i <= n; i++) {
		if (pre[i] + suf[i + 1] > mx) {
			ans = pre[i];
			mx = pre[i] + suf[i + 1];
		}
	}
	cout << max(ans , 0LL) << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

-----

**F. The Boss's Identity**
https://codeforces.com/contest/1847/problem/F
![image-20230710160041504](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230710160041504.png)
用或运算相关的方式，构造出一个数组，基于该数组 ， 解决的经典首个大问题：

#### 20mins

1. 如果只是给定一个静态的数组，怎么去解决上述问题？
   1. 基础的离散化。
   2. 记录某一个离散值的最小位置。
   3. 使用前缀和优化。
2. 题目中的或运算，显示出了什么信息？
   1. 无限的推演下去，最后是否稳定？
      1. 稳定与整个数组的或和。
      2. 数组中出现的不同的元素值的组合方式是$n^2$，数量非常多，因此不能从整体上进行一个统计后处理。
   2. 怎么确定某一个值？ 打表。
      1. 分为若干类型： 2 ， 3 ， 4 ， 5。各个数的所有匹配方式都将会被考虑到。
   3. 给定一个值后怎么check。
      1. 分类讨论：
         1. 前面n个没有更加大的。
         2. 最多选择30不同的元素或运算，可能就可以表达出能表达的所有数字。
      2. 变成选择某一些数字，再定位这个数字的最小的位置在何处的问题。

### solve

参考题解：

[Codeforces Round 882 (Div. 2) A - D, F - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/642054672)

关键：

1. 关注到有效或字段的有限性。
2. 整理后，进行一个二分。

![image-20230710164354755](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230710164354755.png)

#### 实现的几个关键：

1. 怎么整理出不同右端点下，有效的子段？
2. 怎么在上述基础上进行一个二分？



模仿 

Heltion's code

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = int64_t;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t;
    for (cin >> t; t; t -= 1) {
        int n, q;
        cin >> n >> q;
        vector<int> a(2 * n);
        for (int i = 0; i < n; i += 1) {
            cin >> a[i];
            a[i + n] = a[i];
        }
        vector<pair<i64, int>> ans;
        ans.emplace_back(0, a[0]);
        vector<pair<int, int>> f = {{a[0], 0}};
        for (int i = 1; i < 2 * n; i += 1) {
            f.emplace_back(0, i);
            vector<pair<int, int>> g;
            for (auto [x, y] : f) {
                x |= a[i];
                if (not g.empty() and g.back().first == x) {
                    g.pop_back();
                }
                g.emplace_back(x, y);
            }
            f.swap(g);
            if (i > n) {
                for (auto [x, y] : f) {
                    ans.emplace_back(i64(i - y) * (n - 1) + i - n, x);
                }
            }
        }
        ranges::sort(ans);
        vector<pair<int, i64>> res;
        for (auto [x, y] : ans) {
            if (res.empty() or y > res.back().first) {
                res.emplace_back(y, x);
            }
        }
        for (int i = 0, v; i < q; i += 1) {
            cin >> v;
            auto it =
                ranges::upper_bound(res, pair(v, numeric_limits<i64>::max()));
            if (it == res.end()) {
                cout << "-1\n";
            } else {
                cout << it->second + 1 << "\n";
            }
        }
    }
}
```

#### 吸收

1. 得到各个子段和的方法：

   1. 基于上一轮的子段和进行拓展，并且尽量使其更短： 左边界靠右。

   2. 去重问题：

      1. 上述的代码是利用了连续或子段的性质：

      ```cpp
      for (auto [x, y] : f) {
          x |= a[i];
          if (not g.empty() and g.back().first == x) {
              g.pop_back();
          }
          g.emplace_back(x, y);
      }
      对于他们是连续存放的。这意味着有一个长度上升的连续关系。那么先入的更长。并且如果存在两段相等，必然是相邻入g的。（或运算的特殊性质）
      ```

2. 将所有的段进行一个权值分配，使得排序后既满足二分的条件，也满足其选择策略的优先级别：

   1. 这里的方法是：通过几个特征构造一个数字：

      1. 其长度，越小越好
      2. 右边界，越小越好。

   2. 于是将其整合成：

      ```
      (i - y) * (n - 1) + i - n , x
      其实这个数字就是第几个。
      ```

3. 怎么基于上述的整合值进行二分？

```cpp
// 先根据第一维进行一个排序。
ranges::sort(ans);
vector<pair<int, i64>> res;

// 反过来升序去重。
for (auto [x, y] : ans) {
    if (res.empty() or y > res.back().first) {
        res.emplace_back(y, x);
    }
}
// 总的来说，为了减少麻烦，Heltion对这个数组进行了多次的处理。

for (int i = 0, v; i < q; i += 1) {
    cin >> v;
    // 这个函数的作用是返回内置类型的最大值。
    auto it =
        ranges::upper_bound(res, pair(v, numeric_limits<i64>::max()));
    if (it == res.end()) {
        cout << "-1\n";
    } else {
        cout << it->second + 1 << "\n";
    }
}
```



**D. Walk on Matrix**
https://codeforces.com/problemset/problem/1332/D

给定举证： 规定从(1 , 1)开始， 只能够向下， 向右走。求矩阵上行动的最大and和。给出以下算法，发现该算法是不正确的。

![img](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1332D/f77be4abbc0e4a1768015d201a26d68f6c552a32.png)

构造出一个矩阵， 使得该正确答案和上述算法得出的答案相差k。

## solve

首先特殊的 ：

1. 考虑：由算法得到的答案为0.
2. 考虑：矩阵尽量小： 
   1. $2\times2$  
   2. $2\times 3$
3. 构造思路： 骗一个人先得到，然后全部失去。 
4. 位运算中一种常见的构造思路， 构造一个高位权。可以达到区分，调整数大小等等功能.

因此可以是：

```txt
1 << 17  + k	 (1 << 17)	   	 0
k		        (1 << 17) + k    k
```

## code

```cpp
signed main()
{
	int k;
	scanf("%d" , &k);
	printf("2 3\n");
	printf("%d %d %d\n" , (1 << 17) + k , (1 << 17) , 0);
	printf("%d %d %d\n" , k , (1 << 17) + k , k);
}
```

---

**D. Tenzing and His Animal Friends**
https://codeforces.com/contest/1842/problem/D

![image-20230711152217951](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230711152217951.png)

## solve

1. 无穷大解的判定：
   凭借限制构造一个图，如果发现1 和 n不在同一个连通块。那么将1所在的连通块一直做游戏，且时间无穷不违反题意。否则，由于n被孤立在外，1所在的连通块规模会不断减少。这意味着最终会有一个终点。

2. 最优解策略：

   1. 人数选择上： 每一次游戏，将能与1参加游戏的所有人一起全被列入：

      ==证明==

   2. 时间选择上： 关注两个集合，可以与1参与游戏的集合，不可以与1参与游戏的集合。在这两个集合之间选择最短边。作为游戏时长。

      1. 如果大于关注最短边就违背规则。

      2. 如果小于关注最短边，在1的贪心规律下，迟早将该最短边的时长给用完。


## code

```cpp
struct DSU {
	std::vector<int> f, siz;

	DSU() {}
	DSU(int n) {
		init(n);
	}

	void init(int n) {
		f.resize(n);
		std::iota(f.begin(), f.end(), 0);
		siz.assign(n, 1);
	}

	int find(int x) {
		while (x != f[x]) {
			x = f[x] = f[f[x]];
		}
		return x;
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	bool merge(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) {
			return false;
		}
		siz[x] += siz[y];
		f[y] = x;
		return true;
	}

	int size(int x) {
		return siz[find(x)];
	}
};

vector<array<int , 3>> edge;
bool can[N];
ll have[N]; // 总的单人游玩时间。

struct node {
	string s;
	ll t;
};
vector<node> ans;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n ,  m;
	cin >> n >> m;
	DSU dsu(n);
	for (int i = 0; i < m; i++) {
		int u , v , w;
		cin >> u >> v >> w;
		u-- , v--;
		dsu.merge(u , v);
		edge.push_back({u , v , w});
	}

	if (not dsu.same(0 , n - 1)) {
		cout << "inf\n"; return 0;
	}
	// 然后维护两个集合，寻找最短边。
	can[n - 1] = true;
	// 寻找两个集合之间的最短边。
	// 直到不再存在该点。
	// 分别表示总游戏时间
	ll time = 0;
	int sum = 0;

	while (!can[0]) {
		int mi = INF;
		for (auto [u , v , w] : edge) {
			if (can[u] != can[v]) {
				// 已经一起共同游玩的时间。
				mi = min(mi , w);
			}
		}
		string res;
		for (int i = 0; i < n; i++) {
			if (not can[i]) {
				res += "1";
			} else {
				res += "0";
			}
		}
		ans.push_back({res , mi});
		sum++;
		time += mi;
		// 然后对两个集合进行更新。
		vector<array<int , 3>> g;
		vector<int> rrec;
		for (auto &[u , v , w] : edge) {
			if (can[u] != can[v]) {
				w -= mi;
				if (w == 0) {
					// 注意这个后效性。
					// can[u] = can[v] = true;
					rrec.push_back(u);
					rrec.push_back(v);
				}
			}
		}
		for (auto v : rrec) {
			can[v] = true;
		}
	}

	cout << time << " " << sum << "\n";
	for (auto [s , t] : ans) {
		cout << s << " " << t << "\n";
	}
}
```



# D. Circular Spanning Tree

https://codeforces.com/contest/1682/problem/D

对1 .... n的点根据顺时针排列：对这些点之间进行连边， 要求这些连边之间不能存在焦点。同时给定一个01字符串，限制约束了当前各个点的奇偶性： 请给出一个构造方案，或者说不存在合法方案：

![img](https://espresso.codeforces.com/402c10979a8035063e99b5370877562ae422c628.png)

##  solve

自己的解法是： 
关注了几个属性：
首先将：判断一些无解的情况：

1. 对一颗树的基本认识： 总度数和为偶数，这意味着奇数度数的节点必然要有偶数个。



更一般的寻找一个解法：

1. 关于根节点的选取：
   1. 偶数节点
   2. 奇数节点；

2. 一种特殊的手段，尽量圆内连点，避开更多的考虑空间。将圆划分成一段一段的。用偶数节点作为根节点，就容易处理好每一段。

具体的规则如下图：

![笔记](C:/Users/86153/Desktop/%E7%AC%94%E8%AE%B0.png)

三个关键如上：

1. 怎么划分段？ 从根节点开始偶 ....偶 奇 直到 最后一段特殊段：
2. 一般段处理？
3. 最后段怎么处理。上述都已经用绿色的线条强调完毕。

## 生长思考：

1. 非常美妙的角度挖掘：本质上依然是一个原理，

   1. 一般性
      1. 分几类之后，发现这种构造，可以唯一解决。
   2. 简洁性
      1. 成段连续。
      2. 简单明了的操作过程。
   3. 局部构造的统一到整体构造的统一。
      1. 局部段构造，到整体的构造。
   4. 递归构造。
      1. 同三
   5. 观察，定义，或者关注属性：
      1. 奇偶性
      2. 段
      3. 根节点。

   不断的面对一些模型进行构造，这几个构造手段都会更加娴熟，高明。

## code

```cpp
void work(int testNo)
{
	int n;
	string s;
	cin >> n >> s;
	int c[2] {};
	for (int i = 0; i < n; i++) {
		c[s[i] == '1']++;
	}
	if (c[1] & 1 || c[1] == 0) {
		cout << "NO\n";
		return;
	}
	cout << "YES\n";
	int root = 0;
	if (c[0]) {
		// 随便找一个根节点。
		while (s[root] == '1') root++;
		// 同一个方向上分类。
		// 准备将奇数度数的节点把被处理了。
		int sum = 1;
		int ptr = (root + 1) % n;
		while (sum < c[1]) {
			sum++;
			cout << root + 1 << " " << ptr + 1 << "\n";
			// 继续将其它情况处理。
			int pre;
			while (s[ptr] == '0') {
				pre = ptr;
				ptr = (ptr + 1) % n;
				cout << pre + 1 << " " << ptr + 1 << "\n";
			}
			ptr = (ptr + 1) % n;
		}
		// 然后只剩下最后一个1.
		// 两个过程：
		// 首先逆向的走，连边直到奇数节点。
		int pre = root;
		for (int nxt = (root + n - 1) % n; s[nxt] != '1'; ) {
			cout << pre + 1 << " " << nxt + 1 << "\n";
			pre = (pre + n - 1) % n;
			nxt = (nxt + n - 1) % n;
		}

		// while (s[ptr] == '0') {
		// 	ptr = (ptr + 1) % n;
		// 	pre = (pre + 1) % n;
		// 	cout << pre + 1 << " " << ptr + 1 << "\n";
		// }
		while (s[pre] == '0') {
			cout << pre + 1 << " " << ptr + 1 << "\n";
			pre = ptr;
			ptr = (ptr + 1) % n;
		}
		// 过程已经找出来了，剩下的只是模拟问题而已：
		/*
		1
		4
		1010
		*/


	}
	else {
		root = 1;
		for (int i = 2; i <= n; i++) {
			cout << root << " " << i << "\n";
		}
	}
}


signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

----

#  D1. Domino (easy version)

https://codeforces.com/contest/1551/problem/D1

![image-20230714151950458](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230714151950458.png)

## solve

几个结论： 某一种方式下必定行。这个能够理解。但是某种方式下不行这方面不能证明。

总的来说，啥也不想，一筹莫展，不如提问题：

1. 什么情况下，有特殊的构造手段，是一定行的。

   1. 很容易发现当 n : 偶 ， m ： 偶 ， k ： 偶时是一定行的。

      1. 具体手段如下： 将k块合并成若干$2\times 2$的大方块。很容易的就可以将其填满。并且剩下的部分一定也是若干个$2\times 2$的正方形。 （局部构造到整体构造的过程。可以说是构造的递归性把握手段。） 特殊性， 只需要寻求一个解，而不是从复杂的理论，深刻性质的把握入手。
2. 基于上述结论： n 偶 ， m 偶， k奇 是否也行？
   1. 如果按照1 中的构造方式是不行的，因为始终会有至少两列 只有奇数个格子。





## code

```cpp
void work(int testNo)
{
	int n , m , k;
	cin >> n >> m >> k;
	if ((n & 1) == 0 && (m & 1) == 0) {
		cout << (k % 2 ? "NO\n" : "YES\n");
	} else if (n % 2) {
		if (k >= m / 2 && (k - m / 2) % 2 == 0) {
			cout << "YES\n";
		}
		else cout << "NO\n";
	} else {
		if (k % 2 == 0 && k <= (m - 1)*n / 2) {
			cout << "YES\n";
		} else cout << "NO\n";
	}
}
```

----

**E. Two Chess Pieces**
https://codeforces.com/contest/1774/problem/E

![image-20230711090507015](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230711090507015.png)

### solve

从另外一个角度出发：

1. 当我们知道a应该走到那个点时 ， 由两者最大距离不超过d。可以得到b哪些点也是必走的。
2. 于是根据两者的必走点，可以推出所有必走点。

推出必走点：分几种情况

1. 对于u , 在以u为根的子树中，两者都有必走点。那么u两者都必走。

2. 如果只有一个有，找出要到达的最大深度，即可计算出u到最大深度的距离。关注d ，从而判断是

   另外一个角色是否必须经过该点。

由必走点推出距离：

1. 发现往返，其答案就是（sum - 1)*2

**实现：**

1. 简单跑一遍dfs ， 做一个非常基础的树形dp即可。

### code

```cpp
const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;

vector<int> g[N];
ll cnt0 , cnt1;
int dep[N] , n ,  d;
bool vis1[N] , vis2[N];

void getdep(int u , int fa , int d) {
	dep[u] = d;
	for (auto v : g[u]) {
		if (v != fa) {
			getdep(v , u , d + 1);
		}
	}
}

// pair<int , int> 这里是用来访问
pair<int , int> dfs(int u , int fa ) {
	pair<int , int> rec;
	if (vis1[u])
		rec.fi = dep[u];
	if (vis2[u])
		rec.se = dep[u];

	for (auto v : g[u]) {
		if (v == fa) continue;
		auto t = dfs(v , u);
		rec.fi = max(t.fi , rec.fi);
		rec.se = max(t.se , rec.se);
	}
	if (rec.fi) {
		cnt0++;
		if (rec.se) cnt1++;
		else if (rec.fi - dep[u] >= d)
			cnt1++;
	} else {
		if (rec.se) {
			cnt1++;
			cnt0 += (rec.se - dep[u] >= d);
		}
	}
	return rec;
}


signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> d;
	for (int i = 1; i < n; i++) {
		int u , v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	int x; cin >> x;
	for (int i = 0; i < x; i++) {
		int y; cin >> y;
		vis1[y] = true;
	}
	cin >> x;
	for (int i = 0; i < x; i++) {
		int y; cin >> y;
		vis2[y] = true;
	}

	getdep(1 , 0 , 1);
	dfs(1 , 0);
	cout << 2 * (cnt0 + cnt1 - 2) << "\n";
}
```

---

# E. Tenzing and Triangle

![image-20230712155721070](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230712155721070.png)
[Problem - E - Codeforces](https://codeforces.com/contest/1842/problem/E)

## solve

1. 对于解集： 两个三角形不相交是（更优的），用该点来指导分阶段中的策略。

### **相关状态设计以及相关的状态转移方程：**

**==$f_{L , R}$==**表示被三角形（L ， k - L）(R , k - R)覆盖的点的代价减之和减去A(R - L)。(可以简记为（L，R)）
==$dp_{i}$== 表示考虑前缀[1 , i] ， $\sum f(l_k , r_k)$ 的最大值。  ？？ 是 [0 ,i] 还是[1 , i]? 
状态转移方程：

1. i不被任何区间覆盖 : $dp_i <--- dp_{i - 1}$
2. i被[j + 1 , i] 覆盖 ， $dp_i <--- dp_j + f(j + 1 , i)$

--------------

==$g_j$==$ = dp_j + f_{j + 1 , i}$ ：：用于配合转移状态转移方程$dp_i$
从小到大枚举i ， 维护g的变化情况。 当i-1 -> i 时：

1. $g_{0....i-1}$ 减去A。
2. 对于每一点 ，(x , k - i) ,$g_0...x$ 加上点的代价。
3. 计算$dp_i$之后，修改$g_i = dp_i$ ，关注变量表示的实际意义，i点没有包含在任何区间内，可以用该点往后构造出长度为1 的 包含 [i , i + 1] 三角形的方案最优解。

### 初始化：

1. $dp_1$ 是直接给定一个初始化，还是对于 
2. 当i= 0 时， $g_0 = 0$。 
3. 初始化的原则：符合实际。

### 实现

主要是维护g。要求进行以下几种操作：

1. 区间加
1. 全局最大值。

因此可以用线段树维护。

## 生长点：

1. 初始化：
   1. 从哪个开始转移： i : 1 ... k
   2. 最小的问题是什么？
      1. 是否可以通过0这种特殊的解问题转移
      2. 直接赋值： 怎么赋值使得下一规模的子问题是正确解？
2. 这里的解空间的探究思路：
   1. 通过替换迁移，等效；贪心的发现相交的三角形可以转移到一个更优解。从而得到了一个阶段性明显的决策结构。
   2. 对g的定义其实就是对转移部分的对象的维护。从整体上看寻找相邻阶段中g的关系。
3. 线段树维护：
   1. 线段树的下标是可以从0开始维护的。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2E5 + 10;
// 该数组用来记录某个y坐标系下的x坐标值 , 以及该点的总代价。
vector<pair<int , int>> node[N];
//const int N = 201000;
//const ll mod = 1000000007;
int n, q;
struct tag {
	//维护标记。
	ll add;
};
//标记合并。用于updatetag
tag operator + (const tag &t1, const tag &t2) {
	// (x * t1.mul + t1.add) * t2.mul + t2.add
	return {t1.add + t2.add};
}
//节点的内容。数据项以及内容。
//如果维护信息比较复杂。也可以考虑将信息封装。并且如上写一个区间信息合并重载函数。
// 维护g。
struct node {
	tag t;
	ll mx;  // 维护查询区间最大值。
	int sz;
} seg[N * 4];
// [l, r]
//在modify以及建树之后。把两个儿子的信息合并。
void update(int id) {
	// 更新区间最大值。
	seg[id].mx = max(seg[id << 1 | 1].mx , seg[id << 1].mx);
}
//push down。
//完成两项东西。合并标记。
//修改区间信息。
void settag(int id, tag t) {
	seg[id].t = seg[id].t + t;
	seg[id].mx += t.add;
}
//记得将下放后将标记初始化。
void pushdown(int id) {
	settag(id * 2, seg[id].t);
	settag(id * 2 + 1, seg[id].t);
	seg[id].t.add = 0;
}

// 节点为id，对应的区间为[l, r]，修改a[pos] -> val
//记得update
//正确sertag
void modify(int id, int l, int r, int ql, int qr, tag t) {
	if (l == ql && r == qr) {
		settag(id, t);
		return;
	}
	int mid = (l + r) / 2;
	// 重要‼️
	pushdown(id);
	if (qr <= mid) modify(id * 2, l, mid, ql, qr, t);
	else if (ql > mid) modify(id * 2 + 1, mid + 1, r, ql, qr, t);
	else {
		modify(id * 2, l, mid, ql, mid, t);
		modify(id * 2 + 1, mid + 1, r, mid + 1, qr, t);
	}
	// 重要‼️
	update(id);
}
// [ql, qr]表示查询的区间
//到达终点时及时返回。
ll query(int id, int l, int r, int ql, int qr) {
	if (l == ql && r == qr) return seg[id].mx;
	int mid = (l + r) / 2;
	// 重要‼️
	pushdown(id);
	if (qr <= mid) return query(id * 2, l, mid, ql, qr);
	else if (ql > mid) return query(id * 2 + 1, mid + 1, r, ql, qr);
	else {
		// qr > mid, ql <= mid
		// [ql, mid], [mid + 1, qr]
		return max(query(id * 2, l, mid, ql, mid) ,
		           query(id * 2 + 1, mid + 1, r, mid + 1, qr));
	}
}
/*
1. 该代码处理问题：同时维护区间加，区间改变，区间乘法三种操作。
2. 调整过程
维护信息 -> build -> updata -> 区间信息合并函数
tag - > modify  -> push_down  ->  settag
query -> 返回类型，修改内容 , 信息合并。
*/
ll dp[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , k , A;
	cin >> n >> k >> A;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		int x , y , c;
		cin >> x >> y >> c;
		node[y].emplace_back(x , c);
		ans += c;
	}
	for (int i = 1; i <= k; i++) {
		//先对g进行一个更新：
		modify(1 , 0 , k , 0 , i - 1 , { -A});
		for (auto [x , c] : node[k - i]) {
			modify(1 , 0 , k , 0 , x  , {c});
		}
		dp[i] = max(dp[i - 1] , query(1 , 0 , k , 0 , i - 1));
		modify(1 , 0 , k , i , i , {dp[i]});
		// dp[i] = dp[i - 1];
		// modify(1 , 0 , k , 0 , i - 1 , {A});
		// for (auto [x , c] : node[k - i]) modify(1 , 0 , k , 0 , x , { -c});
		// dp[i] = min(dp[i] , query(1 , 0 , k , 0 , i - 1));
		// modify(1 , 0 , k , i , i , {dp[i]});
	}
	cout << ans - dp[k] << "\n";
}
```



2023.7.12

----

# D2. Zero-One (Hard Version)

https://codeforces.com/contest/1733/problem/D2

参考题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-cf1733d2
https://codeforces.com/blog/entry/83109

You are given two binary strings *a* and *b*, both of length *n*. You can do the following operation any number of times (possibly zero).

- Select two indices *l* and *r* (*l*<*r*).
- Change $(1 - a_l)$ and $a_r$ to $1 - a_r$
- If *l*+1=*r*, the cost of the operation is *x*. Otherwise, the cost is *y*.

You have to find the minimum cost needed to make *a* equal to *b* or say there is no way to do so.

## solve

### solve 1: $O(N^2)$

~~比O(N)的还复杂,性价比不高~~

### solve 2 : $O(N)$

首先做分类讨论。

1. y <= x : 容易解决； 如下代码：
2. y > x :

预处理： 对每个$a_i \ne b_i$的位置记录有序成一个数组。并且在这个数组的基础上进行dp。

**状态定义**

$f_i$ 表示将前i项处理完的最小代价。

**状态转移**

1. 当前选择非相邻的方式消除。
   1. $f_i -> f_{i - 1} + \frac{y}{2}$  // 这里使用了一些精妙地代价计算地方法。
2. 当前选择不断地向前相邻重置消除。
   1. $f_i -> f_{i -2} + (p_i - p_{i - 1})$

**初始化：**

1. $f_0 = 0 ,f_1 = y$

**处理一些困惑：**

1. 对于y/2能否不引入double，直接处理。可以先对所有地贡献项数乘上2。最后只需要将答案除于2即可。
   1. 一定是偶数吗？ y必定有偶数个。，因为y的转移涉及了奇数偶数的转换。奇数问题的求解，有奇数个第一次操作。（从记忆化搜索的角度来看。）

2. 为什么x总是和前面的位置进行第x操作相消？
   1. 如果是选当前i之前的元素进行操作，贪心的来看，选择最近是最优的，转移法证明，

还有一些疑惑： 其非相邻的选择方式中可以考虑一些更后方的没有考虑过的点。这很奇怪， 和自己经验冲突了。



#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
	int n;
	ll x ,  y;
	cin >> n >> x >> y;
	vector<int> pos;
	string s , t;
	cin >> s >> t;
	for (int i = 0; i < n; i++)
		if (s[i] != t[i]) {
			s[i] = '1';
			pos.push_back(i);
		} else s[i] = '0';
	int m = pos.size();
	if (m & 1) {
		cout << -1 << "\n";
		return;
	}
	if (y <= x) {
		if (n >= 5) {
			if (m == 2 && pos[0] == pos[1] - 1) {
				cout << min(2 * y , x) << "\n";
			} else {
				cout << m / 2 * y << "\n";
			}
		} else {
			// 无语了。
			if (s == "0110")
				cout << min(3 * y , x) << "\n";
			else if (s == "110" || s == "011" || s == "11")
				cout << x << "\n";
			else if (s == "1100" || s == "0011") cout << min(x , 2 * y) << "\n";
			else cout << m / 2 * y << "\n";
		}

	} else {
		//接下来特殊的用dp解决。

		vector<ll> f (m + 2 , 0);
		f[0] = 0; f[1] = y;
		for (int i = 2; i <= m; i++) {
			f[i] = min(f[i - 2] + (pos[i - 1] - pos[i - 2]) * x * 2 , f[i - 1] + y);
		}
		cout << f[m] / 2 << "\n";
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	while (t--)solve();
}
```



# D1. Xor-Subsequence

https://codeforces.com/contest/1720/problem/D1
https://codeforces.com/contest/1720/problem/D2

### 简介：

给定一个数组：$a_i$ ,选出0 .... (n - 1)的子序列满足：
$$
a_{b_p} \oplus b_{p+1} < a_{b_{p+1}} \oplus b_p
$$
找出该子序列的最大长度：

### solve

特殊的: 简单版本中每个元素小于200。启发 ：枚举一个数字被这个范围的数字至多影响为 +-256（事实上会更小一点）。 因此当$b_p$ 足够小时，$b_{p + 1} - b_{p} > 516$ 。 $a_{b_p} , a_{b_{p + 1}}$ 无论怎么调护，都不会使得大小左右大小关系转化。因此只需要枚举增量为516附近的元素即可。

### code

```cpp
int a[N];
void work(int testNo)
{
	int n;
	cin >> n;
	int mx = 0;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		mx = max(a[i] , mx);
	}
	vector<int> f(n , 1);
	int ans = 0;
	for (int i = 1; i < n; i++) {
		for (int j = max(0 , i - m); j < i; j++) {
			if ((a[j] ^ i) < (a[i] ^ j)) {
				f[i] = max(f[i] , f[j] + 1);
			}
		}
		ans = max(f[i] , ans);
	}
	cout << ans << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

## hard verson

进阶：$a_i$ 推广到了一般的$10^9$。上述的结论就不再适用：

1. 一个优化角度： 怎么将限制转变成单方面的限制？ 即，当确定i , $a_i$之后，就可以从知道从哪些状态转移？ 换而言之，记录状态关注更深刻的属性。

考察这个运算系统：
$$
a_{j} \oplus i < a_{i}\oplus  j
$$


集中精力解决得问题是：当前已经确定了$i , a_i$ ， j , $a_j$ 应该符合什么条件？尝试一个参数，容易记录。

设置 X= $a_j \oplus i$ , $Y = a_i \oplus j$ 。 假设对于同一个位，它们的上的比特分别是：
$$
a_j : A\\
i:B\\
a_i:C\\
j: D\\
$$

从X， Y高位开始考察： 假设前k位是相同的：
有：$A\oplus B=C\oplus D$ 移项得 ， $A\oplus D = B\oplus C$ 。
考察第k + 1 位（第一个不同的位）： $A\oplus B < C\oplus D$ 。总结得：

1. $A=B$
2. $C\ne D$
3. $A=B=C$ 或 $A=B=D$

4. 当$B= 1 ， C= 1$时：  $A= 1 , D = 0$
5. 当$B = 1 , C =0时:$    $A= 1  , D = 1$  
6. 当$B = 0 , C = 1$时:    $A = 0 , D = 0$
7. 当$B = 0 , C = 0$时：   $A = 0, D = 1$

总结：
$$
若B\oplus C =1 则 A\oplus D = 0\\
若B\oplus C = 0 则A\oplus D = 1\\
$$
维护用字典树$a_i \oplus i$ ，的01比特串。同时维护比特状态下的最大值即可。  

### jls's code

```cpp
#include <bits/stdc++.h>

using i64 = long long;

constexpr int N = 300000 * 31;

int cnt;
int trie[N][2];
int f[N][2];

int newNode() {
	++cnt;
	trie[cnt][0] = trie[cnt][1] = 0;
	f[cnt][0] = f[cnt][1] = 0;
	return cnt;
}
void solve() {
	int n;
	std::cin >> n;

	std::vector<int> a(n);
	for (int i = 0; i < n; i++) {
		std::cin >> a[i];
	}
	cnt = 0;
	newNode();

	std::vector<int> dp(n);
	for (int i = 0; i < n; i++) {
		int x = a[i] ^ i;
		int p = 1;
		for (int j = 29; j >= 0; j--) {
			int v = x >> j & 1;
               // 为什么向f[trie[p][!p]][i >> j & 1] 转移？
               //  这个也是一一对应的。
               // 即使是异或和下也对应了两种状态。表示A的取值。而发现，一一对应项A和B是相等的
               //                                         i >> j & 1 对应B
 			dp[i] = std::max(dp[i], f[trie[p][!v]][i >> j & 1]);
			p = trie[p][v];
			if (!p) {
				break;
			}
		}
		dp[i]++;
		p = 1;
		for (int j = 29; j >= 0; j--) {
			int v = x >> j & 1;
			if (!trie[p][v]) {
				trie[p][v] = newNode();
			}
			p = trie[p][v];
            	// a[i] >> j 对应A
			int &res = f[p][a[i] >> j & 1];
			res = std::max(res, dp[i]);
		}
	}
	int ans = *std::max_element(dp.begin(), dp.end());
	std::cout << ans << "\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;

	while (t--) {
		solve();
	}
	return 0;
}
```



### 生长：

1. 怎么使用字典树？

   关注jls的几个主要操作：

   1. 初始化：

      ```cpp
      cnt = 0;
      newNode();
      ```

   2. 查询：

      ```cpp
      int p = 1;
      for (int j = 29; j >= 0; j--) {
          int v = x >> j & 1;
          // 为什么向f[trie[p][!p]][i >> j & 1] 转移？
          //  这个也是一一对应的。
          // 即使是异或和下也对应了两种状态。表示A的取值。而发现，一一对应项A和B是相等的
          //                                         i >> j & 1 对应B
          dp[i] = std::max(dp[i], f[trie[p][!v]][i >> j & 1]);
          p = trie[p][v];
          if (!p) {
              break;
          }
      }
      ```

   3. 插入

      ```cpp
      p = 1;
      for (int j = 29; j >= 0; j--) {
          int v = x >> j & 1;
          if (!trie[p][v]) {
              trie[p][v] = newNode();
          }
          p = trie[p][v];
          // a[i] >> j 对应A
          int &res = f[p][a[i] >> j & 1];
          res = std::max(res, dp[i]);
      }
      ```

   4. 建立新节点：以及基本结构

      ```cpp
      int cnt;
      int trie[N][2];
      int f[N][2];
      
      int newNode() {
      	++cnt;
      	trie[cnt][0] = trie[cnt][1] = 0;
            // 维护的信息。
      	f[cnt][0] = f[cnt][1] = 0;
      	return cnt;
      }
      ```

   5. 封装成一个板子：

      详细看字典树笔记： [字典树.md](..\..\..\..\..\Logrithm\string\字典树\字典树.md) 



# Different Arrays

https://codeforces.com/problemset/problem/1783/D

## 题面翻译

给你一个有 $n$ 个元素的序列，你需要进行 $n-2$ 次操作。

对于第 $i$ 次操作，你可以选择让 $a_i-a_{i+1}$ 且 $a_{i+2}+a_{i+1}$ 或者可以选择让 $a_i+a_{i+1}$ 且 $a_{i+2}-a_{i+1}$

问最后能产生多少个不同的序列。

## 题目描述

You are given an array $ a $ consisting of $ n $ integers.

You have to perform the sequence of $ n-2 $ operations on this array:

- during the first operation, you either add $ a_2 $ to $ a_1 $ and subtract $ a_2 $ from $ a_3 $ , or add $ a_2 $ to $ a_3 $ and subtract $ a_2 $ from $ a_1 $ ;
- during the second operation, you either add $ a_3 $ to $ a_2 $ and subtract $ a_3 $ from $ a_4 $ , or add $ a_3 $ to $ a_4 $ and subtract $ a_3 $ from $ a_2 $ ;
- ...
- during the last operation, you either add $ a_{n-1} $ to $ a_{n-2} $ and subtract $ a_{n-1} $ from $ a_n $ , or add $ a_{n-1} $ to $ a_n $ and subtract $ a_{n-1} $ from $ a_{n-2} $ .

So, during the $ i $ -th operation, you add the value of $ a_{i+1} $ to one of its neighbors, and subtract it from the other neighbor.

For example, if you have the array $ [1, 2, 3, 4, 5] $ , one of the possible sequences of operations is:

- subtract $ 2 $ from $ a_3 $ and add it to $ a_1 $ , so the array becomes $ [3, 2, 1, 4, 5] $ ;
- subtract $ 1 $ from $ a_2 $ and add it to $ a_4 $ , so the array becomes $ [3, 1, 1, 5, 5] $ ;
- subtract $ 5 $ from $ a_3 $ and add it to $ a_5 $ , so the array becomes $ [3, 1, -4, 5, 10] $ .

So, the resulting array is $ [3, 1, -4, 5, 10] $ .

An array is reachable if it can be obtained by performing the aforementioned sequence of operations on $ a $ . You have to calculate the number of reachable arrays, and print it modulo $ 998244353 $ .

### solve

考虑按照题目中要求的过程模拟一遍： 发现如果模拟到一个阶段时候，在前缀必然不同的前提下，如果当前$a_{i + 1}$为0。 那么其两种方案下的前缀都是相同的，这对后续状态的贡献分布乘法的贡献只有一次。如果不为0，那么有两种转移。

**状态定义：**
$f_{i , j}$ 表示当前考虑第i位，且当前第i位为j时的不同的前缀数目。
**状态转移方程：**
枚举+- 或者 -+两种方式：

1. j 等于0 -> 只对后续得状态贡献一次。$f_{i + 1 , a_{i + 1} + j} \quad += f_{i , j}$

2. j 不等于0 -> 两种方案，都可以得到唯一前缀。 
   $$
   f_{i + 1, a_{i + 1} + j} \quad += f_{i , j}\\
   f_{i + 1 , a_{i + 1} - j} \quad += f_{i , j}\\
   $$

#### 实现细节：

1. 确定范围：
   每一个数只能加减n -  2 次。因此上限可以设置为： $300\times 300 $ ， 同理可以设置下限。实现的过程中小心由于转移的范围也是整个范围，加上偏移量导致越界的问题；

2. 处理负数的手段： 偏移的技巧:

   1. 比较容易理解实现的方式是：加个小转移即可。

3. 实现过程中，若要减少常数。对加减法的取mod可以优化。如下：

   ```cpp
   void update(int& x , int y) {
   	x += y;
   	while (x >= mod)
   		x -= mod;
   }
   ```

### code

```cpp
// 注意便宜。
const int N = 300 , M = N * N;
const int mod = 998244353;
int f[2 * M +  2 * N] , g[2 * M + 2 * N];
//g[M + N];
int a[N];
// 卡一点点常数的方法。
void update(int& x , int y) {
	x += y;
	while (x >= mod)
		x -= mod;
}
// 出现了许多麻烦：
// 1. 转移方程中的偏移不大习惯。
// 2. 转移方程不够明确。 边界条件没有处理好。
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	f[a[2] + M] = 1;
	// 往后贡献的形式
	for (int i = 2; i < n; i++) {
		// 枚举转移的问题
		// 下界是什么？
		// 刷表法之一
		for (int j = 0; j <= 2 * M; j++) {
			g[j] = f[j];
			f[j] = 0;
		}
		for (int j = -M + a[i + 1]; j <= M - a[i + 1]; j++) {
			if (j == 0) {
				update(f[j + a[i + 1] + M] , g[j + M]);
			} else {
				update(f[j + a[i + 1] + M] , g[j + M]);
				update(f[j - a[i + 1] + M] , g[j + M]);
			}
		}
	}
	int ans = 0;
	for (int i = 0; i <= 2 * M; i++) {
		update(ans , f[i]);
	}
	cout << ans << "\n";
}
```



# A2. Burenka and Traditions (hard version)

https://codeforces.com/contest/1718/problem/A2

![image-20230716152638793](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230716152638793.png)

## solve

### easy verson:

1. 一个贪心的角度： 任何一种操作都可以等效转换成一种模式： 若干个2 + 0 或者 1个 1的方式。
2. 探究解集： 发现任何方案可以转换成，从前到后依次处理每一个位置：

**状态设计：**

1. $f_{i,j } :$表示已经处理了前i位，当前第i位为j的最小代价:

**状态转移方程：**

1. 操作区间长度为1 ：$f_{i + 1 , a_{i + 1}} min( f_{i, j} ，f_{i + 1 , a_{i + 1}})$
2. 操作区间长度为2 ：$f_{i + 1 , a_{i + 1} \oplus j} = min(f_{i , j} + 1, f_{i + 1 , a_{i + 1} \oplus j})$

### code1 easy verson

```cpp
const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 5010;
const int M = 1 << 13;
int a[N];
int f[N][M + 10];
void work(int testNo) {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= M; j++) {
			f[i][j] = inf;
		}
	}
	f[1][a[1]] = 0;
	for (int i = 1; i < n; i++) {
		f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]] , f[i][0]);
		for (int j = 1; j <= M; j++) {
			f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]] , f[i][j] + 1);
			f[i + 1][a[i + 1] ^ j] = min(f[i + 1][a[i + 1] ^ j] , f[i][j] + 1);
		}
	}
	int ans = f[n][0];
	for (int i = 1; i <= M; i++) {
		ans = min(ans , f[n][i] + 1);
	}
	cout << ans << "\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```


### hard verson

具体分析解集： 

1. x不是任意选。任何一个阶段，都是前面一大段的异或和。
2. 与普通的n个处理相比什么时候才有效果？
   1. 当某一个操作选择长度为2的区间，使得$a_{i + 1}$ 为0。就是优越的操作。
   2. 于是问题最多不相交的异或和为0的异或段。
3. 上述问题的解：
   1. 贪心，如果发现当前枚举的尾下 就立刻选：
   2. 其实就是一个非常经典的贪心问题。选取最早结束的线段。使得得到的不相交线段数最大。


### code2  hard verson

```cpp
int a[N];
void work(int testNo) {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	set<int> rec;
	int pre = 0;
	int ans = n;
	rec.insert(0);
	for (int i = 1;  i <= n; i++) {
		pre ^= a[i];
		if (rec.count(pre)) {
			rec.clear();
			pre = 0;
			ans--;
		}
		rec.insert(pre);
	}
	cout << ans << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

----

# M. Moving Both Hands

https://codeforces.com/contest/1725/problem/M

两只手，分别在点1和p。 两只手在有向图上独立的移动，问这两只手相遇的最短时间。



### solve

有两个解法：

1. 分层图
2. 一些建图技巧。



#### 分层图：

参考博客：[分层图总结_best_brain的博客-CSDN博客](https://blog.csdn.net/x052xiao/article/details/125957769)
相似思想：[P4568 [JLOI2011\] 飞行路线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4568)

建立分层图：一旦选择到第二层后，只能走反边：（并且是不能回到第一层。）

1. 于是在上述图中的路径，全部满足： 先走正向边，或者一转全部走反边。

然后在上述图走一遍最短路即可。

#### 建图技巧的解法：

先跑完所有能直接到达的点。然后在这些点的基础上，建立一个反图 , 具体如下:

1. 跑出最短路之后： 得到$d$最短路数组：
   1. 对于能够到达的点，就使用上述替代，给1和这些点建立一条边。
   2. 正向便前部忽略。建立反向边。
2. 然后在上述图中跑最短路即可。

### code

```cpp
const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = (int)2E5 + 10;

vector<pair<int , int>> e[N];
ll d[N];
bool done[N];

struct node {
	int u;
	ll d;
	bool operator <(const node& t)const {
		return d > t.d;
	}
};
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m ;
	cin >> n >> m;
	fill(d , d + 2 * n + 1, INF);
	for (int i = 1; i <= n; i++) {
		e[i].push_back({i + n , 0});
	}
	for (int i = 0; i < m; i++) {
		int u , v , w;
		cin >> u >> v >> w;
		e[u].push_back({v , w});
		e[v + n].push_back({u + n , w});
	}

	priority_queue<node> que;
	fill(done , done + 2 * n + 1 , false);
	d[1] = 0;
	que.push({1 , 0});
	while (not que.empty()) {
		int u = que.top().u; que.pop();
		if (done[u]) continue;
		done[u] = true;
		for (auto [v , w] : e[u]) {
			if (d[v] > d[u] + w) {
				d[v] = d[u] + w;
				que.push({v , d[v]});
			}
		}
	}
	for (int i  = 2; i <= n; i++) {
		if (d[i + n] == INF) cout << -1;
		else cout << d[i + n];
		cout << " \n"[i == n];
	}
}
```

----

## 字符串哈希板子：

```cpp
#define mp make_pair
typedef pair<int, int> hashv;
const ll mod1 = 1e9 + 7;
const ll mod2 = 1e9 + 9;

hashv operator + (hashv a, hashv b) {
    int c1 = a.fi + b.fi,c2 = a.se + b.se;
    if (c1 >= mod1) c1 -= mod1;
    if (c2 >= mod2) c2 -= mod2;
    return mp(c1, c2);
}

hashv operator - (hashv a, hashv b) {
    int c1 = a.fi - b.fi,c2 = a.se - b.se;
    if (c1 < 0) c1 += mod1;
    if (c2 < 0) c2 += mod2;
    return mp(c1, c2);
}
hashv operator * (hashv a, hashv b) {
    return mp(1ll * a.fi * b.fi % mod1, 1ll * a.se * b.se % mod2);
}
```

---

# F-Kevin的矩阵_牛客小白月赛76

[F-Kevin的矩阵_牛客小白月赛76 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/60393/F)

链接：https://ac.nowcoder.com/acm/contest/60393/F
来源：牛客网

*氧气少年*现在有一个长度为 n 的序列 a 和一个空的矩阵，矩阵的行数不限，但列数为 m。

 每次操作他可以从下面的操作中任选其一：



- ​		 任选序列的某个位置，将此位置的数字修改为任意的数字； 
- ​		 将矩阵的列数增加 1； 
- ​		 将矩阵的列数减小 1（如果当前矩阵的列数大于 1）。 


 操作完成后，*氧气少年*将序列中的每个元素依次按照从上到下、从左到右的顺序填到矩阵中。（即：先填第 1 行第 1 列，再填第 1 行第 2 列，…… 填第 1行第 m 列，填第 2行第 1 列，填第 2 行第 2 列，…… 填第 2行第 m 列，以此类推。）



​	*氧气少年*想要让矩阵至少一列的所有数字均为目标数字 k，请求出他需要做的最少的操作次数



### solve

1. m 小于 $\sqrt n$ ,其变化列数的操作花费 最多为$\sqrt n$ , 

2. m 大于等于 $\sqrt n$ 其直接处理其中某一列，其花费做多为$\sqrt n$

综上至多使用$2\sqrt n$ 的花费就可以得到目标解。因此一一枚举即可：

### code

```cpp
const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
int f(int x) {
	int sq = sqrt(x);
	while (sq * sq < x) sq++;
	return sq;
}
int a[N];
void work(int testNo)
{
	int n ,  m , k;
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	int sq = f(n);
	int ans = inf;
	for (int i = -2 * sq; i <= 2 * sq; i++) {
		int temp = m + i;
		if (temp <= 0) continue;
		// 检查当前的情况 ： 是否。
		for (int j = 0; j < min(n , temp); j++) {
			int res = 0;
			for (int s = j; s < n; s += temp) {
				res += a[s] != k;
			}
			ans = min(ans , res + abs(i));
		}
	}
	cout << ans << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

----

# **D - Peaceful Teams**

https://atcoder.jp/contests/abc310/tasks/abc310_d

现在有N个人，组成T个队伍。但是一些人之间会互相讨厌。问一个有多少队伍的划分方式？

特殊的数据范围是;
$$
1\le T \le N \le 10\\
0 \le M \le \frac{N(N-1)} {2}\\
1 \le A_i \lt B_i \le N (1\le i \le M)
$$


##  solve

由于N大小只有10，只要搜出来的都是答案，那么就复杂度是够的；

**关于搜索的一些技巧：**

1. 保证顺序无关的方法；枚举某个人时，尽量只将其与前已经构成的队伍一组，或者自己新作为一个队伍。发现构造出来的方案都是不同的，并且考虑了所有可能，因此该方式的搜索出来的解空间，就是目标解空间。
2. 利用位运算等方法，对常数做一个优化。



**奇怪的问题：**

为什么将teams.reserve()这个语句删除之后 ， 程序的运行结果就会出错？发现跑几遍代码之后，连程序运行的结果都不同：



```cpp
unsigned dfs(int cur , vector<unsigned>& teams) {
	if (cur == n)
		return (int)teams.size() == t;
	unsigned ans = 0;

	for (auto & team : teams) {
		//先检查是否符合条件：
		if ((team & limit[cur]) == 0) {
			team |= 1U << cur;
			ans += dfs(cur + 1, teams);
			team ^= 1U << cur;
		}
	}
	if (teams.size() < t) {
		unsigned team = 1U << cur;
		teams.push_back(team);
		ans += dfs(cur + 1 , teams);
		teams.pop_back();
	}
	return ans;
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> t >> m;
	for (int i = 0; i < m; i++) {
		int u , v;
		cin >> u >> v;
		u-- , v--;
		limit[v] |= 1U << u;
	}
	vector<unsigned> teams;
	teams.reserve(t);
	cout << dfs(0 , teams) << "\n";
}
```



```cpp
#include <iostream>
#include <vector>

int main() {
    using namespace std;
    unsigned N, T, M;
    cin >> N >> T >> M;

    // j-th bit of hate[i] is 1 ⟹ i-th and j-th players are incompatible (0-indexed)
    vector<unsigned> hate(N);
    for (unsigned i{}, a, b; i < M; ++i) {
        cin >> a >> b;
        hate[--b] |= 1U << --a;
    }

    // Print the result of the recursive function
    cout << [dfs{ [N, T, &hate](auto&& f, vector<unsigned>& teams, unsigned now) -> unsigned {
        // OK if there are T teams so far when all the N players are inspected
        if (now == N)
        return size(teams) == T;

        unsigned ans{};

        // Add the now-th player to an existing team
        for (auto&& team : teams)
            // If nobody in the team is incompatible with the now-th
            if (!(team & hate[now])) {
                team ^= 1U << now;
                ans += f(f, teams, now + 1);
                team ^= 1U << now;
            }

        // If new team can be made, make a new one
        if (size(teams) < T) {
            teams.emplace_back(1U << now);
            ans += f(f, teams, now + 1);
            teams.pop_back();
        }

        return ans;
    } }, T] {
        vector<unsigned> team;
        team.reserve(T);
        return dfs(dfs, team, 0);
    }() << endl;

    return 0;
}
```



# HNOI2009, 梦幻布丁

[HNOI2009, 梦幻布丁 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/15/problem/816)

n个布丁摆成一行，进行m次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。
例如颜色分别为1,2,2,1的四个布丁一共有3段颜色。



## solve

维护各种布丁的集合： 合并的过程中，使用启发式合并的思想，合并小的布丁集合到大的布丁集合。

关键：

1. 合并集合：

   1. 看上去布丁颜色转变是单向的。选择更小的集合并入更大集合的操作是否可行？

      ：： 无论是哪个方向上的并入，最终布丁的颜色整体颜色结构不变。

      数组a上标记和颜色的标号一直保持1对1映射。这意味着：

      1. x ， y合并时，用 tag[x] 和用tag[y] 的最终效果是一样的。即可以使用启发式合并的方法。

2. 维护段数的方法：

   1. pre，颜色改变前的段数。
   2. 颜色改变：怎么维护颜色数目的变化？

   如下代码： 是一个trick。类似扫描的思想，维护块的变化。

## code

```cpp
int a[N];
vector<int> pos[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pos[a[i]].push_back(i);
	}
	int ans = 0;
	for (int i = 1; i <= n + 1; i++) {
		ans += a[i] != a[i - 1];
	}
	for (int i = 0; i < m; i++) {
		int op; cin >> op;
		if (op == 2) {
			cout << ans - 1 << "\n";
		} else {
			int x, y;
			cin >> x >> y;
			if (pos[x].size() > pos[y].size())
				pos[x].swap(pos[y]);
			if (x == y || pos[y].empty()) continue;

			int col = a[pos[y][0]];
			for (auto p : pos[x]) {
				// 怎么处理出这种段的变化？
				ans -= (a[p] != a[p - 1]) + (a[p] != a[p + 1]);
				a[p] = col;
				ans += (a[p] != a[p - 1]) + (a[p] != a[p + 1]);
				pos[y].push_back(p);
			}
			pos[x].clear();
		}
	}
}
```



# 启发式合并

### 问题背景：

启发式合并是解决集合合并问题的算法：
所谓启发式算法，是基于人类的经验和直觉，对一些算法的优化。

1. 维护集合的算法一般使用并查集实现，

   1. 某些问题中，要求，合并后每节点的标记直接指向其集合的祖先标记。
   2. 一般的并查集合算法是无法实现的。因为只处理了集合老大的标记指向。

2. 问题的一般模型是：

   1. 给定n个集合以及标记函数fa（）。
      1. fa（$a_{ik}$）= $tag_i$ 
   2. 在这些集合上进行一些特殊的合并操作：
      1. 要求合并i , j 操作到 i 之后，其j中的$tag_j$标记严格修改成$tag_i$

   ### 解决方法探究：

   1. 朴素的合并：
      1. 操作的复杂度是： $O(n^2)$
   2. 直觉上，将小的集合合并到大的集合中去 , 比大集合合并到小集合更优。这种合并操作就是**启发式合并**

   ### 启发式合并的复杂度分析：

   1. 结论上，复杂度为： $O(nlog(n))$

      #### 证明过程如下：

      1. 关注角度是每一个元素的贡献。
      2. 考虑每次从小往大合并：
      3. 关注过程中的变化：
         1. 一个小集合并入大集合，那么关注小集合至多变大两倍，这意味着该集合中的元素至多作为小集合合并logn次。所以总体上的时间复杂度是$O(nlogn)$

# 路径最小值（启发式合并解法）

### 问题形式：

给一个n节点的树，每条边上有边权，给定q个询问u ， v 每次询问u  ， v上的最小值。

### solve

1. 首先是一个高明的贪心思路： 类似（krukals）算法：

   将边排序后，考虑慢慢的往考察访问一些边：维护已经得到的一系列的点集：

2. 当考察一条边之后： 对这些点集进行一个合并操作：

   1. 一些要求： 不能像普通的并查集一样进行一个简单的祖宗的合并。为了具体面向询问，必须具体的枚举到集合中涉及的所有问题。如果只是用简单的并查集，是不能自上而下精确定位到每一个集合中的元素的。必须对树所有点检查一遍祖宗。
   2. 采取启发式合并配合普通并查集的方法：
      1. 启发式合并： 通过枚举小的集合的点对应的询问，使得所有相关的询问被检索完，并且根据启发式合并的复杂度分析结果，每个查询问题，最多被访问log n复杂度次： 由于其访问当且仅当其端点被访问，合起来最多访问$2\times log(n)$遍。
      2. 并查集，可以快速从元素到集合标记的查询。启发式合并解决了，更细节的，从标记到元素的信息的维护与查询。

### code

```cpp
vector<array<int , 3>> edge;
// 维护集合中的询问。
vector<array<int , 2>> que[N];
int ans[N] , belong[N];
vector<int> vec[N];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , q;
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int u , v , w;
		cin >> u >> v >> w;
		edge.push_back({w , u , v});
	}
	for (int i = 1; i <= n; i++) {
		vec[i].push_back(i);
		belong[i] = i;
	}

	sort(edge.begin() , edge.end() , greater<array<int , 3>> ());
	// 然后维护集合以及询问。
	for (int i = 0; i < q; i++) {
		int u , v;
		cin >> u >> v;
		que[u].push_back({i , v});
		que[v].push_back({i , u});
	}
	for (auto[w , u , v] : edge) {
		// 然后对两个集合进行询问合并。
		// 确定到两个父亲节点。
		u = belong[u]; v = belong[v];
		if (vec[u].size() > vec[v].size()) swap(u , v);
		// 然后进行合并。
		// 首先基于询问进行一次合并。
		for (auto [id , to] : que[u]) {
			if (ans[id] != 0) continue;
			if (belong[to] == v) {
				ans[id] = w;
			} else {
				que[v].push_back({id , to});
			}
		}
		for (auto w : vec[u]) {
			vec[v].push_back(w);
			belong[w] = v;
		}
		que[u].clear();
		vec[u].clear();
	}
	for (int i = 0; i < q; i++) {
		cout << ans[i] << "\n";
	}
}
```



----

这里只能称为启发式算法，而不是启发式合并。

# 好序列

一个序列被称为好序列的条件是，所有子区间都至少一个元素只出现了一次。给出一个序列，判断是否为启发好序列。

## solve

观察一些现象：

1. 首先关注一个序列中只出现了一次的元素。那么包含这个元素的区间都满足条件，于是只需要考虑其它的子区间。这样就可以将序列分成两个，继续进行check.
   1. 出现的问题：可能和快速排序一样，由于分的不均匀导致了总体的复杂度比较高。
2. 启发式的处理方法：
   1. 中间的唯一元素： 不需要比较快的找到该元素。
   2. 靠边的唯一元素， 花费比较小的代价去寻找。
   3. 这样用两种不同的方法寻找唯一元素，总的复杂度是$O(nlogn)$

**处理细节**

1. 找出唯一一次出现元素的方法：

   1. 指针记录相等元素上一次出现的位置，以及下一次出现的位置。（比较常见的一个结构。走投无路叠一些数据结构来处理的时候。可以考虑选择该数据结构。）

2. 启发式分治的实现：

   不单纯的从头到尾寻找中间元素（当前序列中只出现了一次的元素。）

   从两端一起for。下面有两种情况：

   1. 两端的元素比较快的就能找到这个元素。
   2. 寻找中间的元素对总的贡献的复杂度是接近$O(nlog n)$的。

   于是总体的复杂度是：

   $T(n) = T(x) + T(n - x) + O(min(x , n-x))$

   分析得： $T(n) = O(n\times log(n))$

   这个复杂度的证明方法： ？？



## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define fsio ios::sync_with_stdio(false);cin.tie(0);
const int N = (int)1E6 + 10;
const int inf = (int)1E9 + 10;
const ll INF = (long long)1E18 + 10;
int a[N] , pre[N] , suf[N];
bool solve(int l , int r) {
	if (l >= r) return true;
	for (int pl = l , pr = r; pl <= pr; pl++ , pr--) {
		if (pre[pl] < l && suf[pl] > r) {
			return solve(l , pl - 1) && solve(pl + 1, r);
		}
		if (pre[pr] < l && suf[pr] > r) {
			return solve(l , pr - 1) && solve(pr + 1 , r);
		}
	}
	return false;
}
bool solve() {
	int n;
	cin >> n;
	map<int , int> rec;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pre[i] = rec[a[i]];
		rec[a[i]] = i;
	}
	rec.clear();
	for (int i = n; i >= 1; i--) {
		if (rec[a[i]] == 0) {
			suf[i] = n + 1;
			rec[a[i]] = i;
		} else {
			suf[i] = rec[a[i]];
			rec[a[i]] = i;
		}
	}
	return solve(1 , n);
}
int main() {
	fsio
	int t; cin >> t;
	while (t--) {
		if (solve()) cout << "non-boring\n";
		else cout  << "boring\n";
	}
}
```

----

# DSU on tree



## 基础问题

给定一颗树，维护一些子树的信息：

1. 例如，给定一颗树，检查子树有多少种颜色。

   ps:这个问题，可以通过莫队，dfn 序， 扫描线处理。

## 基本思想

将子树信息进行合并： 本质上就是启发式合并。
DSU on tree 是和树结构相关的合并问题中，时间，空间复杂度更加优秀的方法。

==**其一般操作为**==

1. 对每一个点找到最大的儿子（重儿子：节点数最多）。将轻儿子并入重儿子中。
2. 启发想法递进：
   1. u节点集合，直接从重儿子中继承过来。再将轻儿子并入：
   2. 合并轻儿子时，对轻儿子的每一个元素进行访问。不需要维护轻儿子集合中的信息。
      1. 使用dfs序来优化常数。
   3. 整个过程中，只维护一个集合：

### 算法效率分析：

1. 时间复杂度： $O(log(n))$
2. 空间复杂度： $O(log(n))$

## 封装成板：（算法步骤）

1. dfs1（） 

   1. 将重儿子亲儿子等子树信息求出。
   2. 给树求dfs序，优化常数。

2. dfs2 ， 就是进行dsu on tree

   void dfs(int u , int fa, bool keep)

   **主要过程：**

   1. 将（轻儿子）v子树中的所有节点加到重儿子的集合里。 
      1. 这里的可以通过深搜实现，也可以通过dfs序实现。
   2. 然后将u本身加入重儿子的集合中。
   3. keep的意义： 需不需要保留当前信息。对于重儿子需要保留信息，轻儿子不需要保留信息。也就是将轻儿子合并之后，需要对轻儿子的信息进行一些合并操作。



```cpp
const int N = (int)1E6 + 10;

int l[N] , r[N] , id[N] , sz[N] , hs[N] , tot;
// int cnt[N]; //每个颜色出现的次数。
// int mxcnt; // 众数出现的次数。
// ll sumcnt , ans[N];;// 总数颜色编号的和。
/*维护信息集合*/
vector<int> e[N];
void dfs_init(int u , int fa) {
	l[u] = ++ tot;
	id[tot] = u;
	sz[u] = 1;
	hs[u] = -1;
	for (auto v : e[u]) {
		if (v == fa) continue;
		dfs_init(v , u);
		sz[u] += sz[v];
		if (hs[u] == -1 || sz[v] > sz[hs[u]])
			hs[u] = v;
	}
	r[u] = tot;
}
void dfs_solve(int u , int fa , bool keep) {
	for (auto v : e[u]) {
		if (v != fa && v != hs[u]) {
			dfs_solve(v , u , false);
		}
	}
	if (hs[u] != - 1) {
		dfs_solve(hs[u] , u , true);
		// 重儿子集合
	}
	/*主要需要修改的东西： 就是以下这两个函数add() 和 del()*/
	auto add = [&](int x) {
	};
	auto del = [&](int x) {

	};
	for (auto v : e[u]) {
		if (v != fa && v != hs[u]) {
			for (int x = l[v]; x <= r[v]; x++)
				add(id[x]);
		}
	}
	// u本身加入。
	add(u);
	ans[u] = sumcnt;
	if (!keep) {
		mxcnt = 0;
		sumcnt = 0;
		for (int x = l[u]; x <= r[u]; x++) {
			del(id[x]);
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	dfs_init(1 , 0);
	dfs_solve(1 , 0 , false);
}
```



----

# E. Lomsat gelral

https://codeforces.com/problemset/problem/600/E

- 有一棵  $n$ 个结点的以  $1$ 号结点为根的**有根树**。
- 每个结点都有一个颜色，颜色是以编号表示的， $i$ 号结点的颜色编号为  $c_i$。
- 如果一种颜色在以  $x$ 为根的子树内出现次数最多，称其在以  $x$ 为根的子树中占**主导地位**。显然，同一子树中可能有多种颜色占主导地位。
- 你的任务是对于每一个  $i\in[1,n]$，求出以  $i$ 为根的子树中，占主导地位的颜色的编号和。
- $n\le 10^5,c_i\le n$

### solve

运用书上启发式合并的思想

1. 对小子树求解后进行合并求更大子树的解：

**集中精力解决的问题：**

1. 维护内容设计：
   1. 面向某个节点时，每个颜色出现的次数。
   2. 众数出现的次数。
   3. 总颜色编号的和，以及答案。

2. add函数的设计。
   1. add， 首先调用与重儿子相关的函数。

   2. 某个阶段下， 只需要关注

3. del函数的设计。
   1. del函数设计是因为，一整块存储结构要只被重儿子使用。如果当前探索的节点并非是其父亲的重度儿子。那么就应该把它及时清空。
   1. 由贡献源到记录的清空，而不是全局的清空。

**复杂度分析：**

1. 单看一个点被朴素的add的访问次数。
2. 作为一个轻儿子，和启发式合并一样，最多被成为logn个轻儿子的节点。
3. 因此总的复杂度是log n次。

### 生长思考：

1. 和树形dp的对比：
   1. 和树形dp相比 ，这并非是策略的最优性问题，而是对这颗子树的结构的探究，对某些属性以及关注函数的计算。
   2. 这里的合并是朴素的，因为子树的结构上的属性信息更大的树的内容之一。关于
2. 如何启发自己？
   1. 方向就是关注问题中的内容：问题中的内容：是否是子树的一些结构信息，以及子树信息是否可以合并成为更大子树de


### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1E5 + 10;
int c[N];
int l[N] , r[N] , id[N] , sz[N] , hs[N] , tot;
int cnt[N]; //每个颜色出现的次数。
int mxcnt; // 众数出现的次数。
ll sumcnt , ans[N];;// 总数颜色编号的和。
vector<int> e[N];
void dfs_init(int u , int fa) {
	l[u] = ++ tot;
	id[tot] = u;
	sz[u] = 1;
	hs[u] = -1;
	for (auto v : e[u]) {
		if (v == fa) continue;
		dfs_init(v , u);
		sz[u] += sz[v];
		if (hs[u] == -1 || sz[v] > sz[hs[u]])
			hs[u] = v;
	}
	r[u] = tot;
}
void dfs_solve(int u , int fa , bool keep) {
	for (auto v : e[u]) {
		if (v != fa && v != hs[u]) {
			dfs_solve(v , u , false);
		}
	}
	if (hs[u] != - 1) {
		dfs_solve(hs[u] , u , true);
		// 重儿子集合
	}
	auto add = [&](int x) {
		x = c[x];
		cnt[x]++;
		if (cnt[x] > mxcnt) mxcnt = cnt[x] , sumcnt = 0;
		if (cnt[x] == mxcnt) sumcnt += x;

	};
	auto del = [&](int x) {
		x = c[x];
		cnt[x] --;
	};
	for (auto v : e[u]) {
		if (v != fa && v != hs[u]) {
			for (int x = l[v]; x <= r[v]; x++)
				add(id[x]);
		}
	}
	// u本身加入。
	add(u);
	ans[u] = sumcnt;
	if (!keep) {
		mxcnt = 0;
		sumcnt = 0;
		for (int x = l[u]; x <= r[u]; x++) {
			del(id[x]);
		}
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
	}
	for (int i = 1; i < n; i++) {
		int u , v; cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs_init(1 , 0);
	dfs_solve(1 , 0 , false);
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << " \n"[i == n];
	}
}
```



# [IOI2011] Race

[P4149 [IOI2011\] Race - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4149)

给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。

### solve

启发式合并的解法：

1. 树上枚举路径的一种顺序可以为：

   1. 枚举一个节点： 然后通过两个子树情况的组合来枚举路径。

2. 维护信息内容：

   1. 维护当前维护的树的某权值下的最大深度。

   2. 每次在合并子树前，枚举当前是否有可行解：
      $$
      d2 = k  +  2 * dep2[u] - dep2[w];
      $$
      d2 就是在当前数据集维护的一大块子树中，查找一些权值的最小路径。

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 101000;

int n, k;
vector<pair<int, int>> e[N];
int l[N], r[N], id[N], sz[N], hs[N], tot, c[N];
int dep1[N];
ll dep2[N];
int ans;
map<ll, int> val;

void dfs_init(int u, int f) {
	l[u] = ++tot;
	id[tot] = u;
	sz[u] = 1;
	hs[u] = -1;
	for (auto [v, w] : e[u]) {
		if (v == f) continue;
		dep1[v] = dep1[u] + 1;
		dep2[v] = dep2[u] + w;
		dfs_init(v, u);
		sz[u] += sz[v];
		if (hs[u] == -1 || sz[v] > sz[hs[u]])
			hs[u] = v;
	}
	r[u] = tot;
}

void dfs_solve(int u, int f, bool keep) {
	for (auto [v, w] : e[u]) {
		if (v != f && v != hs[u]) {
			dfs_solve(v, u, false);
		}
	}
	if (hs[u] != -1) {
		dfs_solve(hs[u], u, true);
	}
	auto query = [&](int w) {
		ll d2 = k  +  2 * dep2[u] - dep2[w];
		if (val.count(d2)) {
			ans = min(ans, val[d2] + dep1[w] - 2 * dep1[u]);
		}
	};
	auto add = [&](int w) {
		if (val.count(dep2[w]))
			val[dep2[w]] = min(val[dep2[w]], dep1[w]);
		else
			val[dep2[w]] = dep1[w];
	};

	for (auto [v, w] : e[u]) {
		if (v != f && v != hs[u]) {
			for (int x = l[v]; x <= r[v]; x++)
				query(id[x]);
			for (int x = l[v]; x <= r[v]; x++)
				add(id[x]);
		}
	}
	query(u); add(u);
	if (!keep) {
		val.clear();
	}
}

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		++u; ++v;
		e[u].push_back({v, w});
		e[v].push_back({u, w});
	}
	ans = n + 1;
	dfs_init(1, 0);
	dfs_solve(1, 0, false);
	if (ans >= n + 1) ans = -1;
	printf("%d\n", ans);
}
```

----

# **dfs序**

**概念：**

1. 对树节点打一个序标记： 其中该序和dfs的顺序有关。遇到就打一个未分配标记：
2. 使用L ， R数组 记录其子节点访问节点的序范围。

在上述记录结构下，就可以实现一些灵活自由的操作。

## 例题：

### DFS序练习1

给一棵n个点的树，每个点有点权$w_i$，1号点为根。给q个操作：

1. `1 x y`，将x点的点权改成y。
2. `2 x`，询问x点子树的点权和，到根的路径的点权和（都包含x这个点）。

#### solve

1. 关键想法， 使用dfs序，将子树上的维护问题转换成，数组的段信息的维护问题。
2. 整出dfs序数组后。使用两个树状数组维护以下信息。
   1. $d_1:$ 朴素用法维护权的前缀和。然后可以轻松解决第一个问题。x点子树的点权和就是到L[x] , R[x]的段和。
   2. $d_2: $ 维护差分数组 ， 前缀和就是x节点到根节点的路径和。那么当修改一个点权时，只有其子树内的点受到影响。于是对这一段做区间L[x] , R[x]加减即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define fsio ios::sync_with_stdio(false);cin.tie(0);
#define int ll

const int N = (int)1E6 + 10;
const int inf = (int)1E9 + 10;
const ll INF = (long long)1E18 + 10;
int n , q;
class BIT {
public:
	ll c[(int)1E6 + 10];
	ll query(int x) {
		ll res = 0;
		for (; x ; x -= x & (-x))
			res += c[x];
		return res;
	}
	void modify(int x, ll d) {
		assert(x != 0);
		for (; x <= n; x += x & (-x)) {
			c[x] += d;
		}
	}
	int bineray_serach(ll x) {
		int pos = 0;
		ll  t = 0;
		//18对应5e5
		//19对应1e6
		for (int i = 18; i >= 0; i--) {
			//t的水平一直是小于等于x的关系。
			if (pos + (1 << i) <= n && t + c[pos + (1 << i)] <= x) {
				pos += (1 << i);
				t += c[pos];
			}
		}
		//dbg(pos)
		return pos;
	}
} d1 , d2;

vector<int> e[N];
ll l[N] , r[N] , tot;
ll w[N];
void dfs(int u , int fa) {
	l[u] = ++tot;
	for (auto v : e[u])
		if (v != fa) {
			dfs(v , u);
		}
	r[u] = tot;
}
signed main() {
	fsio;
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int u , v; cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1 , 0);
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
		d1.modify(l[i] , w[i]);
		d2.modify(l[i] , w[i]);
		d2.modify(r[i] + 1 , -w[i]);
	}
	// d0维护第一个问题。
	// d1 , d2 维护第二个问题；
	while (q--) {
		int ty; cin >> ty;
		if (ty == 1) {
			ll x , y; cin >> x >> y;
			ll d = y - w[x];
			w[x] = y;
			d1.modify(l[x] , d);
			d2.modify(l[x] , d);
			d2.modify(r[x] + 1 , -d);
		} else {
			int x; cin >> x;
			cout << d1.query(r[x]) - d1.query(l[x] - 1) << " " << d2.query(l[x]) << '\n';
		}
	}
}
```

-----------

### DFS序练习2

给一棵n个点的树，每个点有点权$w_i$，1号点为根。给q个操作：

1. `1 x y`，将x点的点权改成y。
2. `2 x`，询问x点子树的点权和。
3. `3 x`，将根换到x位置。

#### solve

每一次操作中，如果朴素的处理dfs序操作，那么dfs序将会变化非常大。想法是，维护之前的dsf序来完成这些操作。

当查询一个节点时： 有3种i情况： （不对dfs序做出改动，且依然用BIT维护当前序列权前缀情况下：）

1. 当前查询的节点就是根
   当前整棵树的点权和就是子树的点权和。

   

2. 根在x的子树外（这里的前提是：1作为根节点时。）

   x的子树没有发生变化：依然可以用之前的方法直接求出。


3. 根在x的子树内：（前提也是，1作为根节点。）

   找出分支直接做容斥即可。总权重减去根所在子树的权重和即可。



**所以集中的精力解决的几个问题：**

1. 判断根节点的位置。比较$L[root] ， L[x] , R[x]$即可。
2. 如果根在x的子树里头， 找出其子树和。
   1. 倍增
   2. 对dfs序二分。 
      1. 实现方式是对sons的子树范围处理。详细看代码即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2E5 + 10;

int n , q ,  w[N];
vector<int> e[N];
vector<pair<int, int>> son[N];

int l[N] , r[N] , tot;
ll c[N];
void modify(int x , ll d) {
	for (; x <= n; x += x & -x) {
		c[x] += d;
	}
}
ll query(int x) {
	ll res = 0;
	for (; x; x -= x & -x) {
		res += c[x];
	}
	return res;
}
void dfs(int u , int fa) {
	l[u] = ++tot;
	for (auto v : e[u]) {
		if (v != fa) {
			dfs(v , u);
			son[u].emplace_back(l[v] , r[v]);
		}
	}
	r[u] = tot;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> q;
	for (int i = 1; i < n; i++) {
		int u , v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1 , 0);
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
		modify(l[i] , w[i]);
	}

	int root = 1;
	while (q--) {
		int ch , x;
		cin >> ch >> x;
		if (ch == 1) {
			int y;
			cin >> y;
			modify(l[x] , y - w[x]);
			w[x] = y;
		} else if (ch == 2) {
			// 根节点的位置信息
			if (x == root) {
				cout << query(n) << "\n";
			}
			// 在里面
			else if (l[root] >= l[x] && r[root] <= r[x]) {
				auto seg = *(--upper_bound(son[x].begin() , son[x].end() , make_pair(l[root] , r[root])));
				cout << query(n) - (query(seg.second) - query(seg.first - 1)) << "\n";
			}
			// 在外面：
			else {
				cout << query(r[x]) - query(l[x] - 1) << "\n";
			}
		} else {
			root = x;
		}
	}
}
```

---

# 树链剖分：



## 原理

将子树划分成若干的链进行管理：

1. 长链剖分
   1. 找子树最深的儿子，来形成链。

### 重链剖分

剖分方法：找最重的儿子（子树节点数最多），其连边划分为重边。

性质：

1. 从一个点往上走，子树大小翻倍。即最多只经过$O(log(n))$轻边。
2. 两个点之间的路径，被$O(log(n))$ 级别的轻边分割。于是，至多有$O(log (n))$段的划分。

![image-20230716104130770](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230716104130770.png)



因此维护的信息就是，上下纵横几段重边。

1. 某个点向上如果在重链上，记录该重链的链头。

### 树链剖分例题：

#### 树链剖分求LCA

观察重链剖分后的树形结构：两点的LCA无非以下两种情形：

1. 临近LCA 的两条相关边中，两边都是轻边，或有且仅有一条重边。其启发是，两个点都暴力的往上跳。



```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = (int)1E6 + 10;
vector<int> e[N];
int n , m;
int l[N] , r[N] , id[N];
int sz[N] , hs[N] , dep[N] , fa[N] , top[N] , tot;

void dfs1(int u , int f) {
	sz[u] = 1;
	hs[u] = -1;
	dep[u] = dep[f] + 1;
	fa[u] = f;

	for (auto v : e[u]) {
		if (v == f) continue;
		dfs1(v , u);
		sz[u] += sz[v];
		// 记录重儿子。
		if (hs[u] == -1 || sz[v] > sz[hs[u]]) {
			hs[u] = v;
		}
	}
}
// dfs序以及链头的位置。
void dfs2(int u , int t) {
	top[u] = t;
	l[u] = ++tot;
	id[tot] = u;
	if (hs[u] != -1) {
		dfs2(hs[u] , t);
	}
	for (auto v : e[u]) {
		if (v != fa[u] && v != hs[u]) {
			dfs2(v , v);
		}
	}
	r[u] = tot;
}
int LCA(int u , int v) {
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) v = fa[top[v]];
		else u = fa[top[u]];
	}
	if (dep[u] < dep[v]) return u;
	else return v;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	for (int i = 1; i < n; i++) {
		int u , v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs1(1 , 0);
	dfs2(1 , 1);
	int m; cin >> m;
	for (int i = 0; i < m; i++) {
		int u , v;
		cin >> u >> v;
		cout << LCA(u , v) << "\n";
	}
}
```

































