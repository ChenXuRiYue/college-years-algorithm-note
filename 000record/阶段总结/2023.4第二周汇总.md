## 2023.4第二周

嗯，现在专心了很多。

**桃之夭夭，灼灼其华。之子于归，宜其室家。
桃之夭夭，有蕡其实。之子于归，宜其家室。
桃之夭夭，其叶蓁蓁。之子于归，宜其家人。 **



==树上问题要补。==

#### dp板刷

1.  [Jury Compromise .md](..\problems\题单\kuangbing\基础dp\Jury Compromise .md) 
1.  [Making the Grade.md](..\problems\题单\kuangbing\基础dp\Making the Grade.md)  ==×==

**codeforces**

**div3补题**

1.   [C. Restore the Array.md](..\problems\codeforces\1400-1600\解的构造\数组模型\C. Restore the Array.md)  ✔
2.   [D. Umka and a Long Flight.md](..\problems\codeforces\1400-1600\规律挖掘\斐波那契数列\D. Umka and a Long Flight.md) 
3.   [F. Is It Flower.md](..\problems\codeforces\1700\图论\环结构\F. Is It Flower.md) 
4.   [G2. Vlad and the Nice Paths (hard version).md](..\problems\codeforces\1700\动态规划\数组模型\余数\G2. Vlad and the Nice Paths (hard version).md) 

**构造**

1.  [B. Railway System.md](..\problems\codeforces\1700\构造\图构造\B. Railway System.md)  （两道非常相似 ， 都是构造和交互结合的好问题）
1.  [D. Sum Graph.md](..\problems\codeforces\1700\构造\图构造\D. Sum Graph.md) 
1.  [E. Between.md](..\problems\codeforces\2200\构造\图论模型\E. Between.md) 
1.   [D. Range = √Sum.md](..\problems\codeforces\1800\构造\算术数学\D. Range = √Sum.md) 

#### dp

1.  [F. XOR Counting.md](..\problems\codeforces\2600\dp\位运算模型\F. XOR Counting.md) 

**小白月赛补题：**

博弈论： [小d的博弈.md](..\problems\nowcoder\小白月赛\博弈论\进制角度突破\小d的博弈.md) 

#### 最短路

1.  [Frogger .md](..\problems\题单\kuangbing\最短路练习\Frogger .md) 
2.  [Heavy Transportati.md](..\problems\题单\kuangbing\最短路练习\Heavy Transportati.md) 
3.  [Currency Exchange.md](..\problems\题单\kuangbing\最短路练习\Currency Exchange.md) (判断图中， u ， u 之间是否有正环)

#### 最小生成树：

------------



**Jury Compromise**

https://vjudge.csgrandeur.cn/problem/POJ-1015#author=0258

![image-20230404154533146](image-20230404154533146.png)

### solve

初步：

**状态定义**

$f_{i , j ,k}$：i  , j分别表示两种分数之和 , 已经选择了k个陪审员的情况是否存在。

**转移方程**

利用滚动数组优化：从后往前，转移。

$f_{i , j , k}为ture$ ，且更大规模的状态没有更新 ， 则更新更大规模的状态。（只记录首次发现符合解的状态。最大限度节省空间。）、

**初始化**

$f_{0 , 0 , 0} = true$

时间复杂度$O(n\times m\times 400 * 400 * q)$

1E8 --- 1E9

--------

==正解：==

**状态设计：**

$f_{i , j , k}$  ： 表示考虑前i个 ， 两种的和的差值为j ， 选择了k个物品的最大和。

滚动数组优化成$f_{i , j}$

**转移方程：**
如果用滚动数组优化就从后往前推。

**时间复杂度：**
$O(n*m*800)$
注意将：插值可能为负数， 所以要对使用移码。 	

#### 困难

关于滚动优化的细节：

1. 逆推可以保证解的正确性。
2. 路径还原的方案：
   1. `path[n][m][k]`
   2. 开一个`vector<int>数组`非常方便的维护一个状态的情况。更新情况。处理起来开销较大，虽然维护方便。

#### 总结：

由于一个地方出错拼命wa ， runtimeerror.
**状态转移顺序上**

应该先枚举m递增。因为a[i] - b[i]的大小是【-20.....20】。会造成 ， 表的缺失。导致转移不正确。

#### code1.1代码

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
const int N = 810, M = 24;
const int d = 400;
int f[N][M], pre[210][N][M];
int a[N], b[N];
int main() {
	int n, m;
	int test = 0;
	while (scanf("%d%d" , &n , &m) && n && m) {
		printf("Jury #%d\n", ++test);
		memset(f, 0xf0, sizeof f);

		memset(pre, 0, sizeof pre);
		f[d][0] = 0;
		for (int i = 1; i <= n; i++) {
			scanf("%d%d" , a + i , b + i);
			int x = a[i], y = b[i];
			for (int k = m; k >= 1; k--) {
				for (int j = 400; j >= -400; j--) {
					pre[i][j + d][k] = pre[i - 1][j + d][k];
					int dd = j - (x - y);
					if (dd + d >= 0 && dd + d <= 800 && f[j + d][k] < f[dd + d][k - 1] + x + y) {
						f[j + d][k] = f[dd + d][k - 1] + x + y;
						pre[i][j + d][k] = i;
					}
				}
			}
		}
		int st = 0;
		for (int i = 0; i <= 400; i++) {
			if (f[-i + d][m] > 0 || f[i + d][m] > 0) {
				if (f[-i + d][m] > f[i + d][m]) st = -i;
				else st = i;
				break;
			}
		}
		printf("Best jury has value %d for prosecution and value %d for defence:\n", (f[st + d][m] + st) / 2, (f[st + d][m] - st) / 2);
		vector<int> rec;
		//定位用到的三个变量
		int cur = n;
		st += d;
		for (int i = m; i >= 1; i--) {
			cur = pre[cur][st][i];
			rec.push_back(cur);
			st = st - (a[cur] - b[cur]);
			cur--;
		}
		for (int i = m - 1; i >= 0; i--) {
			printf(" %d", rec[i]);
		}
		printf("\n\n");
	}
}
```

**玄学的是， 其实1.1跑的更慢。大概是初始化方式过于暴力。**

#### code1.2代码：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
const int N = 1000, M = 30;
const int d = 400;
int f[N][M];
int a[N], b[N];
vector<int> path[N][M];

int main() {
	int n, m;
	int test = 0;
	while ((scanf("%d%d" , &n , &m)) && n && m) {
		printf("Jury #%d\n", ++test);
		memset(f, -0x3f, sizeof f);

		for (int i = 0; i <= n; i++)
			for (int j = 0; j <= m; j++) {
				path[i][j].clear();
			}

		f[d][0] = 0;
		for (int i = 1; i <= n; i++) {
			scanf("%d%d" , a + i , b + i);
			int v = a[i] - b[i] , w = a[i] + b[i];
			for (int k = m; k >= 1; k--) {
				for (int j = 400; j >= -400; j--) {
					int dd = j - v;
					if (dd + d >= 0 && dd + d <= 800 && f[dd + d][k - 1] >= 0  && f[j + d][k] < f[dd + d][k - 1] + w) {
						f[j + d][k] = f[dd + d][k - 1] + w;
						path[j + d][k] = path[dd + d][k - 1];
						path[j + d][k].push_back(i);
					}
				}
			}
		}
		int st = 0;
		for (int i = 0; i <= 400; i++) {
			if (f[-i + d][m] > 0 || f[i + d][m] > 0) {
				if (f[-i + d][m] > f[i + d][m]) st = -i;
				else st = i;
				break;

			}
		}
		printf("Best jury has value %d for prosecution and value %d for defence:\n", (f[st + d][m] + st) / 2, (f[st + d][m] - st) / 2);
		//定位用到的三个变量
		st += d;
		for (int i = 0; i  < m; i++) {
			cout << " " << path[st][m][i] ;
		}
		printf("\n\n");
	}
}


```

#### code1的代码；tle了 (也可能错了qaq, 留个纪念)

```cpp
#include<iostream>
#include<vector>
using namespace std;
typedef long long ll;

const int N = 4e2 + 10;

int a[N], b[N], pre[N][N][21];
bool f[N][N][21];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n, m;
	int test = 0;
	while (cin >> n >> m && n && m) {
		test++;
		printf("Jury #%d\n", test);
		int s = 0, t = 0;
		for (int i = 1; i <= n; i++) {
			cin >> a[i] >> b[i];
			s += a[i];
			t += b[i];
		}
		for (int i = 0; i <= 400; i++)
			for (int j = 0; j <= 400; j++)
				for (int k = 0; k <= m; k++) {
					f[i][j][k] = false;
					pre[i][j][k] = 0;
				}
		s = 0, t = 0;
		//滚动之后 ， 怎么还原转移路径？
		//可以尝试记录第一次被更新到的时候的状态。
		f[0][0][0] = true;
		for (int i = 1; i <= n; i++) {
			for (int j = 400; j >= 0; j--)
				for (int k = 400; k >= 0; k--)
					for (int l = min(i, m - 1); l >= 0; l--) {
						if (f[j][k][l] && f[j + a[i]][k + b[i]][l + 1] == false) {
							f[j + a[i]][k + b[i]][l + 1] = true;
							pre[j + a[i]][k + b[i]][l + 1] = i;
							//			printf("i :%d , j : %d ， l : %d , pre : %d\n" , j + a[i], k + b[i] , l + 1 , pre[j + a[i]][k + b[i]][l + 1]);
						}
					}
			s += a[i]; t += b[i];
		}
		//然后寻找到最优的状态：
		//	printf("%d %d \n" , s , t);
		int d = 10000000, x = -1000, y = -1000;
		for (int i = 0; i <= 400; i++) {
			for (int j = 0; j <= 400; j++) {
				if (f[i][j][m] == false)continue;
				if (abs(i - j) < d) {
					d = abs(i - j);
					x = i; y = j;
					//printf("bool : %d x: %d , y: %d\n", f[i][j][m] , x , y);
				}
				else if (abs(i - j) == d) {
					if (i + j >= x + y)x = i, y = j;
					//printf("bool : %d x: %d , y: %d\n" , f[i][j][m] ,  x , y);
				}
			}
		}
		// printf("x : %d , y : %d\n" , x , y);
		printf("Best jury has value %d for prosecution and value %d for defence: \n", x, y);
		vector<int> ans;
		for (int i = m; i >= 1; i--) {
			int t = pre[x][y][i];
			x -= a[t];
			y -= b[t];
			ans.push_back(t);
			//	printf("x: %d y :%d\n" , x , y);
		}
		for (int i = 0; i < m; i++) {
			cout << ans[i] << " \n"[i == m - 1];
		}
	}
}
```

-----

C. Restore the Array

[Problem - C - Codeforces](https://codeforces.com/contest/1811/problem/C)

![image-20230405115121878](image-20230405115121878.png)

#### solve ==不懂==

一种构造方法：
$$
a[1] = b[1]\\
a[n]=b[n - 1]\\
对于中间的元素：\\
a[i]=min(b[i],b[i - 1])\\
$$
验证如下：

$b[i]=max(a[i],a[i+1])$

对于两边：
$$
max(a[1] , a[2])=max(b[1] , min(b[1],b[2]))=b[1]\\
max(a[n-1],a[n])=max(min(b[n - 1] , b[n-2]) , b[n-1])=b[n-1]
$$
对于中间：
$$
max(a[i] , a[i+1]) = max(min(b[i-1] , b[i]) , min(b[i] , b[i + 1]))\\
$$
对于合法的$b[i - 1] , b[i] , b[i+ 1]$ ， 不可能出现 
$b[i-1]\lt b[i] 且 b[i + 1] \lt b[i]$否则无解。

证明如下：b[i]在中间， 即中间必然出现一个数字 b[i] 。该数字贡献两个位置， 而相邻b[i - 1] ， b[i + 1]小于b[i] ， 说明a数组中对应b[i] 相邻必然为小于它的数字， 就会贡献两项。矛盾。


$$
综上（3）分类展开如下：\\
max(b[i - 1] , b[i])\\
max(b[i] , b[i + 1])\\
max(b[i] , b[i])\\
显然三种的结果都为b[i].
$$

#### code

```cpp
int a[N] , b[N];

void work(int testNo)
{
	int n;
	cin >> n;
	for (int i = 1; i < n; i++)
		cin >> b[i];
	cout << b[1] << ' ';
	for (int i = 1; i < n - 1; i ++)
		cout << min(b[i] , b[i + 1]) << ' ';
	cout << b[n - 1] << '\n';
}
```



---------

**D. Umka and a Long Flight**

https://codeforces.com/contest/1811/problem/D

![image-20230405163548585](image-20230405163548585.png)

 #### solve

**涉及概念：**

1. 斐波那契矩形： 如上。

**涉及操作**：

1. 染色1*1大小方块。
2. 切割矩形为若干个正方形。（每个尺寸的正方形只能出现一次。）



<img src="node-1681662136684-3.png" alt="node" style="zoom: 67%;" />



检查是否可以通过上述形式 ， 分割矩形：
方法贪心的将大的一块正方形分离出去，然后递归成分割更小地斐波那契矩形。用同一种策略递归看最后是否分成2*1地矩形。

递归模拟分割：

#### 递归代码如下：

这份代码实现细节比较高超。对坐标使用投影 ， 变换方便处理。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

ll f[50];

string check(ll n , ll x , ll y) {
	if (x == 1 && y == 1)return "YES\n";
	if (y <= f[n] && y > f[n - 1])return "NO\n";
	if (y > f[n]) y -= f[n];
	return check(n - 1 , y , x);
}
void work(int testNo) {
	ll n , x , y;
	cin >> n >> x >> y;
	cout << check(n , x , y);
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	f[0] = f[1] = 1;
	for (int i = 2; i <= 45; i++) {
		f[i] = f[i - 1] + f[i - 2];
	}
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

---------

**F. Is It Flower?**

![image-20230405181759912](image-20230405181759912.png)



#### 简介：

判断图是否为一个长度为k的简单环， 且每个点上都接着一个长度为k的环。这些环之之间不相交。如上图形式：

#### solve

判断有没有环：

1. 点的个数上：
   $$
   k + k*(k - 1) = n\\
   k^2 = n\\
   k = \sqrt n
   $$
   为正整数

2. 点的度数上：

   1. 有k割个点的度数为4
   2. 这k个点要形成一个环。

3. 其余点度数为2 ， 并且平分成k份。

   这个不大对有可能会被hack。必须保证这k份同时成一个圈。简单的判断会被hack.

   ```txt
   16 20
   1 2
   1 5
   1 6
   1 7
   2 3
   2 7
   2 8
   3 10
   3 11
   3 4
   4 13
   4 14
   4 15
   5 6
   8 9
   9 10
   11 12
   12 13
   14 16
   15 16
   
   NO
   ```

   

<img src="node-1681662149515-6.png" alt="node" style="zoom: 50%;" />

1. 找出一些条件：
   1. 每一组中的点只能其首部尾部只能遇见一种四度的点。





上述算法大模拟实现即可。

 [E. Routing.md](..\..\..\2000\图论\E. Routing.md) （这个也是涉及到了环结构比较比较）。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

vector<vector<int>> g;
vector<int>deg;
int  n , m , k;
void work(int testNo)
{
	bool f = true;
	cin  >> n >> m;
	g = vector<vector<int>>(n);
	deg = vector<int>(n , 0);
	for (int i = 0; i < m; i++) {
		int x , y;
		cin >> x >> y;
		x-- , y--;
		g[x].push_back(y);
		g[y].push_back(x);
		deg[x]++; deg[y]++;
	}
	k = sqrt(n);
	int st = 0;
	if (k * k != n)f = false;
	int sum4 = 0;
	for (int i = 0; i < n; i++) {
		if (deg[i] == 4) {
			st = i;
			sum4 ++;
		} else if (deg[i] != 2) {
			f = false;
		}
	}
	if (sum4 != k) f = false;
	//检查是否成圈。
	vector<bool> vis(n , false);
	function< bool (int)> check = [&](int x) {
		return deg[x] == 4 && vis[x] == false;
	};
	int sum = 0;
	set<int> rec4;
	function<void(int)> dfs = [&](int u) {
		vis[u] = true;
		sum++;
		for (auto v : g[u]) {
			if (check(v)) {
				dfs(v);
			}
			if (deg[u] == 2 && deg[v] == 4)rec4.insert(v);
		}
		vis[u] = true;
	};
	dfs(st);
//	cout << sum << '\n';
	if (sum != k) f = false;
	check = [&](int x) {
		return deg[x] == 2 && vis[x] == false;
	};
	for (int i = 0; i < n; i++) {
		if (deg[i] == 4) {
			st = i;
			sum = 0;
			rec4.clear();
			dfs(i);
			//cout << rec4.size() << '\n';
			if (sum != k || rec4.size() != 1)f = false;
		}
	}
	if (f) cout << "YES\n";
	else cout << "NO\n";
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

------

**G2. Vlad and the Nice Paths (hard version)**

https://codeforces.com/contest/1811/problem/G2

![image-20230405220215011](image-20230405220215011.png)

#### solve

动态规划：

**状态定义：**

$f_i$表示以i为结尾的 ， 符合条件的长度最长序列的个数。

**状态转移：**

$f_j * C(区间内c[i]颜色的个数 , k - 1)->f_i$

**初始化：**

$f_{0}= {1 ，0}$ 一个状态要记录两个量。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int mod = 1E9 + 7;
const int N = 5E3 + 10;
const int N_c = 5E3 + 10;
int c[N_c][N_c];
void C_init() {
	c[0][0] = 1;
	for (int i = 1; i < N_c; ++i) {
		c[i][0] = c[i][i] = 1;
		for (int j = 1; j < i; ++j) {
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
		}
	}
}

struct node {
	ll s;
	ll l;
} f[N];
int a[N];
int sum[N][N];
void work(int testNo) {
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			sum[i][j] = 0;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		sum[i][a[i]] = 1;
		f[i] = { 0 , 0 };
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			sum[j][i] += sum[j - 1][i];
		}
	}
	f[0] = { 1 , 0 };
	ll x = 0, y = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < i; j++) {
			if (sum[i][a[i]] - sum[j][a[i]] < k || f[j].l + 1 < f[i].l) {
				continue;
			}
			if (f[j].l + 1 == f[i].l) {
				f[i].s = (f[i].s + f[j].s * c[sum[i - 1][a[i]] - sum[j][a[i]]][k - 1] % mod) % mod;
			}
			else {
				f[i].s = f[j].s * c[sum[i - 1][a[i]] - sum[j][a[i]]][k - 1] % mod;
				f[i].l = f[j].l + 1;
			}
		}
		x = max(x, f[i].l);
	}
	// cout << "test  " << testNo << '\n';
	// cout << "x" << x << '\n';
	for (int i = 0; i <= n; i++) {
		//cout << f[i].s << " \n"[i == n];
		if (f[i].l == x) {
			y = (y + f[i].s) % mod;
		}
	}
	cout << y << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	C_init();
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

-------

https://codeforces.com/problemset/problem/1687/B

B. Railway System

![image-20230410172636355](image-20230410172636355.png)

#### solve

1. 2m次询问限制意味着什么？
2. 怎么挖掘2m的价值 ， 得到每一条边的长度？
3. 怎么联系到krusal定理？



**得到每一条边的长度：**

1. 特殊的 ， 00000100000这种形式， 可以得到一条边的长度。

**联系kruskal的关键**

1. 逐渐添加边的过程中 ， 判断是否已经属于一个连通块。应该关注什么信息？
   1. 如果添加一条边， 使得变化情况不为当前边的边长 ，说明改变已经替代了之前的一条边。所以当前边不可选。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int q[N] , len[N];
int n , m;
int query() {
	cout << "? ";
	for (int i = 1; i <= m; i++) {
		cout << q[i];
	}
	cout << endl;
	int x; cin >> x;
	return x;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cout << "? ";
		for (int j = 1; j <= m; j++)
			if (j == i)cout << 1;
			else cout << 0;
		cout << endl;
		cin >> len[i];
	}
	vector<int>id(m , 0);
	iota(id.begin() , id.end() , 1);
	sort(id.begin() , id.end() , [&](int x , int y) {
		return len[x] < len[y];
	});
	int pre = 0;
	for (int i = 0; i < m; i++) {
		q[id[i]] = 1;
		if (query() - pre == len[id[i]]) {
			pre += len[id[i]];
		} else q[id[i]] = 0;
	}
	cout << "! " << pre << endl;
}
```

**D. Sum Graph**
https://codeforces.com/contest/1816/problem/D

![image-20230412153224051](image-20230412153224051.png)

非常阴间的交互背景。

#### solve

首先构造出一个特殊的图。并且是从两点之间距离出发的。

**显然是将图变成一条有规律的单链：**

两次操作如下：

1.  `?   n + 2`
2.  `?    n + 1`

然后图就会转变成一种非常具有特殊性的图： 
1 n 2 n -1 .....

然后找到一个端点 ， 逐步确定么每一个元素距离端点的距离。最后分类讨论关注的断电在哪一端即可。

1. 找到端点, 枚举任意一个元素作为中间值， 逐步询问，显然距离最长是端点。
2. 找到其余元素离端点的距离 ， 同样逐步询问即可。
3. 然后先枚举当前端点的值， 然后确认距离 ， 从而整理出两种可能的排列。

==注意交互要求和普通的交互不一致：每次输出两种 ？ ！ 操作后都要接受一个反馈信息==

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
int ans[N];
int order[N];
int xd;
void work(int testNo)
{
	int n;
	cin >> n;
	cout << "+ " << n + 1 << endl;
	cin >> xd;
	cout << "+ " << n + 2 << endl;
	cin >> xd;
	int mx = 0, j = 1;
	for (int i = 2; i <= n; i++) {
		cout << "? " << 1 << " " << i << endl;
		int rp; cin >> rp;
		if (rp > mx) {
			j = i ;
			mx = rp;
		}
	}
	//j是两端中的一个，
	//1 , n , 2 , n  - 2 ........这样的排列方法。
	for (int i = 1 , k = 1; i <= n; i += 2 , k++) {
		ans[i] = k;
	}
	for (int i = 2 , k = n; i <= n; i += 2 , k--) {
		ans[i] = k;
	}
	order[j] = 0;
	for (int i = 1; i <= n; i++) {
		if (i != j) {
			cout << "? " << j << " " << i << endl;
			int pos;
			cin >> pos;
			order[i] = pos;
		}
	}
	cout << "!";
	for (int i = 1; i <= n; i++) {
		cout << " " << ans[order[i] + 1];
	}
	for (int i = 1; i <= n; i++) {
		cout << " " << ans[n - order[i]];
	}
	cout << endl;
	cin >> xd;
}
int main(){
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**E. Between**
https://codeforces.com/contest/1816/problem/E

![image-20230414163920631](image-20230414163920631.png)

#### solve

从能做的事情开始：

1. 什么时候无限长？
   1. 如果涉及的限制元素$a_i$没有覆盖所有元素 。那么无限长。
   2. 抽象出一种有向图。

众多情况分类讨论如下：

![node](node-1681662208187-12.png)

**就当上面随手画画图即可：**

总结出以下规律：

1. 每一个元素都有个数限制。这意味着众多的约束中。它指向了一个明确数量的数字。可以追溯到1

   1. 建立一个图来看。 b->a。那么从1bfs出发。可以到达所有数字。

2. 对于每一个点的数量。就是到达1的最短路。大小加1。记录为$s_i = d_i + 1$

3. 得到上述的信息之后怎么摆放这些元素呢？

   1. 有规律的摆放。
      1. 将所有点按照拓扑序摆放。
      2. 记录每一个点的最短路。表示其可以重复多少次。
   2. 不断按照上述序列放置。该过程中， 不断地剔除掉一些元素数字。
      1. 保证每一个数字都出现了最大可行次数。
      2. 保证了该夹的都夹上去了。

-------

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int inf = 0x3f3f3f3f;
const int N = 1700;

void work(int testNo)
{
    int n , m;
    cin >> n >> m;
    vector<vector<int>> g(n);
    vector<int>d(n , 0);
    for (int i = 0; i < m; i++) {
        int u , v;
        cin >> u >> v;
        u--; v--;
        g[v].push_back(u);
    }
    vector<int> ans;
    auto bfs = [&]() {
        queue<int> que;
        vector<bool> vis(n , false);
        que.push(0);
        d[0] = 1;
        vis[0] = true;
        while (que.size()) {
            int u = que.front(); que.pop();
            for (auto v : g[u]) {
                if (vis[v])continue;
                d[v] = d[u] + 1;
                vis[v] = true;
                que.push(v);
            }
        }
    };
    bfs();
    vector<int>id(n);
    iota(id.begin() , id.end() , 0);
    sort(id.begin() , id.end() , [&](int x , int y) {
        return d[x] > d[y];
    });
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if (d[i] == 0) {
            cout << "INFINITE\n";
            return;
        }
        sum += d[i];
    }
    cout << "FINITE\n";
    cout << sum << "\n";
    for (int i = 1; i <= d[id[0]]; i++) {
        for (auto j : id) {
            if (d[j] < i)break;
            cout << j + 1 << " ";
        }
    }
    cout << "\n";
}


int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t; cin >> t;
    for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**D. Range = √Sum**
https://codeforces.com/contest/1758/problem/D

#### 题意

![image-20230415165114028](image-20230415165114028.png)

#### solve

追求特殊性 ， 使用等差数列的方案为每一个元素分配值。

尝试这样一种构造方式 ： 首项为a , 等差为1 。然后进行求和：摸一下a的范围为：
$$
a = (n + 1)/2;
$$
![node](node-1681662222790-15.png)

调整角度为 ： 

1. 所有元素加2：
   $$
   s = n^2 + 2*n\\
   d = n - 1;
   $$

2. 

3. 尾部元素尾部元素加1：
   $$
   S = n^2 + 2n + 1\\
   =(n +1)^2\\
   d = n
   $$

4. 

5. 首部减少1 , 倒数第二个元素增加1.
   $$
   S = (n + 1)^2\\
   d = n + 1
   $$

#### 偶数角度：

<img src="node-1681576386120-2.png" alt="node" style="zoom: 33%;" />

不要问 ， 问就是玄学：

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

int ans[N];

void work(int testNo)
{
	int n;
	cin >> n;
	if (n % 2) {
		for (int i = 1; i <= n; i++) {
			ans[i] = (n + 1) / 2 + i + 1;
		}
		ans[1]--;
		ans[n]++;
		ans[n - 1]++;
	} else {
		for (int i = 0; i < n / 2; i++) {
			ans[i + 1] = n / 2 + i;
		}
		for (int i = n / 2; i < n; i++) {
			ans[i + 1] = n + i - n / 2 + 1;
		}
	}
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << " \n"[i == n];
	}
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**小d的博弈**
https://ac.nowcoder.com/acm/contest/53366/E

![image-20230407221929829](image-20230407221929829.png)

#### solve

用dp暴力打表如下：

![image-20230407222217474](image-20230407222217474.png)

或者用sg函数。这个还得学学。
着重找出x 、 y之间的关系。
x ， y满足什么条件才在一块正方形中？发现这些一块一块的正方形有一些规律， 对于每一块正方形分段，计算出x ,y边界：。
$$
x(1) , y(1)->[1 , 2]\\
s(i)表示以2^i等比数列的前缀和。\\
x(i),y(i)->[s(i -1) + 1 , s(i)]\\
[2^{i} -1 , 2^{i + 1} - 2]
$$
发现往上偏移一位之后 ，二进制长度相同即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
int len(int x) {
	int l = 0;
	while (x) {
		x /= 2;
		l++;
	}
	return l;
}
void work(int testNo)
{
	int a , b;
	cin >> a >> b;
	if (len(a + 1) == len(b  + 1)) {
		cout << "Bob\n";
	} else cout << "Alice\n";
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

#### 打表函数

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N =  1000;
bool f[N][N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	f[1][1] = f[1][2] = 0;
	int n = 100;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= n; k++) {
				if (k <= (j + 1) / 2 - 1) {
					int t = max(k , i);
					int tt = min(k , i);

					f[i][j] |= (!f[tt][t]);
				}
				if (k <= (i + 1) / 2 - 1) {
					int t = max(k , j);
					int tt = min(k , j);
					f[i][j] |= !f[tt][t];
				}
			}
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			cout << f[i][j] << " \n"[j == n];
		}
}
```



 **Frogger**

https://vjudge.csgrandeur.cn/problem/POJ-2253

![image-20230411100204036](image-20230411100204036.png)

#### solve

找到两点之间的可达路径的最大边的最小值。
通过floyed的dp思想。更新即可。

#### 生长：

数据强化版本： [Heavy Transportati.md](Heavy Transportati.md) 

#### code

```cpp
#include<iostream>
#include<math.h>
#include<iomanip>
using namespace std;
typedef long long ll;
const int N = 1E3 + 10;
double x[N] , y[N];
double d[N][N];
double f(int i , int j) {
	return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	while (t--) {
		int n , m;
		cin >> n >> m;
		cout << "Scenario #" << test << '\n';
		for (int i = 1; i <= m; i++) {
			int u , v;

		}
		for (int k = 1; k <= n; k++)
			for (int i = 1; i <= n; i++)
				for (int j = 1; j <= n; j++) {
					d[i][j] = min(d[i][j] , max(d[i][k] , d[k][j]));
				}
		cout << fixed << "Frog Distance = " <<  setprecision(3) << d[1][2] << "\n\n";
	}
}
```

**Heavy Transportati**
https://vjudge.csgrandeur.cn/problem/POJ-1797#author=0

#### solve

求出图中最小权的最大值。  N = 1000.
类似迪杰斯特拉的贪心思路 ， 逐渐求出到每一个点的所有路径中最小边的最大值。

**算法描述**

1. 初始化：
2. 确定新的d【i】
3. 对更新的点作拓展。
4. 上述2 ， 3进行n伦直到确认所有点。

**证明：**





#### code

```cpp
#include<iostream>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E3 + 10;

int g[N][N];
int d[N];
bool vis[N];

void work(int testNo)
{
	int n , m; cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		vis[i] = false;
		d[i] = 0;
		for (int j = 1; j <= n; j++) {
			g[i][j] = 0;
		}
	}
	for (int i = 0; i < m; i++) {
		int u , v , w; cin >> u >> v >> w;
		g[u][v] = g[v][u] = w;
	}
	d[1] = 1 << 29;
	for (int i = 1; i <= n; i++) {
		int m = 0 , mx = 0;
		for (int j = 1; j <= n; j++)if (d[j] > mx && vis[j] == false)mx = d[m = j];
		vis[m] = true;
		for (int j = 1; j <= n; j++) {
			d[j] = max(d[j] , min(d[m] , g[m][j]));
		}
	}
	d[1] = 0;
	cout << "Scenario #" << testNo << ":\n";
	cout << d[n] << "\n\n";
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
3* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

------

## Currency Exchange

https://vjudge.csgrandeur.cn/problem/POJ-1860#author=wanglin007

![image-20230411121947627](image-20230411121947627.png)



#### solve:

首先联系几个问题：

1. 怎么在图中寻找负数环？

**bellman算法：** 使用bellman算法迭代更新k次之后。所有节点数长度小于等于k + 1的节点数的路径 ， 都已经被考虑。如果第n次某一点的最短路依然被更新，说明存在负数环；

2. 怎么将问题转换成一个图上问题？

建图角度： ==关于点的处理：==  没有点权 ，代表一种类型的 钞票。

​                      ==关于边的处理：==   有边权（可以认为是一个函数 ） ， 转换后的钞票价格。



**question** : 所有的钞票是否都转换成一种钞票？这种转换方式是最优的吗？

考察一定量采取某一转移路径 ， 其总值的变化 ：
$$
f = (((f - a_1)*b_1 - a_2 )*b_2 - a_3)*b_3...
$$
从起点到达某一点时， 总有一个最优方案， 把所有钱投进该方案最优。所以采取全部统一的策略。

**综上：**

跑bellman ， 关注最长路。判断是否有回路即可。



纳闷的是g++ ,要改成float才能过。改成vs的c++ 可以过。不大理解。

```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<queue>
using namespace std;

const int N = 110;
double r[N][N];
double c[N][N];
double d[N];
int n , m , s;
double st;
int inq[N] , cnt[N];

bool spfa(int s , double have) {
	queue<int> que;
	memset(inq , 0 , sizeof(inq));
	memset(cnt , 0 , sizeof(cnt));
	d[s] = have;
	inq[s] = true;
	que.push(s);
	while (!que.empty()) {
		int u = que.front(); que.pop();
		inq[u] = false;
		for (int v = 1; v <= n; v++) {
			if (d[v] < (d[u] - c[u][v])*r[u][v]) {
				d[v] = (d[u] - c[u][v]) * r[u][v];
				if (!inq[v]) {
					que.push(v); inq[v] = true;
					if (++cnt[v] > n) return false;
				}
			}
		}
	}
	return true;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m >> s >> st;
	for (int i = 1; i <= m; i++) {
		int u , v;
		cin >> u >> v;
		double a , b;
		cin >> a >> b;
		r[u][v] = a;
		c[u][v] = b;
		cin >> a >> b;
		r[v][u] = a;
		c[v][u] = b;

	}
	if (spfa(s , st))cout << "NO\n";
	else cout << "YES\n";

}

/*stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





