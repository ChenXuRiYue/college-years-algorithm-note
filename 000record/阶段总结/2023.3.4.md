**2023.4第三四周**

**绝句 宋 志南
古木阴中系短篷，
仗藜扶我过桥东。
沾衣欲湿杏花雨，
吹面不寒杨柳风。**




省赛 省赛 省赛 省赛 省赛 省赛  省赛 省赛.........

拿到名额啦！ 全队都很开心， 下一个目标是省赛银。

#### 算法学习：

学点博弈论， 爽一下。

1. 博弈论
   1.  [SG函数.md](..\Logrithm\博弈论\SG函数\SG函数.md) 

   2.  [阶梯nim.md](..\Logrithm\博弈论\SG函数\阶梯nim.md) 

   3.  [翻硬币问题.md](..\Logrithm\博弈论\SG函数\翻硬币问题.md) 

   4.  [anti-sg.md](..\Logrithm\博弈论\SG函数\anti-sg.md) 

   5.  [d阶nim.md](..\Logrithm\博弈论\SG函数\d阶nim.md) 
2. 博弈论问题：
   1.  [BJwc2009 取石子游戏.md](..\Logrithm\博弈论\SG函数\SG函数例题\BJwc2009 取石子游戏.md) 
   2.  [SDOI 2009, E&D.md](..\Logrithm\博弈论\SG函数\SG函数例题\SDOI 2009, E&D.md) 

**dp**

1.  [换根dp求树直径.md](..\Logrithm\动态规划\树形dp\换根dp\换根dp求树直径.md) 


**图论**

1.  [树的直径.md](..\Logrithm\图论\树上问题\树的直径.md)  

codeforces 补题：

1.  [D. The Butcher.md](..\problems\codeforces\1900\思维\递归\D. The Butcher.md)  ==对check的理解上不够深刻：==

**codeforces**刷题：

1. 构造
   1.  [B. Letter Exchange.md](..\problems\codeforces\1900\图论建模\B. Letter Exchange.md) 
   1.  [King’s Puzzle.md](..\problems\codeforces\1900\构造\图论\King’s Puzzle.md) 
   1.  [C. Recover an RBS.md](..\problems\codeforces\1800\构造\括号序列\C. Recover an RBS.md) （未补）
   1.  [D. Super-Permutation.md](..\problems\codeforces\1400-1600\解的构造\数组模型\D. Super-Permutation.md) 
   1.  [D. Unique Palindromes.md](..\problems\codeforces\1800\构造\字符串构造\D. Unique Palindromes.md) 
2. 数论：
   1.  [C. Candy Store.md](..\problems\codeforces\1700\数论\因数问题\C. Candy Store.md) 
3. dp
   1. 博弈 ， dp  [D. Letter Picking.md](..\problems\codeforces\1900\博弈\博弈与dp\D. Letter Picking.md) 
   1. [城市里的间谍.md](..\problems\题单\算法竞赛入门经典\动态规划\DAG上的动态规划\城市里的间谍.md) 
   1. [tour.md](..\problems\题单\算法竞赛入门经典\动态规划\tour.md) 
   1. [单向TSP.md](..\problems\题单\算法竞赛入门经典\动态规划\单向TSP.md) 
   1. [学霸题，与原神の终极之战.md](..\problems\BZOJ\动态规划\dp优化\单调队列优化dp\学霸题，与原神の终极之战.md) 
   1.  [学霸题，帮原神分割布丁.md](..\problems\BZOJ\动态规划\dp优化\树状数组，线段树优化dp\学霸题，帮原神分割布丁.md) 
4. 博弈论：
   1.  [E. Removing Graph.md](..\problems\codeforces\2200\博弈论\SG函数\E. Removing Graph.md) 

--------

### SG函数

如果一种公平组合游戏可以转换成一个有向图。将问题转变成 ， 在一个有向无环图中 ， 只有一个起点，上面有一个棋子， 两个玩家轮流推动棋子 ， 不能走的玩家判负。
==**SG函数定义**==
状态x和它所有k个后继状态 $y_1 , y_2 ....y_k$
$SG_x = mex(SG_{y1} , SG_{y2} , SG_{y3}.....SG_{yk})$
==**游戏的和：**==
Gi表示若干个游戏：
G = G1 + G2 + G3
每步选择一个Gi移动一步。
==**SG定理：**==
对于由n个有向图游戏组成的组合游戏， 设它们的起点分别为$s_1 ...s_n$有： $SG(s)=SG(s_1)\oplus SG(s_2)\oplus ....\oplus SG(s_n) $
先手必胜当且仅当 ，$SG(s) > 0 $



#### 问题：

1. $SG$函数的初值怎么定义？
   1. 将终点状态定义为0.
2. 把握SG函数的使用前提：
   1. SG函数和SG定理可以解决一大类的博弈问题,这一大类的博弈问题称为**ICG游戏**.
      1. 游戏有两人参与，两人轮流做出决策，并且两人做出的决策都是对自己最优的
      2. **当有一人无法决策的时候，该人失败**。无论两人如何决策，该游戏都必然会在有限时间内结束
      3. 游戏中同一个状态不能达到多次，且游戏没有平局。游戏者在某个确定状态做出的决策集合只与状态有关，与游戏者无关

### 例题：

#### first

**1.设有一堆石子， 两个人轮流取， 每次可以取1  ... k 个 ， 谁不能动就算输， 问谁会获胜。**

$SG(i)表示当前这堆石子有i个其SG值的大小：$

$SG(0...i)$:0 1 2 3 .... k 0 1 2 3 ... k ....

规律就是mod （ k + 1 ) = 0必输。

-----

#### second

**2. n堆石子 。 两个人轮流取 ， 每次可以在一堆石头里面选取任意多的石头 ， 或者把一堆石头分裂成两堆 。 谁不能操作谁输。**

1. 思路： 打表找出sg大小的计算规律：

   1. 关于sg函数的转移：

   $$
   1. 取石头：sg(0...(i - 1))\\
   2. 分裂： sg(j)\quad xor \quad sg(j - i)
   $$

2. 

3. 然后找出规律后 ， 就可以统计多个有向图组合成的组合游戏sg情况了。

   **生长：**对于第二种分裂的统计 , 可以感受到多个有向图游戏之间有一定的独立性。

打表角度如下：

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int sg[N];
int cal(int x) {
	if (x == 0 || (x - 1) % 4 == 0 || (x - 1) % 4 == 1) {
		return x;
	} else if ((x - 1) % 4 == 2)
		return x + 1;
	else return x - 1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n = 100;
	for (int i = 1; i <= n; i++) {
		set<int> rec;
		for (int j = 1; j <= i; j++)
			rec.insert(sg[i - j]);
		for (int j = 1; j < i; j ++)
			rec.insert(sg[j] ^ sg[i - j]);
		for (int j = 0; j <= 1000; j++)
			if (rec.count(j) == 0) {
				sg[i] = j;
				break;
			}
		assert(sg[i] == cal(i));
		cout << i << " " << sg[i] << "\n";
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### third

**1. 有1*n的东西， 每个人轮流拿连续（序号必须连续）两个 ， 谁不能拿就输。 求sg的值： **
对于一个初始序号连续的序列， 拿到两个条之后 ， 就可以将问题转换成两个独立的公平组合游戏：
$sg(i) = sg(j)\quad xor\quad sg(i - j - 2)$

//这点还有待理解：

然后打表 ， 寻找规律即可。

<img src="image-20230416174857327.png" alt="image-20230416174857327"  />

​	一眼没有看出很显然的归规律 ， 但是可以看到一些数字出现的频率 ， 可以猜测出现循环结。

**技巧：**

1. 借助网站： 分析循环。（平常打比赛的时候可以用。）oeis
2. 调整文本框宽度。因为是一个字符一个字符调整的。非常清楚方便：

![image-20230416180311208](image-20230416180311208.png)

规律很显然：

##### fourth

**4. 两人在一张划分格子的白纸条上打轮流×标记。 先手填完得到一个3位连续×标记后胜利。**

考虑一种策略：

1. 打完一个标记之后 ， 不能在标记的附近5格子范围内打标记。于是和4一样， 游戏转变成两个独立游戏。
2. sg函数转移：

$sg(i) = sg(j)\quad xor \quad sg(i - j - 5)$

如果没有规律就暴力做即可。



-----------

### 阶梯nim



#### 问题描述：

有n堆石头 ，两个人进行操作： 选择第i堆石头，拿出一部分石头放在i - 1堆之中， 直到只剩下一堆。使得一方不能再拿。

#### 结论：

结果与偶数堆的sg异或和相关：

1. 偶数的sg异或和为0：先手必败。

-------

**翻硬币问题**

![image-20230418232803418](image-20230418232803418.png)

#### 理解：

上述一个特殊的约束：

1. 最右边的硬币的变化要求
2. 这样决定了每一枚硬币只能作为一种端点：

#### 结论：

1. 整个游戏的sg值， 等于每个硬币的单独的sg的异或和。

#### 硬币的sg值计算：

$sg(i) = mex(0 , sg(j), (1\le j \lt i))$

#### 原理概述：

？？？真抽象。



----

**anti -SG**

<img src="image-20230418235549490.png" alt="image-20230418235549490" style="zoom:80%;" />



**d阶nim**

![image-20230418235154997](image-20230418235154997.png)

如上 ， 不是普通人neng'gou



**取石子游戏**
http://oj.daimayuan.top/course/30/problem/1239

![image-20230419093926723](image-20230419093926723.png)

#### solve

首先是个公平组合游戏 ： 博弈的集合减少，两人操作。当集合缩减为0时结束。

1. **sg函数的计算方式：**
   ​由于数据范围比较小 ， 直接计算就行。

2. **判断先手是否必胜的方法：**

​           sg定理。

3. **找到先手必胜的第一步：**
   枚举各种操作， 找出使得后手必输的一个操作。（也是利用sg定理：）

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
int a[N] , b[N] , sg[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	int m;
	cin >> m;
	for (int i = 1; i <= m; i++)
		cin >> b[i];
	int ans = 0;
	for (int i = 1; i <= 1100; i++) {
		set<int> rec;
		for (int j = 1; j <= m && b[j] <= i; j++) {
			rec.insert(sg[i - b[j]]);
		}
		while (rec.count(sg[i])) sg[i]++;
	}
	for (int i = 1; i <= n; i++) {
		ans ^= sg[a[i]];
	}
	if (ans == 0) cout << "NO\n";
	else {
		cout << "YES\n";
		for (int i = 1; i <= n; i ++) {
			for (int j = 1; j <= m && b[j] <= a[i]; j++) {
				if ((ans ^ sg[a[i]] ^ sg[a[i] - b[j]]) == 0) {
					cout << i << ' ' << b[j] << "\n";
					return 0;
				}
			}
		}
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**SDOI 2009, E&D**

![image-20230419110448670](image-20230419110448670.png)

#### solve

$sg函数转移：$

$sg_{i , j} = mex(sg_{x , i -x} , sg_{x , j -x})$ 不太精确意会即可。

然后到打出了一张表:

![image-20230419110653060](image-20230419110653060.png)

很容易发现规律：

1. 从小到大构造这张表： 类似于当前表左上角的正方形向下贴三份， 并且将其中的一个数字x改成x + 1;其中x和正方形的长有关。
2. 那么怎么利用这种现象 ， 精确的计算sg的值呢？

模仿上述的递归构造方式 ， 是可以计算出目标的sg函数的（时间复杂度O（nlog(a)））

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1010;
int a[N] , sg[N][N];
int calsg(int i , int j) {
	if (sg[i][j] != -1) return sg[i][j];
	sg[i][j] = 0;
	set<int> rec;
	for (int x = 1; x < i; x++)
		rec.insert(calsg(x ,  i - x));
	for (int x = 1; x < j; x++)
		rec.insert(calsg(x , j - x));
	while (rec.count(sg[i][j]))sg[i][j]++;
	return sg[i][j];
}
int calc2(int  i , int j , int d) {
	if (d == -1) return 0;
	if ((i & (1 << d)) || (j & (1 << d))) {
		int ans = calc2(i & ((1 << d) - 1), j & ((1 << d) - 1) , d - 1);
		ans += ans == d;
		return ans;
	} else return calc2(i , j , d - 1);
}
void work(int testNo)
{
	int n; cin >> n;
	memset(sg , -1 , sizeof sg);
	int ans = 0;
	for (int i = 0; i < n; i += 2) {
		int x , y;
		cin >> x >> y;
		ans ^= calc2(x - 1 , y - 1 , 30);
	}
	if (ans) cout << "YES\n";
	else cout << "NO\n";
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

-------

**D. A Wide, Wide Graph**
https://codeforces.com/contest/1805/problem/D

![image-20230429112657890](image-20230429112657890.png)

#### solve

最特殊的 ， 关注树的直径。发现k变大的过程中， 如果一个点脱离了图， 就将变成孤立点。

某点是否变成孤立点的结论是：

1. 到两端点的最大距离小于k.

于是问题转变成了：求点到其它点的最大距离，其实就是该点到直径两端点的距离的较大值：

有更简单的方式求：但用换根dp做， 会使用到换根dp的经典内容 ， 经典优化：\

**指标函数定义**

$d_i$以1为根的树中， d到该子树点的最大距离。

$par_i$以该i点父亲为一个根， 除i子树点 ， 所有点 作为其子树中的点 ， 该子树的最大高度（ 根据阶段而定。类似滚动数组， 存储空间重利用。）

**状态转移：**

$d_i$   dfs扫一遍即可

$par_i$ 

1. max比较对象：
   1. 父亲的父亲
   2. i的兄兄弟。
2. 上述信息可以通过前后缀和维护。

**初始化：**

1. 根节点的没有父亲。 par[1] = -1
2. 前后缀初始化负数.因为可能没有。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
vector<int> g[N];
int d[N];
int pa[N];
int sum[N];
//子树深度
void dfs(int u, int fa) {
	d[u] = 0;
	for (auto v : g[u]) {
		if (fa != v) {
			dfs(v, u);
			d[u] = max(d[v] + 1, d[u]);
		}
	}
}
//换根dp;
void dfs2(int u, int fa) {

	int sz = g[u].size();
	vector<int>pre(sz + 5, -1), suf(sz + 5, -1);
	d[u] = max(d[u], pa[fa] + 1);
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pre[i] = max(pre[i - 1], d[g[u][i - 1]]);
		}
		else pre[i] = pre[i - 1];
	}
	for (int i = sz; i >= 1; i--) {
		int v = g[u][i - 1];
		if (fa != v) {
			suf[i] = max(suf[i + 1], d[g[u][i - 1]]);
		}
		else suf[i] = suf[i + 1];
	}
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pa[u] = max({ pre[i - 1] , suf[i + 1] , pa[fa]}) + 1;
			dfs2(g[u][i - 1], u);
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n; cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	pa[0] = -1;
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) {
		sum[d[i] + 1]++;
	}
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + sum[i];
		cout << min(1 + sum[i], n) << " \n"[i == n];
	}
}
```





#### **树的直径**

#### **概念**

直径： 两点之间的最大距离。

#### 求直径的方法：

1. 树形dp求直接直径：
2. 两次bfs求直径：

#### 拓展

1. 给定一个点， 求出其与其它点之间的最大距离：
   1. 换根dp求法 ： 比较困难。
   2. 从直径上的两个点开始进行bfs。求出最大距离。

#### bfs方法下求

依然是下述的例题：

**jls代码**

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n;
    std::cin >> n;
    
    std::vector<std::vector<int>> adj(n);
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    std::vector<int> d(n, -1);
    auto bfs = [&](int x) {
        std::queue<int> q;
        d.assign(n, -1);
        q.push(x);
        d[x] = 0;
        
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            
            for (auto y : adj[x]) {
                if (d[y] == -1) {
                    d[y] = d[x] + 1;
                    q.push(y);
                }
            }
        }
        
        return std::max_element(d.begin(), d.end()) - d.begin();
    };
    
    int x = bfs(0);
    int y = bfs(x);
    auto dx = d;
    bfs(y);
    auto dy = d;
    
    std::vector<int> ans(n + 1);
    for (int i = 0; i < n; i++) {
        ans[std::max(dx[i], dy[i]) + 1] += 1;
    }
    ans[0] += 1;
    ans[dx[y] + 1] -= 1;
    for (int i = 1; i <= n; i++) {
        ans[i] += ans[i - 1];
    }
    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << " \n"[i == n];
    }
    
    return 0;
}
```







#### 例题：

**D. A Wide, Wide Graph**
[Problem - D - Codeforces](https://codeforces.com/contest/1805/problem/D)

 [换根dp求树直径.md](..\..\动态规划\树形dp\换根dp\换根dp求树直径.md) 

**换根dp处理给定一个点 ，到其它点的最大距离：**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
vector<int> g[N];
int d[N];
int pa[N];
int sum[N];
//子树深度
void dfs(int u, int fa) {
	d[u] = 0;
	for (auto v : g[u]) {
		if (fa != v) {
			dfs(v, u);
			d[u] = max(d[v] + 1, d[u]);
		}
	}
}
//换根部dp;
void dfs2(int u, int fa) {

	int sz = g[u].size();
	vector<int>pre(sz + 5, -1), suf(sz + 5, -1);
	d[u] = max(d[u], pa[fa] + 1);
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pre[i] = max(pre[i - 1], d[g[u][i - 1]]);
		}
		else pre[i] = pre[i - 1];
	}
	for (int i = sz; i >= 1; i--) {
		int v = g[u][i - 1];
		if (fa != v) {
			suf[i] = max(suf[i + 1], d[g[u][i - 1]]);
		}
		else suf[i] = suf[i + 1];
	}
	for (int i = 1; i <= sz; i++) {
		int v = g[u][i - 1];
		if (fa != v) {
			pa[u] = max({ pre[i - 1] , suf[i + 1] , pa[fa]}) + 1;
			dfs2(g[u][i - 1], u);
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n; cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	// for (int i = 1; i <= n; i++) {
	// 	cout << d[i] << " \n"[i == n];
	// }
	pa[0] = -1;
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) {
		sum[d[i] + 1]++;
	}
	// for (int i = 1; i <= n; i++) {
	// 	cout << d[i] << " \n"[i == n];
	// }
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + sum[i];
		cout << min(1 + sum[i], n) << " \n"[i == n];
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

------

**D. The Butcher**
https://codeforces.com/contest/1820/problem/D

![image-20230417102403365](image-20230417102403365.png)

#### solve

几个关键：

1. 该矩形的面积是确定的。
2. 特殊的裁剪方式， 并且丢弃其中一部分。

考虑第一步： 

1. 最终有两种可能， 沿着高裁剪，沿着宽裁剪：
   1. 两种裁剪方式下， 导致了一些结果： 最大高， 或者最大宽。
2. 然后根据上述的结论， 可以明确：
   1. 枚举两种可能， 最大高  最大宽之后 ， 由于面积确定。宽与高就确定了。
   2. 所以一共只有两种可能结果， 最后就是check这两种结果的可行性即可。
3. check设计：(从几个角度入手：)
   1. 




#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll , ll>pll;
#define fi first
#define se second
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
int n;

bool check(ll H , ll W , multiset<pll , greater<pll> > h , multiset<pll , greater<pll> > w) {
	//维护当前的两种情形。
	//交替变换处理怎么实现？
	// cout << "\n\n\n";
	for (int i = 0 ; i < n; i++) {
		pll a = *h.begin();
		pll b = *w.begin();
		// cout << H << " " << W << "\n";
		if (H == a.fi) {
			W -= a.se;
			h.erase(h.begin());
			w.erase(w.lower_bound({a.se , a.fi}));
		} else if (W == b.fi) {
			H -= b.se;
			w.erase(w.begin());
			h.erase(h.lower_bound({b.se , b.fi}));
		} else return false;
	}
	return true;
}

void work(int testNo)
{
	cin >> n;
	multiset<pll , greater<pll> >h1 , w1;
	ll s = 0;
	for (int i = 0; i < n; i++) {
		ll h , w;
		cin >> h >> w;
		s += h * w;
		h1.insert({h , w});
		w1.insert({w , h});
	}
	ll mxh = h1.begin()->fi;
	ll mxw = w1.begin()->fi;
	set<pll> ans;
	if (s % mxh == 0 && check(mxh , s / mxh , h1 , w1)) {
		ans.insert({mxh , s / mxh});
	}
	if (s % mxw == 0 && check(s / mxw , mxw , h1 , w1)) {
		ans.insert({s / mxw , mxw});
	}
	cout << ans.size() << "\n";
	for (auto [x , y] : ans) {
		cout << x << " " << y << "\n";
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**B. Letter Exchange**
https://codeforces.com/contest/1785/problem/B

t宝的题！！！

![image-20230418093225480](image-20230418093225480.png)

#### solve

容易将人的持牌情况分类：

**策略如下：** 关注一个人缺什么牌， 多了什么牌。

1. 建立一个图描述其中的关系：
   1. 如果i 缺y 多x 建立一条边 , x -》 y . 并且将这条边标记为i。
2. 基于上图的一个结论：
   1. 如果同时存在 x  - > y , y - > x。交换两个人的x , y 牌。
   2. 上述1不断执行完之后 ， 剩下了若干个三元环 。通过两次交换即可。

这个结论怎么这么熟悉跌？ 得证证啦！

-------------



-------

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
map<char, int> mp;
map<int, char> restore;
vector<int> g[3][3];
int ans[N][4], tot;
void add(int a, int b, int c, int d) {
	++tot;
	ans[tot][0] = a;
	ans[tot][1] = b;
	ans[tot][2] = c;
	ans[tot][3] = d;
}
void solve() {
	tot = 0;
	int n; cin >> n;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			g[i][j].clear();
		}
	}
	for (int i = 1; i <= n; i++) {
		int c[3] {};
		string s;
		cin >> s;
		for (int j = 0; j < 3; j++) {
			c[mp[s[j]]]++;
		}
		//建图。
		for (int j = 0; j < 3; j++)
			for (int k = 0; k < 3; k++) {
				if (c[j] > 1 && c[k] < 1)g[j][k].push_back(i);
			}
	}
	//建图完成。
	//然后先处理
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++) {
			while (g[i][j].size() && g[j][i].size()) {
				add(g[i][j].back(), i, g[j][i].back(), j);
				g[i][j].pop_back();
				g[j][i].pop_back();
			}
		}
	//接着处理答辩
	int u = 0, v = 1, w = 2;
	if (g[v][u].size()) {
		swap(u, v);
	};
	for (int i = 0; i < (int)g[u][v].size(); i++) {
		int a = g[u][v][i];
		int b = g[v][w][i];
		int c = g[w][u][i];
		add(a, u, b, v);
		add(b, u, c, w);
	}
	cout << tot << "\n";
	for (int i = 1; i <= tot; i++) {
		// cout << ans[i][0] << " " << ans[i][1] << " " << ans[i][2] << " " << ans[i][3] << "\n";
		cout << ans[i][0] << " " << restore[ans[i][1]] << " " << ans[i][2] << " " << restore[ans[i][3]] << "\n";
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	mp['w'] = 0;
	restore[0] = 'w';
	mp['i'] = 1;
	restore[1] = 'i';
	mp['n'] = 2;
	restore[2] = 'n';
	int t; cin >> t;
	for (int i = 1; i <= t; i++)solve();
}
```



**King’s Puzzle**

![image-20230422233846495](image-20230422233846495.png)

#### solve

体现出几点特征：

1. 特殊性：
2. 简洁：
3. 有序：



**从简单的起点开始构造：**从平凡图开始

**有序构造：** 处理若干割点：

**特殊性：** 度数的值域连续 ： 接近$1....k$

然后方案如下：（有解前提下：） 

1. 1 -> 度数为k 。向后边连边：
2. 2 ->度数为k - 1 ， 向后边连边。

然后按照这种规律 ， 逐渐的把所有的点处理完。

最后剩下的点，  并入一个第一个点中。 （妙）

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , k;
	cin >> n >> k;
	if (n == 1 && k == 1) {
		cout << "YES\n";
		cout << 0 << "\n";
		return 0;
	}
	if (k >= n) {
		cout << "NO\n";
		return 0;
	}
	cout << "YES\n";
	if (k == 1 && n == 2) {
		cout << 1 << "\n";
		cout << 1 << " " << 2 << "\n";
	}
	else if (k == 1) {
		cout << n << "\n";
		for (int i = 1; i <= n; i++) {
			cout << i << " " << i % n + 1 << "\n";
		}
	}
	else {
		vector<pair<int , int>> ans;
		int d = k;
		for (int i = 1; i <= k ; i++ , d -= 2) {
			for (int j = 1; j <= d; j++) {
				ans.emplace_back(i , i + j);
			}
		}
		for (int i = k + 2; i <= n; i++) {
			ans.emplace_back(1 , i);
		}
		// set<int> rec;
		// vector<int >deg(n + 1, 0);
		// for (auto [x , y] : ans) {
		// 	deg[x]++;
		// 	deg[y]++;
		// }
		// for (int i = 1; i <= n; i++) {
		// 	rec.insert(deg[i]);
		// }
		// cout << rec.size() << "\n";
		cout << ans.size() << "\n";
		for (auto [x , y] : ans) {
			cout << x << " " << y << "\n";
		}
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

**C. Recover an RBS**
[Problem - 1709C - Codeforces](https://codeforces.com/problemset/problem/1709/C)

![image-20230429131253211](image-20230429131253211.png)

#### solve

序号模型：

1. 追求括号合法性：
   1. 能放（就方（ 。如果必然有合法解的话， 当我们无法构造合法化， 是因为）不足。应该尽量将）放在后面。
2. 判断合法性的方法：
   1. 将（抽象为1.
   2. 将 ）抽象为-1.
   3. 关注前缀和。合法要保证每一段前缀和都要大于等于0.

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ull = unsigned long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;


#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define pb push_back
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define sz(x)  (int)(x).size()

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;

int a[N];

void work(int testNo)
{
    string s;
    cin >> s;
    int n = sz(s);
    int l = 0 , r = 0;
    int low = -1 , high = inf;

    for (auto t : s) {
        if (t == ')')r++;
        else if (t == '(')l++;
    }
    // dbg(n);
    // dbg(l);
    for (int i = 0; i < n; i++) {
        if (s[i] == '(') {
            a[i] = 1;
        } else if (s[i] == ')') {
            a[i] = -1;
        } else if (s[i] == '?') {
            if (l < n / 2) {
                low = max(low , i);
                // dbg(low);
                l++;
                a[i] = 1;
            } else {
                high = min(i , high);
                r++;
                a[i] = -1;
            }
        }
    }
    // dbg(high);
    // dbg(low);
    // dbg(high);
    if (low == -1 || high == inf) {
        cout << "YES\n";
        return;
    }
    swap(a[low] , a[high]);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum + a[i];
        if (sum < 0) {
            cout << "YES\n";
            return;
        }
    }
    cout << "NO\n";
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t; cin >> t;
    for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

---

**D. Super-Permutation**
https://codeforces.com/contest/1822/problem/D

![image-20230427085354570](image-20230427085354570.png)

#### solve

 分类讨论：

1. 奇数的解存在情况：
   1. 1显然有解
   2. 其余奇数无解。容易证明， 至少有两个位置的前缀和是  n 的倍数。
2. 偶数的情况
   1. 初始 n  n - 1 . 然后奇数 ， 偶数分类。详细处理看下代码。一种左右对称构造的想法。

#### code

```cpp
void work(int testNo)
{
	int n;
	cin >> n;
	if (n == 1) {
		cout << 1 << "\n";
		return;
	}
	if (n % 2) {
		cout << -1 << "\n";
		return;
	}
	ans[1] = n;
	ans[2] = n - 1;
	for (int i = 3; i <= n; i++) {
		if (i % 2) ans[i] = n + 1 - ans[i - 1];
		else ans[i] = n - 1 - ans[i - 1];
	}
	for (int i = 1; i <= n; i++)
		cout << ans[i] << " \n"[i == n];
}
```

---

**D. Unique Palindromes**
https://codeforces.com/contest/1823/problem/D

![image-20230428091512406](image-20230428091512406.png)

#### solve

首先注意到：

1. 长度为n的字符串中 ， 本质不同的回文子串最多有n个。

2. 增加字符串的过程中， 可以控制回文串的种数增加0或1.
3. 对于每一个段， 可以分段构造贡献：

对每一段贡献为了防止前后产生干扰：

1. 使用循环串选择段落尾： abcabc..........

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ull = unsigned long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int, int>;
using pli = pair<ll, int>;
using pll = pair<ll, ll>;


#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;

int a[N], b[N];

void work(int testNo)
{
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= k; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= k; i++) {
		cin >> b[i];
	}
	string res;
	string rem;
	while (sz(rem) <= n) rem += "abc";
	int st = 0;
	char cur = 'd';
	for (int i = 1; i <= k; i++, cur++) {
		//第一段位置， 特殊的情况怎么解决？
		//题中的数据比较特殊。
		// dbg(res);
		if (a[i] - a[i - 1] < b[i] - b[i - 1]) {
			cout << "NO\n";
			return;
		}
		int t = b[i] - b[i - 1];
		if (i == 1) {
			res += "abc";
			st = 3;
			t -= 3;
			for (int j = 1; j <= t; j++)
				res += cur;
			int d = a[i] - sz(res);
			res += rem.substr(st , d);
			st += d;
		} else {
			for (int j = 1; j <= t; j++)
				res += cur;
			int d = a[i] - sz(res);
			res += rem.substr(st , d);
			st += d;
		}
	}
	cout << "YES" << "\n";
	cout << res << "\n";
	assert(sz(res) == n);
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

---

**C. Candy Store**
https://codeforces.com/contest/1798/problem/C

![image-20230418172833555](image-20230418172833555.png)

#### 20mins

?? 子问题：

1. 相当于一个分组问题： 对于一个数， 怎么确定同组元素？

   1. 能选就选？
      1. ？？ 不知道：该结论正确情况：
         1. 手推： ？？
         2. 纯逻辑推导：？？
   2. 如果允许 ， 尽量往小了选。（这个是显然的 ， 因为这样遇到了更小的数字时 ，可以获得更多的选择。）

2. 两个数可以经过因数的选取 ， 归于同一个标签的技巧是什么？

   1. 从因数的角度上看：

$$
对于数组: i， j都有\\
a_i \% lcm(b_i , b_j)=0\\
a_j\% lcm(b_i , b_j)=0
$$

读假题啦！！这里的区间是可以连续的。
所以只需要集中精力解决： 最长连续可用作同一个区间的问题即可。

#### solve

角度就是从最左端开始 ， 能选就选。
抄大哥的博客：

![image-20230418180545893](image-20230418180545893.png)

[【CF1798C】Candy Store - 一扶苏一 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/fusu2333/solution-cf1798c)

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
ll a[N], b[N];
ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}
ll lcm(ll x, ll y) {
	return x * y / gcd(x, y);
}
void work(int testNo)
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i] >> b[i];
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans++;
		ll x = a[i] * b[i], y = b[i];
		for (int j = i + 1; j <= n; j++) {
			x = gcd(x, a[j] * b[j]);
			y = lcm(y, b[j]);
			if (x % y) {
				i = j - 1;
				break;
			}
			if (j == n) {
				i = j;
				break;
			}
		}
	}
	cout << ans << "\n";
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

---

**D. Letter Picking**
https://codeforces.com/contest/1728/problem/D

![image-20230418231556614](image-20230418231556614.png)

#### solve

一般而言， 当博弈的资源规模较小时 ， 可以使用dp转移记录。上述就是例子：
**状态定义**

$f_{i , j}$表示当前选到i , j区间时候， 先手的情况。 为了方便转移， 保证j - i + 1为偶数长度。从而保证了当前的先手为alice。

其中其解有三种 0 ， 1 ， 2.分别表示 先手输 ， 平 ， 胜

**转移方程**
基于一个状态 ， 枚举可能发生的情况：两个人分别取

1. low , low + 1
2. low , high
3. high , low
4. high , high - 1

**初始化**

在这个例中 ， 与其想办法为， 最小状态转移得到的，不能存在的状态分配一个合理值。不如直接初始化zui'xiao

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 2E3 + 10;
int f[N][N];
void work(int testNo){
	string s;
	cin >> s;
	const int n = s.size();
	//0表示更小， 1 , 表示更多。
	for (int i = 1; i < n; i++) {
		if (s[i] == s[i - 1])f[i - 1][i] = 1;
		//表示更小。
		//表示更大。
		else f[i - 1][i] = 2;
	}
	for (int len = 4; len <= n; len += 2)
		for (int low = 0 , high = len - 1; high < n; low++ , high++) {
			//一共有四种选择情况。
			//low low + 1
			int t = f[low + 2][high];
			int a = 0;
			if (s[low] == s[low + 1]) {
				a = t;
			} else if (s[low] < s[low + 1]) {
				if (t == 1 || t == 2) a = 2;
				else a = 0;
			} else {
				if (t == 2) {
					a = 2;
				} else if (t == 1)a = 1;
				else a = 0;
			}
			t = f[low + 1][high - 1];
			int b = 0;
			if (s[low] == s[high]) {
				b = t;
			} else if (s[low] < s[high]) {
				if (t == 2 || t == 1) b = 2;
				else b = 0;
			} else {
				if (t == 2) {
					b = 2;
				} else b = 0;
			}
			//第二大类。
			t = f[low][high - 2];
			int c = 0;
			if (s[high] == s[high - 1]) {
				c = t;
			} else if (s[high] < s[high - 1]) {
				if (t == 2 || t == 1) c = 2;
				else c = 0;
			} else {
				if (t == 2) {
					c = 2;
				} else c = 0;
			}
			t = f[low + 1][high - 1];
			int d = 0;
			if (s[high] == s[low]) {
				d = t;
			} else if (s[high] < s[low]) {
				if (t == 2 || t == 1) d = 2;
				else d = 0;
			} else {
				if (t == 2) {
					d = 2;
				} else d = 0;
			}
			f[low][high] = max(min(a , b) , min(c , d));
		}
	if (f[0][n - 1] == 1) {
		cout << "Draw\n";
	} else cout << "Alice\n";
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

-------

[A Spy in the Metro - UVA 1025 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-1025)

**城市里的间谍：**
紫书页号： p268



#### 20mins

解决dp之前 ， 是否会使用暴力？

1. 怎么写一个暴力？

关注所有方案， 阶段中的一些标志性的量：

1. 时间发生的时间。
2. 当前在什么站点。

#### solve

这种面向一些现实中的模型的问题中  ， 时间是是天然有序的。感受这种天然有序的模型性质的其它问题，例如： [免费馅饼.md](..\..\..\kuangbing\基础dp\免费馅饼.md) 

分阶段的关注角度：时间。

**状态定义**

$dp_{i , j}$ ，表示 ， 当前处于i时刻， 间谍处于j站点的最小等待时间。

**转移方程：**

1. 等待一分钟。
2. 搭乘正向火车。
3. 搭乘反向火车。

**初始化**

1. 不存在解为无穷大。
2. 最小状态： $dp_{t, n} = 0$

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int Nmax = 100;
const int Tmax = 1000;
const int inf = 1e9 + 7;

int dt[Nmax] , tx[Nmax] , ty[Nmax];
int n , T , m1 , m2;
bool has_train[Tmax][Nmax][2];
int dp[Tmax][Nmax];
int sum[Nmax];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int _ = 1;
    while (cin >> n && n) {
        int T;
        cin >> T;
        for (int i = 1; i < n; i++) {
            cin >> dt[i];
            sum[i + 1] = sum[i] + dt[i];
        }
        for (int i = T; i >= 0; i--)
            for (int j = 1; j <= n; j++) {
                has_train[i][j][0] = has_train[i][j][1] = false;
            }
        cin >> m1;
        for (int i = 1; i <= m1; i++) {
            int t;

            cin >> t;
            for (int j = 1; j <= n; j++) {
                // cout << sum[j] + t << " \n"[j == n];
                if (sum[j] + t > T) continue;
                has_train[sum[j] + t][j][0] = true;
            }
        }
        cin >> m2;
        for (int i = 1; i <= m2; i++) {
            int t;
            cin >> t;
            for (int j = n; j >= 1; j--) {
                // cout << sum[n] - sum[j] + t << " \n"[j == 1];
                if (sum[n] - sum[j]  + t > T) continue;
                has_train[sum[n] - sum[j] + t][j][1] = true;
            }
        }
        for (int i = 1; i < n; i++)
            dp[T][i] = inf;
        dp[T][n] = 0;
        for (int i = T - 1; i >= 0; i--)
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i + 1][j] + 1;
                if (j < n && has_train[i][j][0] && i + dt[j] <= T) {
                    dp[i][j] = min(dp[i][j] , dp[i + dt[j]][j + 1]); //右
                }
                if (j > 1 && has_train[i][j][1] && i + dt[j - 1] <= T)
                    dp[i][j] = min(dp[i][j] , dp[i + dt[j - 1]][j - 1]); //左
            }
        cout << "Case Number " << _++ << ": ";
        if (dp[0][1] >= inf) cout << "impossible\n";
        else cout << dp[0][1] << "\n";
    }
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

-----

**tour**

[Tour - UVA 1347 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-1347)

![image-20230420175319848](image-20230420175319848.png)

#### solve

1. 问题可以等闲成， 两个人从同一个起点出发。达到终点。途中，两人的经过点除了起点终点外不相同。

**状态设计：**

$dp_{i ,j}$表示 ， 两个人到达分别到达max(i , j)个点时 ， 其经过的最短距离。

**转移方程：**

1. 一种处理技巧是： 规定 i  大于 j  。 $dp_{i , j } 和dp_{j , i}$等效性启发下的一个处理。

2. 因为途中的点都将被经历， 每一步决定谁先走到i + 1。类似于完全背包的优化思想
3. 从小贡献大状态的方向更加容易处理。

**初始化：**

1. dp\[1][2] = g(1 , 2)

#### 生长思考：

1. 基于等效性的启发的体会：
   1. 其作用：
      1. 优化常数：/2
      2. 降低编码难度。不需要分类讨论谁大谁小。
   2. 原理体会：
      1. 关于两个问题，它们是等效的
         1. 它们的大小相同： 问题的解系中存在单射 ， 满射的关系。
         2. 它们对更大规模问题的贡献相同， 两者其中一个有贡献计算记录即可。
2. 基于状态设计角度的体会：
   1. 类比完全背包问题：
      1. 选择1 ， 2 ， 3 步 ， 等效于当前选择1步进入下一个状态。
   2. 这种设计角度保证 《 max(i , j)的所有点经过。从而不需要具体研究解集点的经历情况。
   3. 并不可以往回走， 跳一大步之后的转移是可预测的。
   4. 转换思维：将问题分为两种阶段：分化成两个人的交互移动问题。像传纸条也有类似的 ， 双向搜索有着类似的思想精华；

#### code

[Source code - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/solution/42431288/D1jj9SGptwMT57CAe2Nn)

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define fi first
#define se second

const int N = 1100;
const double inf = 1E16;
pair<double , double> c[N];
int tot;
double f[N][N];

double g(int i , int j) {
	double dx = c[i].fi - c[j].fi;
	double dy = c[i].se - c[j].se;
	return sqrt(dx * dx + dy * dy);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n;
	while (cin >> n) {
		tot = 0;
		for (int i = 1; i <= n; i++) {
			double x , y;
			cin >> x >> y;
			c[++tot] = make_pair(x,  y);
		}
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++) {
				f[i][j] = inf;
			}
		f[1][1] = 0;
		f[2][1] = g(2 , 1);
		// cout << f[2][1] << "\n";
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j < i; j++) {
				f[i + 1][i] = min(f[i + 1][i] , f[i][j] + g(i + 1, j));
				f[i + 1][j] = min(f[i + 1][j] , f[i][j] + g(i , i + 1));
			}
		}
		//那么最终的解是和哪一个指标函数有关呢？
		for (int i = 1; n - i >= 1; i++) {
			f[n][n] = min(f[n][n - i] + g(n, n - i) , f[n][n]);
		}
		cout << fixed << setprecision(2) <<  f[n][n] << "\n";
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

---------



**单向TSP**

[Source code - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/solution/42445475/ag8ROvLP5zV5LRKpCnUc)

![image-20230421161842548](image-20230421161842548.png)

[Unidirectional TSP - UVA 116 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-116)

#### solve

==自己的：==

正推转移：

**状态定义：**

$f_{i , j}$： 从第一列格子开始 到达（i  ， j）中最大经历权重和。

$pre_{i , j}$ , $f_{i , j}$表示的最优方案中， i ， j点的前驱。

**状态转移：**

按照题意 ， 三个方向： 

1. 就是三个状态转移的同时记录初始化点即可

2. 一个技巧： 循环可以通过mod运算天然的实现。

**初始化 + 递归起点**

将第一列的初始化即可。

==书上 ， 逆推角度==

**状态定义：**

$f_{i , j}$ ，  从格子（i , j )出发到最后一列的最小开销。

$nxt_{i , j}$ ,  记录最优解 ，且最小的转移行号。

#### 生长：

遇到非常多的问题：

1. 第一构造过程中 ， 保证每一个方案都是最优。除此之外， 比较还有一个维度， 题目中的问题是针对列的而不是针对某一个点， 在列集合中再额外完成一个还原比较字典序的工作。
2. 这个角度上， 逆推似乎恰到好处。

#### 书上思路：code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E3 + 10;
const int inf = 1 << 29;

int a[N][N] , f[N][N];
int nxt[N][N];


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	while (cin >> n >> m) {
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++) {
				cin >> a[i][j];
			}
		//尝试逆推实现
		int ans = inf , first = 0;
		for (int j = m; j > 0; j--) {
			for (int i = 1; i <= n; i++) {
				if (j == m)f[i][j] = a[i][j];
				else {
					int rows[3] = {i , i - 1 , i + 1};
					if (i == 1) rows[1] = n;
					if (i == n) rows[2] = 1;
					sort(rows , rows + 3);
					f[i][j] = inf;
					for (int k = 0; k < 3; k++) {
						int t = f[rows[k]][j + 1] + a[i][j];
						if (t < f[i][j])f[i][j] = t , nxt[i][j] = rows[k];
					}
				}
				if (j == 1 && f[i][j] < ans) {
					ans = f[i][j];
					first = i;
				}
			}
		}
		cout << first;
		for (int i = nxt[first][1] , j = 2; j <= m; i = nxt[i][j] , j++) {
			cout << " " << i;
		}
		cout << "\n" << ans << "\n";
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### code 自己的思路 wa了（未解之谜）

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int , int>;
const int N = 1E2 + 10;
const ll inf = 1LL << 40;

ll a[N][N] , f[N][N] , pre[N][N];
int n , m;
vector<int> g(int t) {
    vector<int> ans;
    for (int i = m; i >= 1; i--) {
        ans.push_back(t);
        t = pre[t][i];
    }
    reverse(ans.begin() , ans.end());
    return ans;
}
bool cmp(const vector<int> & a , const vector<int> & b) {
    for (int i = 0; i < m; i++) {
        if (a[i] < b[i]) return true;
        else if (a[i] > b[i]) return false;
    }
    return true;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i++)
            for (int  j = 1; j <= m; j++) {
                cin >> a[i][j];
                f[i][j] = inf;
                pre[i][j] = inf;
            }
        for (int i = 1; i <= n; i++) {
            f[i][1] = a[i][1];
            pre[i][1] = i;
        }
        //转移顺序： 先列在行
        function<void(int , int , int)> update = [&](int i , int j, int x) {
            if (x == n + 1) x = 1;
            if (x ==  0) x = n;
            if (f[i][j] > f[x][j - 1] + a[i][j]) {
                f[i][j] = f[x][j - 1] + a[i][j];
                pre[i][j] = x;
            } else if (f[i][j] == f[x][j - 1] + a[i][j]) {
                pre[i][j] = min(pre[i][j] , 1LL * x);
            }
        };
        for (int j = 2; j <= m; j++) {
            for (int i = 1; i <= n; i++) {
                for (int k = -1; k <= 1; k++) {
                    update(i , j , i + k);
                }
            }
        }
        vector<int> ans;
        ll mi = inf;
        for (int i = 1; i <= n; i++) {
            if (f[i][m] > mi)continue;
            vector<int> temp = g(i);
            if (f[i][m] < mi) {
                ans = temp;
                mi = f[i][m];
            }
            else  if (cmp(temp , ans)) ans = temp;
        }
        // cout << "d : " << cunt++ << "\n";
        // for (int i = 1; i <= n; i++) {
        //     cout << f[i][m] << " \n"[i == m];
        // }
        for (int i = 1; i <= m; i++) {
            cout << ans[i - 1] << " \n"[i == m];
        }
        cout << mi << "\n";
    }
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





### 学霸题，与原神の终极之战

#### 题目来源：

1.  bzoj
2.  省赛筛选赛问题：

#### introduces

![image-20230425234401381](image-20230425234401381.png)

#### solve

**状态定义：**

$f_{i}$表示 ， 到达 i 点时 最低疲劳数。

**转移方程：**
$$
f_{i} = min(f_{i - k -1.......i -1} + (a_j <= a_i))
$$
**初始化：**

$f_1 =1$

**优化角度**

1. 对转移方程优化一下： 发现函数都是增加1的。因此最多只需要变化1即可。由于转移中只涉及1的常量。选最小值即可：两种选择在结果上是等效的：
2. 然后就可以转换成单调队列问题：
   1. 对于同大小的指标函数对应的位置，尽量维护最大值。
   2. 上面有个小贪心成分。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ull = unsigned long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
int a[N];
ll f[N];
int que[N] , low , high;
int n;
void work(int testNo) {
	int k;
	cin >> k;
	fill(f  , f + n + 1 , INF);
	f[1] = 0;
	low = 0;
	high = -1;
	for (int i = 2; i <= n; i++) {
		while (low <= high && i - que[low]  > k)low++;
		while (low <= high) {
			if (f[que[high]] > f[i - 1])high--;
			else if (f[que[high]] == f[i - 1] && a[que[high]] < a[i - 1])
				high--;
			else break;
		}
		que[++high] = i - 1;
		f[i] = f[que[low]] + (a[que[low]] <= a[i]);
	}
	cout << f[n] << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

# 学霸题，帮原神分割布丁

## 题目描述

$N(1\leq N\leq 10^5)$ 个布丁，第 i 个布丁的甜度为 $A_i(-10^9\leq A_i\leq 10^9)$。

现在原神要从左往右依次吃掉一段连续的布丁。如果连续一段布丁的甜度总和为负数，那么原神就会痛苦。

请问使得原神享用完所有布丁并且不痛苦的方案数。输出方案数 $\mod 1e9 + 9$（注意!!!）。

## 输入格式

第一行：一个整数 $N$

第二行：$N$ 个整数 $A_i$，分别表示第 $i$ 个补丁的甜度

## 输出格式

输出一个整数表示布丁的划分方案数 $\mod 1e9 + 9 $的结果

## 样例 #1

### 样例输入 #1

```
4
2
3
-3
1
```

### 样例输出 #1

```
4
```

## 提示

样例解释：一共 4 种分割方案:[2 3 -3 1]、[2] [3 - 3 1]、[2 3 -3][1]、[2][3 -3] [1]。

时间限制：2s

空间限制：128MB

## solve

**状态定义：**

$f_i$以， 前缀和为$s_i$ 为前缀中 ， 内部划分的方案数。

**状态转移：**

枚举到某一个位置： 根据其前缀， 更新其它$s_i$的答案。最终的解为。对小于等于$s_{last}$的状态做一次求和。



实现上：

1.  离散化。
2.  维护前缀和 ， 可以用树状数组， 线段树。

#### 生长：

1. 离散化找到了一个更加好看的写法。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
const int mod = 1E9 + 9;

int a[N] , id[N];
int n;
ll sum[N];
ll c[N];

void modify(int x , ll d) {
	for (; x <= n; x += -x & x) {
		c[x] = (c[x] + d) % mod;
	}
}
ll query(int x) {
	ll res = 0;
	for (; x; x -= -x & x) {
		res = (res + c[x]) % mod;
	}
	return res;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + a[i];
	}
	//然后做离散化。
	sort(sum + 1 , sum + n + 1);
	int last = unique(sum + 1 , sum + n + 1) - sum;
	ll pre = 0;
	for (int i = 1; i <= n; i++) {
		pre += a[i];
		id[i] = lower_bound(sum + 1, sum + last , pre) - sum;
	}
	for (int i = 1; i < n; i++) {
		ll d = (sum[id[i]] >= 0) + query(id[i]);
		modify(id[i] , d);
	}
	ll res = query(id[n]) + (sum[id[n]] >= 0);
	cout << res % mod << "\n";
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### E. Removing Graph

https://codeforces.com/contest/1823/problem/E

![image-20230428213238188](image-20230428213238188.png)

#### code

嗨 ， 比赛的时候没有看出它是环， 导致以为这个图是一张普通的图。连打表都没有做出来：

1. 首先每一个节点的度数都为2.因此这个图是一个环组成的图。

**sg定义：**

$sg_i$ 长度为i的长度的sg值。

**计算sg函数：**

就是根据sg定理求即可。求出每一个环的sg值。对这些图中的所有环的sg做一个异或和。

#### 打表结果如下：

```txt
l : r :3 4
1       0
2       0
3       1
4       1
5       1
6       2
7       0
8       0


l : r :2 8
1       0
2       1
3       1
4       2
5       2
6       3
7       3
8       4
9       4
10      0
11      0


l : r :5 10
1       0
2       0
3       0
4       0
5       1
6       1
7       1
8       1
9       1
10      2
11      2
12      2
13      2
14      2
15      0
16      0
17      0
18      0
19      0

```

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ull = unsigned long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;


#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
struct DSU {
	std::vector<int> f, siz;

	DSU() {}
	DSU(int n) {
		init(n);
	}

	void init(int n) {
		f.resize(n);
		std::iota(f.begin(), f.end(), 0);
		siz.assign(n, 1);
	}

	int find(int x) {
		while (x != f[x]) {
			x = f[x] = f[f[x]];
		}
		return x;
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	bool merge(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) {
			return false;
		}
		siz[x] += siz[y];
		f[y] = x;
		return true;
	}

	int size(int x) {
		return siz[find(x)];
	}
};
DSU dsu;

int sg[N];
int l = 3 , r = 4;
int calsg(int x) {
	if (sg[x] != -1) return sg[x];
	//然后变成了链式的情况。
	if (x < l) return sg[x] = 0;
	//然后两个一起用。
	sg[x] = 0;
	set<int> rec;
	for (int i = l; i <= r; i++) {
		for (int j = 0; j + i <= x; j++) {
			rec.insert(calsg(j)^calsg(x - i - j));
		}
	}
	while (rec.count(sg[x]))sg[x]++;
	return sg[x];
}
void solve() {
	cin >> l >> r;
	memset(sg , -1 , sizeof sg);
	cout << "l : r :" << l << " " << r << "\n";
	for (int i = 1; i <= 500; i++) {
		int ans = 0;
		set<int> rec;
		for (int j = l; j <= min(i , r); j++) {
			rec.insert(calsg(i - j));
		}
		while (rec.count(ans)) ans++;
		cout << i  << "\t" <<  ans << "\n";
	}
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	// solve();
	int n , l , r;
	cin >> n >> l >> r;
	dsu.init(n);
	for (int i = 0; i < n; i++) {
		int u , v;
		cin >> u >> v;
		u-- , v--;
		dsu.merge(u , v);
	}
	int res = 0;
	for (int i = 0; i < n; i++) {
		if (dsu.find(i) == i) {
			int cunt = dsu.size(i);
			res ^= cunt < l || cunt >= l + r ? 0 : cunt / l;
		}
	}
	if (res) cout << "Alice\n";
	else cout << "Bob\n";
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```
