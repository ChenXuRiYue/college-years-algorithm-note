**2023.4第一周**

**《荀子 修身》**
**道虽迩 ， 不行不至；事虽小， 不为不成。**

26号校赛 ，发挥不错 ， 拿到四题首。蓝桥杯 ， 天梯赛 ， 省赛将近。集中精力获得省赛名额。

倒计时： 

1. 省赛： 30天
2. 网络赛： 180 天。
3. icpc:  200天
4. ccpc: 不一定有名额。（qaq）

**算法学习**

1. [bitset_dls课程.md](..\Logrithm\杂篇\bitset\bitset_dls课程.md) 

**补题**

1.  [2023校赛补题.md](..\problems\补题\2023校赛补题.md)  （最大值的情况I待证）

**problems**

codeforce

1.  [B. Frodo and pillows.md](..\problems\codeforces\1400-1600\binary_serach\B. Frodo and pillows.md) (二分贪心)
2.  [D. Big Brush.md](..\Logrithm\思维\逆向思维\逆向构造\D. Big Brush.md)  （2000思维逆向构造）
3.  [D. Climbing the Tree.md](..\Logrithm\数学\计算\D. Climbing the Tree.md) (==)

*转换思维：*

1.  [C. Carrying Conundrum.md](..\problems\codeforces\1400-1600\dp\C. Carrying Conundrum.md) 

枚举分类讨论：

1.  [D. Moscow Gorillas.md](..\problems\codeforces\1800\特殊运算模型\MEX\D. Moscow Gorillas.md) 

**算法学习**

1. 分数规划： [分数规划.md](..\Logrithm\杂篇\分数规划\分数规划.md) 

**背包**

==下面笔记全都未补==

1.  [E - Elect.md](..\problems\BZOJ\动态规划\背包dp\E - Elect.md)  ==贪心证明==
2.  [I - 最佳团体.md](..\problems\BZOJ\动态规划\背包dp\I - 最佳团体.md) 
3.  [F - forgot.md](..\problems\BZOJ\动态规划\背包dp\F - forgot.md) 
4.  [消失之物.md](..\problems\BZOJ\动态规划\背包dp\消失之物.md) 
5.  [J - 挂饰.md](..\problems\BZOJ\动态规划\背包dp\J - 挂饰.md) 

**kuangbing基础dp题单**

1.  [Monkey and Banana.md](..\problems\题单\kuangbing\基础dp\Monkey and Banana.md) 
2.  [Doing Homework.md](..\problems\题单\kuangbing\基础dp\Doing Homework.md) 
3.  [免费馅饼.md](..\problems\题单\kuangbing\基础dp\免费馅饼.md) ==（第二份代码为什么错？ 这个问题没有处理。）
4.  [导弹拦截系统.md](..\problems\题单\kuangbing\基础dp\导弹拦截系统.md) 



**bitset**

## **bitset**

四个函数： [库中算法函数使用.md](..\..\..\programming language\C++&&C\basic of lanuge\库中算法函数使用.md) 

bitset基础函数博客：

 [stl.md](..\..\..\programming language\C++&&C\basic of lanuge\stl\stl.md) 

#### 原理：

将 unsigned long long组合起来 。将其每一个比特位看作一个独立的整体 ， 有效利用空间表达简单的信息：

#### 作用：

1. 省内存， 有效利用比特位保存信息。
2. 常数优化。和普通暴力相比，复杂度除个64 ， 32等。

#### 使用 ， 接口 ， 细节。

1. bitset定长：
2. `bitset<1000>a` 定义
3. `a[1]` 访问该位，获取当前位上修改权限。

**统计函数**

1. `a.any()`是否全是0.
2. `a.node()`是否全是1。

**运算函数**

1. 常见的位运算。
2. `a.set()`把所有位变成1.
3. `a.set(1)`把第一位变成1.
4. `a.reset()`同上。
5. `a.reset(1)`
6. `_Find_first , _Find_net`

**打印**

1. `to_string()`

**特殊使用**

`bitset<1024> a;`

` auto p = (ull*) &a;`

 `cout << p[0] << p[1] << endl; `



#### 课程problems

一般解决的问题：

1. 怎么压位？
2. 将问题模型转换成一个bitset上优化的模型。

**[BZOJ 3687, 简单题 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/30/problem/1279)**

![image-20230327194934789](image-20230327194934789-1680510852076-7.png)

### solve

关注亦或和的运算性质 ， 关注奇偶性。

**dp状态设计**

$dp_{i , j}$前i个数 ， 和为j的方案的奇偶性。

**状态转移**

$dp_{i , j}= dp_{i - 1 , j } \quad^ {\wedge}\quad dp_{i - 1 , j - x}$

**初始化**

$dp_{0 , 0} = 1$

#### 实现：

1. 一般角度： 正常转移复杂度为 2E9。

   1. 枚举前段的每一种和 ， 进行转移。
   2. 枚举数字。

2. bitset优化；

   *现象*

   1. 关注到每一个状态只有两种属性。
   2. 连续范围之内的一个点对点位运算。

#### code

```cpp
int n;
bitset<2000001> f;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	f[0] = 1;
	for (int i = 0; i < n; i++) {
		int x; cin >> x;
		f = f ^ (f << x);
	}
	int ans = 0;
	for (int i = 0; i < 2000001; i++) {
		if (f[i])ans ^= i;
	}
	cout << ans << '\n';
}
```

### **DAG 计数**

[DAG 计数 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/30/problem/1281)

![image-20230327201737983](image-20230327201737983-1680510852076-8.png)

#### solve

按照输入风格，点的标号已经可以作为拓扑序。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 5E4 + 10;
bitset<N> f[N];
vector<int> g[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u , v;
		cin >> u >> v;
		g[u].push_back(v);
	}
	for (int i = n; i >= 1; i--) {
		f[i][i] = 1;
		for (auto v : g[i]) {
			f[i] |= f[v];
		}
	}
	for (int i = 1; i <= n; i++) {
		cout << f[i].count() << '\n';
	}
}
```

**三元组计数问题**

记录下所有点与其它点的可达情况之后。枚举两个点.

`ans += (g[u] & g[v]).count()`

注意方案重贡献两次，最终结果要除3.

**转递闭包**

其实就是求出每个点的可达性。

1. 如果没有回路利用拓扑序dp。

2. 类似弗洛伊德的思想：

   `	for(int k = 1;k <= n; k++){`

   `	for(int i = 1; i <= n; i++)`

   `	if (g[i][k])`

   `g[i] |= g[k];`

   `}`

2更好写。



### 两个串

![image-20230327215853899](image-20230327215853899-1680510852076-9.png)

**通配符匹配问题**

有几种解决思路： fft  ， bitset



**下面是bitset的解决思路：**

观察出下列现象：
对于最简单类型的01匹配，可以直接取出一段运算。
字符串匹配有类似的性质。不同点在于字符的位上的种数有27种。

枚举t串中的字符。每一次枚举，筛除掉一部分字符位置，剩下位置对应的字符串对于枚举过的t[i]是匹配的。全部枚举完成之后，留下来的解就是所有解的全集了。（筛法思想。）

对于枚举t上的字符,快速筛掉不匹配的位置。这点可以使用bitset优化。

1. `bitset g[i][j]`表示对应char(i + 'a') ； 第j位上如果为1表示s串中对应的字符就是（i+ ’a‘）;

2. 枚举t串上的i位时，如果s的j位上不为枚举字符。那么j - i不可能为匹配串的首部。该过程可以看作g[j]和 f[j - i]

   的且运算。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E5 + 1;
bitset<N> f;
bitset<N> g[28];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	string s , t;
	cin >> s >> t;
	int n = s.size() , m = t.size();
	for (int i = 0; i < n; i++) {
		g[s[i] - 'a'][i] = 1;
	}
	for (int i = 0; i <= n - m; i++)
		f[i] = 1;
	for (int i = 0; i < m; i++) {
		if (t[i] == '?')continue;
		f &= g[t[i] - 'a'] >> i;
	}
	cout << f.count() << "\n";
	for (int i = 0; i < n ; i++) {
		if (f[i]) cout << i << '\n';
	}
}
```



### k维数点

![image-20230329105929548](image-20230329105929548-1680510852076-10.png)



#### solve

直接暴力： 枚举$O(n^2\times k)$
换个角度， 预处理一些集合。从简单枚举变成集合的交集。

预处理 bitset$g_{i , j }$ ， 表示第i维小于j 的点的集合。

于是求集合的过程中，就是每一求出每一维度满足条件的集合，的交集。扫描过程中，交集同时用一个f维护即可。

**其它问题**
空间花销过大 ， 可能会被卡空间：

----------

开一个g：
$5\times(5 \times 10^4 )^2$

1.25 * 10 ^10

直接炸

----------

**卡空间的处理方法**

使用分块的处理方法。对于某维度上只处理B ， 2B  ， 3B ..... n / B *B 大小的集合。对剩下的一小块 ， 暴力枚举处理即可。

**预处理的方法：**

![node](node-1680510852076-11.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 5E4 + 10;
const int B = 250;
int a[N][10];
int pos[10][N];
//表示第几维 ， 大小小于等于N的集合情况。
bitset<N> f[10][N / B + 10] , ans , s;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , k; cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < k; j++) {
			cin >> a[i][j];
			pos[j][a[i][j]] = i;
		}
	}
	//预处理。
	for (int i = 0; i < k; i++) {
		for (int j = B; j <= n; j += B) {
			f[i][j / B] = f[i][j / B  - 1];
			for (int l = 0; l < B; l++) {
				f[i][j / B][pos[i][j - l]] = 1;
			}
		}
	}
	//进行几项重要的预处理。
	//分块中的一些细节处理：
	// 对于一个具体的位置pos应该投射到具体的第几块？
	// 管理分块标记。
	//求并集交集 ， 补集。
	for (int i = 1; i <= n; i++) {
		ans.set();
		for (int j = 0; j < k; j++) {
			s = f[j][a[i][j] / B];
			for (int l = a[i][j] / B * B + 1; l <= a[i][j]; l++) {
				s[pos[j][l]] = 1;
			}
			ans &= s;
		}
		cout << ans.count() - 1 << '\n';
	}
}
```



**校赛补题**

**A 萤火虫**

性质 ， 构造最优解：

[A-萤火虫_广州大学第十七届ACM大学生程序设计竞赛（同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/53967/A)

问题等效为， 进行若干次操作1之后 ， 至多有多少个位置为0。

探究操作1的性质：

1. 同余分组。进行操作1相当于对每一个余数组的和进行加减1.
2. 不变量： 进行一些操作1之后，每一组和之间的差值不变。

存在一种方案，将0 ...... n - k) 所有位置变成0。考虑对最后k位进行处理。在前不变量性质的指导下。这一组继续操作成0的最大个数为组内和相同的组数。

不会有更多的方案，反证法证明如下：

标记同余组的和为$s_{0....k - 1}$

1. 如果存在更少的方案： 
   1. 非1的点落在0.... k - 1中的某一组。个数为a.
   2. 至少有 k  - a组之间的差相同。
   3. 违背上述的现象。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
void work(int testNo)
{
	int n , k;
	cin >> n >> k;
	vector<int> a(k , 0);
	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		a[i % k] += x;
	}
	map<ll , int> rec;
	int mx = 0;
	for (int i = 0; i < k; i++) {
		rec[a[i]]++;
		mx = max(rec[a[i]] , mx);
	}
	cout << k - mx << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

**G Clannad**

[G-Clannad_广州大学第十七届ACM大学生程序设计竞赛（同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/53967/G)

由鸽巢原理，必然出现同余的情况。除了前提性不能得到满足， 所有的方案都满足题意。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int N_C = 1E5 + 10;
const int mod = 1E9 + 7;

int fac[N_C] , infac[N_C];
ll qp(ll x  , ll n , ll p) {
	ll res = 1;
	while (n > 0) {
		if (n & 1) res = res * x % p;
		x = x * x % p;
		n /= 2;
	}
	return res;
}
void init() {
	fac[0] = infac[0] = 1;
	for (int i = 1; i < N_C; i++) {
		fac[i] = 1LL * fac[i - 1] * i % mod;
		infac[i] = 1LL * infac[i - 1] * qp(i , mod - 2 , mod) % mod;
	}
}
ll c(int a , int b) {
	return 1LL * fac[a] * infac[b] % mod * infac[a - b] % mod;
}

void solve() {
	int n , x;
	cin >> x >> n;
	if (x + 1 > n) {
		cout << -1 << '\n';
		return;
	}
	cout << c(n , x + 1) << '\n';

}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin >> t;
	init();
	while (t --) {
		solve();
	}
}
```

**I min and max**

![image-20230403164405941](image-20230403164405941.png)

二进制：
形象的观察一种其摆放方式特点：

考虑最小值：

1. 降序的放： 物品之间没有空隙 ， 这种方案必然是长度的最小值。

考虑最大值：

----------



----------

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
ll w[N];
void work() {
	int n; cin  >> n;
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
		w[i] = (1LL << w[i]);
	}
	sort(w + 1 , w + 1 + n);
	ll s = 0;
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		if (i > (n + 1) / 2)ans += w[i] * 2;
		s += w[i];
	}
	if (n & 1)ans += w[(n + 1) / 2];
	cout << s << ' ' << ans << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	work();
}
```



**H 性格差劲的久美子**

[H-性格差劲的久美子_广州大学第十七届ACM大学生程序设计竞赛（同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/53967/H)

![image-20230403164457564](image-20230403164457564.png)

考察一个符合条件的的序列，其实就只是满足题中给出的定义即可。从该角度上看：进行一些量的抽象： 对于一个数字：有关注最后出现的位置 ， 最初出现的位置$R[i] ,L[i]$ ， 一个合法的序列必须满足条件为：
$R[i]< L[j] , i < j$
所以就是一个最长单调下降序列的变形。
集中精力 ， 处理这种变化：类比发现和普通的dp处理其实一致。

#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using iip = pair<int , int>;

const int N = 1E6 + 10;
int a[N] , b[N];
map<int , iip> rec;
int d[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n; cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int m; cin >> m;
	for (int i = 1; i <= m; i++) {
		cin >> b[i];
		if (rec[b[i]] == iip{0 , 0}) {
			rec[b[i]] = {i , i};
		} else rec[b[i]].second = i;
	}
	d[0] = 1E9 + 10;
	int ans = 0 ,  cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (rec[a[i]] == iip{ 0 , 0}) {cnt++; continue;}
		int low = 0 , high = ans + 1;
		int fi = rec[a[i]].first;
		int se = rec[a[i]].second;
		while (low < high) {
			int mid = (low + high) / 2;
			if (d[mid] < se) high = mid;
			else low = mid + 1;
		}
		d[low] = max(d[low] , fi);
		ans = max(ans , low);
	}
	cout << ans + cnt << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```
#### 生长：

如果 ， 在二分时 ， 将`d[mid] < se `改为 `d[mid] <= se` 就会wa一个点。按照题意 ， 如果存在两个点是不可能会出现相等的情况的。这应该没有影响但是 ， 确实是wa了一个点。

****

[B-罗伯特_广州大学第十七届ACM大学生程序设计竞赛（同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/53967/B)

![image-20230329002015625](image-20230329002015625.png)



从起点出发搜索。bfs即可。

**比较难写的地方**

1. 处理传送阵的情况
2. 状态的记录相对复杂： 包含了路标的使用。
------
1. 着重感受， 枚举的过程中，最优解保持优势。
2. 再次回到一个状态时，其优劣情况。


```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int , int>;

const int N = 1E2 + 10;
const int inf = 1E9 + 10;

pii nxt[N][N];
char mp[N][N];
int f[N][N][N][10];
int dx[5] = { -1 , 0 , 1 , 0} , dy[5] = {0 , 1 , 0 , -1};
bool vis[N][N][N][10];

struct node {
	int d , x , y , k , f;
	bool operator< (const node & t) const {
		return d > t.d;
	};
};
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m , k , p; cin >> n >> m >> p >> k;
	for (int i = 1; i <= p; i++) {
		int a , b , c , d;
		cin >> a >> b >> c >> d;
		nxt[a][b] = {c , d};
		nxt[c][d] = {a , b};
	}
	for (int i = 1; i <= n; i++) {
		cin >> (mp[i] + 1);
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (mp[i][j] == 'U') mp[i][j] = '0';
			else if (mp[i][j] == 'R')mp[i][j] = '1';
			else if (mp[i][j] == 'D')mp[i][j] = '2';
			else if (mp[i][j] == 'L')mp[i][j] = '3';
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int s = 0; s <= k; s++)
				for (int t = 0; t < 5; t++)
					f[i][j][s][t] = inf;

	priority_queue<node> que;
	//初始状态为在起点处，花费步数为1。总长度为：
	f[1][1][0][1] = 0;
	que.push({0 , 1 , 1, 0 , 1});
	while (que.size()) {
		auto cur = que.top(); que.pop();
		//然后进行一些列的迁移；
		if (vis[cur.x][cur.y][cur.k][cur.f])continue;
		vis[cur.x][cur.y][cur.k][cur.f] = true;
		//接下来就是转移了。
		//然后是迁移分类讨论；
		//分成若干类；
		//第一类型， 可以在其中放置路标。
		if (mp[cur.x][cur.y] == '.') {
			//向四个方向转移：
			//解决四个方向。
			for (int i = 0 ; i < 4; i++) {
				//确定下一个转移状态。
				//确定下一个状态：
				int nx = dx[i] + cur.x , ny = cur.y + dy[i] , nf = i , nk = cur.k + (nf != cur.f);
				if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && mp[nx][ny] != '#') {
					if (nxt[nx][ny].first != 0) {
						//说明当前是传送阵
						//先用一个temp保存结果，小心后效性。
						auto temp = nxt[nx][ny];
						nx = temp.first;
						ny = temp.second;
					}
					int nd = f[cur.x][cur.y][cur.k][cur.f] + 1;
					if (nk <= k && f[nx][ny][nk][nf] > nd) {
						f[nx][ny][nk][nf] = nd;
						que.push({nd , nx , ny , nk , nf});
					}
				}
			}
			//另外的普通情况。
		}
		if ((mp[cur.x][cur.y] >= '0' && mp[cur.x][cur.y] <= '3') || mp[cur.x][cur.y] == '@') {
			int nf = mp[cur.x][cur.y] - '0';
			if (mp[cur.x][cur.y] == '@') nf = cur.f;
			int nx = cur.x + dx[nf] , ny = cur.y + dy[nf];
			int nk = cur.k;
			//然后接下来就是处理：
			if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && mp[nx][ny] != '#') {
				if (mp[nx][ny] == '@') {
					auto temp = nxt[nx][ny];
					nx = temp.first;
					ny = temp.second;
				}
				int temp = f[cur.x][cur.y][cur.k][cur.f] + 1;
				if (f[nx][ny][nk][nf] > temp) {
					f[nx][ny][nk][nf] = temp;
					que.push({temp , nx , ny , nk , nf});
				}
			}
		}
	}
	int ans = inf;
	for (int i = 0; i <= k; i++)
		for (int j = 0; j < 4; j++) {
			ans = min(ans , f[n][m][i][j]);
		}
	if (ans == inf) {
		cout << "NO\n";
	} else {
		cout << "YES\n";
		cout << ans << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

## codeforces

**B. Frodo and pillows**

https://codeforces.com/contest/760/problem/B

![image-20230403170800748](image-20230403170800748.png)



#### solve

最优方案是以k位置为做高 ，然后往两边逐步降。注意最小值为1.二分求出临界值。
整体来说有一些小计算。处理起来有些麻烦。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
ll n , m , k;
ll l , r;
bool check(ll x) {
	ll suml = 0 , sumr = 0;
	if (x > l) {
		suml = (x - 1 + x  - l) * l / 2;
	} else {
		suml = x * (x - 1) / 2;
		suml += (l - x + 1);
	}

	if (x > r) {
		sumr = (x - 1 + x - r) * r / 2;
	} else {
		sumr = x  * (x - 1) / 2;
		sumr += (r - x + 1);
	}
	return suml + sumr + x <= m;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m >> k;
	int low = 1, high = m;
	//两边的长度。
	l = k - 1;
	r = n - k;
	while (low < high) {
		int mid = (low + high + 1) / 2;
		if (check(mid)) {
			low = mid;
		} else {
			high = mid - 1;
		}
	}
	cout << low << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**D. Big Brush**

[Problem - D - Codeforces](https://codeforces.com/contest/1638/problem/D)

![image-20230329002849750](image-20230329002849750.png)

**solve**

覆盖问题中典型的逆向思维：
关注最终结果， 发现一些同色的块 ，则必然是之前该位置作为整体最后一次涂上颜色。
1. 如果当前块中同色的可以分成多个正方形块怎么办？
   1. 随便截取一块下来。最后一次有多种可能 ， 一个可行，无论其它方案怎么处理都可行。
2. 找出其中的若干几块正方形。之后 ， 怎么得到更进一步的正方形？
   1. 同色正方形中原来的颜色可以是任意的。处理完之后打上表示任意的标记。
   2. 然后通过任意标记的引入更新新的正方形即可。

如果最终没有办法将所有的块变成任意标记： 无解。
时间复杂度为$O(nm)$
#### 生长思考：
未解决问题： 上述的结论，一些细节未证如下： 
1. 对于同色块 ， 选择该步数先填哪一个效果是一致的。
2. 引入任意色的作用，想法。
**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
const int N = 1E3 + 10;
int a[N][N], cunt;
struct tt {
	int first;
	int second;
	int ch;
} ans[N * N];
int ch;
bool check(int x, int y) {
	set<int> rec;
	for (int i = 0; i < 2; i++)
		for (int j = 0; j < 2; j++) {
			rec.insert(a[x + i][y + j]);
		}
	ch = *(--rec.end());
	return (rec.size() == 1 && rec.count(-1) == 0) || (rec.size() == 2 && rec.count(-1));
}
void update(int x, int y) {
	for (int i = 0; i < 2; i++)
		for (int j = 0; j < 2; j++)
			a[x + i][y + j] = -1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n, m; cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
	for (int i = 1; i < n; i++)
		for (int j = 1; j < m; j++) {
			if (check(i, j)) {
				ans[cunt++] = {  i , j , ch};
				update(i, j);
			}
		}
	int low = 0;
	while (low < cunt) {
		int x = ans[low].first;
		int y = ans[low].second;
		for (int i = -1; i < 2; i++)
			for (int j = -1; j < 2; j++) {
				int tx = i + x, ty = j + y;
				if (tx >= 1 && tx < n && ty >= 1 && ty < m && check(tx, ty)) {
					ans[cunt++] = { tx , ty , ch};
					update(tx, ty);
				}
			}
		low++;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			if (a[i][j] != -1) {
				cout << -1 << '\n';
				return 0;
			}
		}
	cout << cunt << '\n';
	while (cunt) {
		--cunt;
		cout << ans[cunt].first << ' ' << ans[cunt].second << ' ' << ans[cunt].ch << '\n';
	}
}
```

--------

**D. Climbing the Tree**
https://codeforces.com/contest/1810/problem/D
![image-20230401113213297](image-20230401113213297.png

![image-20230401113232052](image-20230401113232052.png)

#### solve

**关于询问1**

1. 计算出，当前信息下地最大高度以及最小高度。

手段： 关注几个量 解不等式组：
$$
d最后一次跳跃高度：\\
x , y,n(早上向上上升高度 ， 晚上向下下滑高度 , 天数)\\
d\le x\\
d + (x - y)\gt  + x\\
h_{max}=(n -1)*(x- y) + x\\
h_{min}=(n - 1)*(x-y)+y+1、、
$$
特判n = 1情况。 此时不存在上一次向上爬不到达终点地前提。所以此时 $h_{min}=h_{max} =1$

**关于询问二**

1. 根据当前地最大高度以及最小高度 ， 来计算出最长天数、最小天数。

手段：

1. 二分：

   二分天数。

2. 归纳出公式：

   符号依然使用上述体系：
   $$
   假设天数：t\\
   (x - y)*(t-1)+x\ge h\\
   t\ge\frac {(h - y)}{x-y}\\向上取整即可。
   $$
注意特判1.

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const ll inf = 1LL << 59;
const int N = 1E6 + 10;

void work(int testNo)
{
	int q;
	cin >> q;
	ll mi = 1 , mx = 2E18;
	//不断的找到最大最小高度。
	//维护， 计算可能的最快天数以及最小天数。
	while (q--) {
		ll x , y , z;
		int ch;
		cin >> ch;
		if (ch == 1) {
			cin >> x >> y >> z;
			//最高 ， 最低。
			ll a , b;
			if (z != 1) {
				a = (z - 1) * (x - y) + y + 1;
				b = (z - 1) * (x - y) + x;
			} else {
				a = 1;
				b = x;
			}
			if (a <= mx && b >= mi) {
				mi = max(mi , a);
				mx = min(mx , b);
				cout << 1 << ' ';
			} else cout << 0 << ' ';
		} else {
			cin >> x >> y;
			//cout << '\n' << mi << ' ' << mx << '\n';
			ll a , b;
			if (mi <= x) a = 1;
			else {
				a = (mi - y + x - y - 1) / (x - y);
			}
			if (mx <= x) b = 1;
			else {
				b = (mx - y + x - y - 1) / (x - y);
			}
			if (a == b)cout << a << ' ';
			else cout << -1 << ' ';
		}
	}
	cout << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

--------



**C. Carrying Conundrum**

https://codeforces.com/contest/1567/problem/C

![image-20230403200324944](image-20230403200324944.png)

**提供两种解决思路：**

1. 性质挖掘：

   发现问题转变成，奇数上的进位 ， 进到下一位奇数位。于是问题转变成， 于是奇数位，偶数位两个位置相独立。求出“奇数x”，以及偶数的方案然后拼接起来即可。（x + 1）(y + 1) - 2 。注意去除去除一项拼接成0的方案。

2. dp角度

   **定义dp**

   dp\[i][0/1/2]表示对后 1 ， 2 位产生 进位进位 ， 前i个数上已经相同的方案数目。

   **状态转移：**

   枚举a当前位选什么 ， 枚举更小规模的状态。然后通过当前位上的结果 ， 枚举是否有进位。然后由后往前（重点在更小规模状态）贡献转移即可。

#### code1模型性质挖掘：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
void work(int testNo)
{
	string s; cin >> s;
	int x = 0 , y = 0;
	//reverse(s.begin() , s.end());
	for (int i = 0; i < (int)s.size(); i += 2) {
		x = x * 10 + (s[i] - '0');
	}
	for (int i = 1; i < (int)s.size(); i += 2) {
		y = y * 10 + (s[i] - '0');
	}
	cout << (x + 1)*(y + 1) - 2 << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

--------

和上问题有点像， 补充一下：

https://codeforces.com/contest/1699/problem/C

给定一个0.....n-1的排列。

定义一种运算 MEX( l , r )。为\[L,R]之内（0....n）最小的缺省值.

寻找和题目给定排列任意子区间下 MEX{l,r}相等的排列总数。

#### solve:

一步一步迁移计算等效数组。定义pos(i)为数字i中的位置。

先关注两个位置 0 ， 1显然不能变。如果0变了。

接下来看2，有两种情况。

- 0，1之内。可以在其中随便变化位置。
- 0，1之外，不可以改变位置。此时更新L，R

接下来看3同理向上面的情况进行处理。

计算贡献的方法是：如果当前检查的数字在{L，R}之内，就是R—L+1-i.用分步计算原理来理解。前面的所有数字都已经相乘上了该数字可以放的位置的所有选择。相当于一个数字一个数字，分n步的放。同时不可以影响到之前的选择。

所以对于第i步的总方案数是R—L+1-i.

#### code-

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;
int mod = 1E9 + 7;
void solve()
{
    int n;
    cin >> n;
    vector<int> a(n), pos(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
        pos[a[i]] = i;
    }
    ll ans = 1, l, r;
    l = r = pos[0];
    for (int i = 1; i < n; i++)
    {
        if (pos[i] < l)
            l = pos[i];
        else if (pos[i] > r)
            r = pos[i];
        else
            ans = (ans * (r - l + 1 - i)) % mod;
    }
    cout << ans << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int t;
    cin >> t;
    while (t--)
        solve();
}
```



## **分数规划**
https://oi-wiki.org/misc/frac-programming/
**问题形式：**

求一个分式子的极值： 其中该分式子有如下特点：
$$
\frac{\sum_{i=1}^{n}a_i*w_i}{\sum_{i=1}^{n}b_i*w_i}
$$
其中$w_i为{0 或1}$

#### 解决方法

**二分**
$$
\frac{\sum_{i=1}^{n}a_i*w_i}{\sum_{i=1}^{n}b_i*w_i}\ge x
$$

$$
{\sum_{i=1}^{n}a_i*w_i}-x{\sum_{i=1}^{n}b_i*w_i}\ge 0
$$

二分x.



**E - Elect**

 [动态规划-背包专项练习1 - Virtual Judge (d0j1a1701.cc)](https://vjudge.d0j1a1701.cc/contest/550928#problem/E)![image-20230331095703023](image-20230331095703023.png)



#### solve

对席位数排序后做01背包：

**证明：**

1. 所有解是否合法？

   对于$f_{x} , x\gt (sum)/2$ ， 被更新时 ，新选择的物品中 ， 必然小于拼接方案中的任意一个物品。所以该状态对应的方案必然是合法方案。

2. 所有解是否讨论充分？

   小于sum/2的所有情形都被记录 ，这和普通的01背包原理相同。

   大于sum/2的状态不能参与迁移， 否则必然是不合法解。就是全集减去一个必然不合法的集合。所以是对所有可能的方案都考虑充分的。 

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E5 + 10;
bool f[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n; cin >> n;
	vector<int> a(n);
	ll sum = 0;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		sum += a[i];
	}
	sort(a.rbegin() , a.rend());
	int ans = 0;
	f[0] = true;
	for (int i = 1 ; i <= n; i++) {
		for (int j = min( sum / 2 + a[i - 1], sum); j >= a[i - 1] ; j--) {
			f[j] |= f[j - a[i - 1]];
			if (f[j]) ans = max(j , ans);
		}
	}
	cout << ans << '\n';
}
```

-------

**I - 最佳团体**
https://vjudge.d0j1a1701.cc/contest/550928#problem/I

简介：![image-20230331090428576](image-20230331090428576.png)

#### solve

分数规划问题： 初步分析如下：

二分答案：
$$
\frac {\sum _{i=1}^{n} a_i*w_i}{\sum_{i=1}^{n}b_i*w_i} \le mid
$$

$$
\sum_{i=1}^{n}(a_i - mid*b_i)\times w_i<=0。
$$

有k次机会分配$w_i的情况$
**题意分析**

![image-20230403204559915](image-20230403204559915.png)

根据输入的特点 ，发现图必然是一课没有回路的拓扑图。用二分解决上述分数规划问题。

然后转换成树上规定大小的连通块背包问题。时间复杂度是$O(n^2)$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const ll inf = 1E9;
const int N = 2505;
int n, m, a[N], b[N];
double f[N][N], pre[N];
int sz[N];
double mid;
vector<int> g[N];
inline void dfs(int u) {
	for (int i = 2; i <= m; i++)
		f[u][i] = -1000000000;
	f[u][0] = 0;
	f[u][1] = b[u] - a[u] * mid;
	sz[u] = 1;
	for (auto v : g[u]) {
		//防止会回路。
		dfs(v);
		for (int i = 1; i <= sz[u]; ++i)pre[i] = f[u][i];
		for (int i = 1; i <= sz[u]; ++i)
			for (int j = 0; j <= sz[v] && i + j <= m; ++j)
				f[u][i + j] = max(pre[i] + f[v][j], f[u][i + j]);
		sz[u] += sz[v];
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> m >> n;
	m++;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i] >> b[i];
		int x; cin >> x;
		g[x].push_back(i);
	}
	double low = 0, high = 10000;
	while (low + 0.0001 < high) {
		mid = (low + high) / 2;
		dfs(0);
		if (f[0][m] < 0) high = mid;
		else low = mid;
	}
	cout << fixed << setprecision(3) << low << '\n';

}
```

-------

**F - forgot**
https://vjudge.d0j1a1701.cc/contest/550928#problem/F

![image-20230403211252327](image-20230403211252327.png)

#### solve

观察一些要求： 字典中是被分为下列的一些词的。所以可以将这些词作为整段考虑。同时要满足段之前也是由这些字典组成的词。

**状态设计：**
$f_{i}$表示i位置为末尾的合法的最小字典序方案。

**状态转移**

1. 枚举单词：
2.  check考虑接在当前的枚举位置尾部合法
   1. 通过f数组，将该单词作为一个整体考虑之后，前方段的单词是否可以作为一个整体考虑。
   2. 如果可以更新当前的状态的最小字典序单词。
3. 注意初始化， 如果当前单词就是一整段并且 ，考虑更新f值。
   1. 如果f已经有考虑解 。 比较得出小字典序。然后返回。
   2. 如果f函数尚未考虑解 ， 直接更新f。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;

string t[N];
string f[N];
string s;

//局部匹配函数的设计。
bool check(int low, int j) {
	for (int i = 0; i < (int)t[j].size(); i++) {
		if (s[low + i] != '?' && s[low + i] != t[j][i])
			return false;
	}
	return true;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n, m;
	cin >> n >> m;
	cin >> s;
	//前若干个。
	s = ' ' + s;
	for (int i = 0; i < m; i++) {
		cin >> t[i];
	}
	//怎么进行初始化？
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < m; j++) {
			int st = i - t[j].size();
			if (st < 0) continue;
			if (st && f[st] == "") continue;
			if (check(st + 1, j)) {
				if (f[i] == "" || f[st] + t[j] < f[i])
					f[i] = f[st] + t[j];
			}
		}
	}
	cout << f[n] << '\n';
}
```

----------

**消失之物**
https://vjudge.d0j1a1701.cc/contest/550928#problem/G

![image-20230403213924776](image-20230403213924776.png)

#### solve

类比普通的背包问题，这里是一个要维护一个物品的丢失情形。
比较巧妙 ， 慢慢体会。
先求出整体的背包问题的所有解。

**状态 **

$f_{i,j}$表示考虑前i个物品，当前体积为j的方案个数。

$g_{i,j}$表示不选择i物品 ， 体积为j的方案数个数。

**状态转移：**

$f_{i , j}$普通的背包方法求取即可。

$g_{i , j}$：

1. j < w[i]: $g_{i,j} = f_{n , j}$
2. $j > i$ $f_{i,j} - g_{i , j}$容斥

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2E3 + 10;
ll f[N] , g[N] , w[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m; cin >> n >> m;
	f[0] = 1;
	for (int i = 1; i <= n; i++) {
		cin >> w[i];
		for (int j = m; j >= w[i]; j--) {
			f[j] = (f[j] + f[j - w[i]]) % 10;
		}
	}
	for (int i = 1; i <= n; i++) {
		g[0] = 1;
		for (int j = 1; j <= m; j++) {
			if (w[i] > j)g[j] = f[j];
			else g[j] = (f[j] - g[j - w[i]] + 10) % 10;
			cout << g[j];
		}
		cout << '\n';
	}
}
```



---------

**挂饰**
https://vjudge.d0j1a1701.cc/contest/550928#problem/J

![image-20230403215752703](image-20230403215752703.png)

#### solve

**状态**

$g_{i ,j}$ 考虑前i个物品 ， 挂钩数为j 得到的最大喜悦值。

**状态转移：**

枚举之前的方案 ， 从后往前的更新状态即可。

==发现一些问题==

1. 负数挂钩数也要参与计算。因为最终只需要，所有方案的挂钩数大于0即可。某一个时刻可能不够但是在后续的选择中挂钩就足够了。
2. 挂钩数可能过大：
   1. 此时考虑将值域压缩。因为挂钩数一旦大于n其实和n是等效的。可以并成同一个问题考虑。

对于1：处理要平移值域。

**关于1的其它解决方法：** 
按照挂钩数升序排序。做转移即可。
**原理:**

1. 根据子问题的形式：验证问题的解的正确性： 然后可以得出 ， 显然考虑了所有情况。
2. 考虑了所有合法方案；
   1. 如果当前枚举出负数， 表示当前挂钩数为0 以后也不会补充。枚举过程中的负数方案是不合法的方案。

#### GROW

对解集合的整理优化。

做背包时为什么要对物品进行重新排序？

1. 对枚举顺序的优化。使得枚举最优。

#### code

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
using ll = long long;
const int N = 2010;
const int inf = 2E9 + 10;
ll f[N][N];
struct node {
	int x , y;
	bool operator<(const node& t) const {
		return x > t.x;
	}
} a[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			f[i][j] = -inf;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].y;
	}
	sort(a + 1 , a + n + 1);
	f[0][1] = 0;
	for (int i = 1; i <= n; i++) {
		int x = a[i].x , y = a[i].y;
		for (int j = 0; j <= n; j++)f[i][j] = f[i - 1][j];
		for (int j = 1; j <= n; j++) {
			f[i][min(n, j + x - 1)] = max(f[i][min(n, j + x - 1)], f[i - 1][j] + y);
		}
	}
	ll ans = 0;
	for (int i = 0; i <= n; i++)ans = max(ans, f[n][i]);
	cout << ans << '\n';
}
```

kuangbing基础题单

---------

**Monkey and Banana**

https://vjudge.d0j1a1701.cc/problem/HDU-1069

![image-20230330222740748](image-20230330222740748.png)

#### solve

和紫书中经典的矩形嵌套是同一类型的问题：
建图处理转换成成dag上的dp即可。
注意一些模块的代码编写：

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 35;
using ll = long long;
struct node {
	int l , r , h;
	node(int l_ , int r_ , int h_) {
		l = l_; r = r_; h = h_;
		if (l > r) swap(l , r);
	}
	bool operator> (const node & t)const {
		return l > t.l && r > t.r;
	}
};
int getid(int x) {
	return x / 3 + x % 3;
}
int main()
{
	int n;
	int test = 0;
	while ((scanf("%d" , &n)) && n) {
		test++;
		vector<vector<int>> g(n * 3);
		vector<int> deg(n * 3 , 0);
		vector<node> rec;
		vector<ll> f(n * 3 , 0);
		int c[3] {};
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < 3; j++) {
				scanf("%d" , c + j);
			}
			for (int j = 0; j < 3; j++) {
				rec.push_back(node(c[j] , c[(j + 1) % 3] , c[(j + 2) % 3]));
			}
		}
		for (int i = 0; i < 3 * n; i++)
			for (int j = 0; j < 3 * n; j++) {
				if (rec[i] > rec[j]) {
					g[i].push_back(j);
					deg[j]++;
				}
			}
		//到此完成建图。
		queue<int> que;
		for (int i = 0; i < 3 * n; i++) {
			if (deg[i] == 0) que.push(i);
		}
		vector<int> topo;
		while (que.size()) {
			int u = que.front(); que.pop();
			topo.push_back(u);
			for (auto v : g[u]) {
				deg[v]--;
				if (!deg[v]) que.push(v);
			}
		}
		reverse(topo.begin() , topo.end());
		ll ans = 0;
		for (auto u : topo) {
			for (auto v : g[u]) {
				f[u] = max(f[u] , f[v]);
			}
			f[u] += rec[u].h;
			ans = max(ans , f[u]);
		}
		printf("Case %d: maximum height = %lld\n" , test , ans);
	}
}
```

--------



**Doing Homework**
https://vjudge.d0j1a1701.cc/problem/HDU-1074

![image-20230402132020251](image-20230402132020251.png)

#### solve

观察数据范围：
最基础的状态压缩dp;

**状态**

$f_{s}$表示s状态下 ， 的最佳分数。

**$状态转移：$**

有两种方案，

1. 先枚举小问题的解 ， 更新大问题的解。
   $$
   f_{s|1 << i} = max(f_{s} + max(0 , ddl[j] - sum[s|1<<j]) , f_{s|1<<j});
   $$
   
2. 先枚举大问题的解，枚举所有相关小问题，更新解。
   $$
   f_{s} = max(f_{s^{\wedge }1<<j)} + ddl[j] - sum[s] , f_s)
   $$

注意为了构造字典序最小的解。从小字典序的科目开始枚举：若方案最优， 往后同优方案字典序必然比字典序更大。这样的枚举顺序可以让字典序保持优势。因为路径函数就是记录第一个遇到的优值。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int inf = 1E9;
const int N = 1E6 + 10;
ll ddl[20], nt[20];
void work(int testNo)
{
	int n; cin >> n;
	const int M = 1 << n;
	vector<string>str(n);
	vector<ll>T(M, 0), pre(M, -1), f(M, inf);
	f[0] = 0;
	for (int i = 0; i < n; i++) cin >> str[i] >> ddl[i] >> nt[i];
	for (int i = 1; i < M; i++) {
		for (int j = 0; j < n; j++) {
			if ((i >> j) & 1) {
				T[i] += nt[j];
			}
		}
	}
	for (int s = 0; s < M; s++) {
		for (int i = 0; i < n; i++) {
			if ((s >> i & 1) == 0) {
				int t = f[s] + max(0LL , T[s | 1 << i] - ddl[i]);
				if (f[s | 1 << i] > t) {
					f[s | 1 << i] = t;
					pre[s | 1 << i] = i;
				}
			}
		}
	}
	int s = M - 1;
	stack<int> ans;
	cout << f[s] << '\n';
	while (s) {
		ans.push(pre[s]);
		s ^= 1 << pre[s];
	}
	while (ans.size()) {
		cout << str[ans.top()] << '\n';
		ans.pop();
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

```



----------

**免费馅饼**
https://vjudge.d0j1a1701.cc/problem/HDU-1176
![image-20230402135214651](image-20230402135214651.png)

#### solve

**状态设计：**

$f_{i , j}$从第秒时在i点 ， 之后可以获得的最大的馅饼数。

**状态转移：**

$f_{i , j}$的解中，最近一步的转移分三类。不动 ， 往左走 ，往右走。

$f_{i , j} = max(f_{i + 1, j - 1} , f_{i + 1 . j} , f_{i + 1 , j + 1}) + sum[i][j]$

#### solve code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E5 + 10;

int f[N][20];


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);

	int n;
	while (cin >> n && n) {
		int mx = 0;
		memset(f, 0 , sizeof f);
		for (int i = 1; i <= n; i++) {
			int  t , x;
			cin >> x >> t;
			x++;
			mx = max(mx , t);
			f[t][x]++;
		}
		for (int i = mx; i >= 0; i--) {
			for (int j = 1; j <= 11; j++)
				f[i][j] = max({f[i + 1][j - 1] , f[i + 1][j] , f[i + 1][j + 1]}) + f[i][j];
		}
		cout << f[0][6] << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### code

下面这一份，死活不知什么地方出错。
应该重新审视状态转换方程的正确性。

**上下两份的主要区别：**
为了防止时间过于离散，造成计算资源的浪费。
分阶段的进行考虑：

关注每一有馅饼掉落的时间。
然后进行了一下相当模糊的转移：

集中于：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E5 + 10;
struct node {
	int t;
	int x;
	bool operator<(const node& tt) {
		return t < tt.t;
	}
} a[N];

int main()
{
	int n;
	while (scanf("%d" , &n) , n) {
		for (int i = 0; i < n; ++i) {
			scanf("%d%d" , &a[i].x , &a[i].t);
		}
		sort(a , a + n);
		int f[100] {} , pre[100] {} , nxt = a[n - 1].t;
		for (int i = n - 1; i >= 0; --i) {
			int d = nxt - a[i].t;
			d = min(d , 10);
			nxt = a[i].t;
			for (int j = 0; j < 20; j ++)
				pre[j] = f[j];
			for (int j = 0; j < 11; ++j) {
				for (int k = -d; k <= d; ++k) {
					if (j + k < 0 || j + k > 10)continue;
					f[j] = max(f[j] , pre[j + k]);
				}
			}
			f[a[i].x]++;
		}
		printf("%d\n" ,  max({f[4] , f[5] , f[6]}));
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



## 最少拦截系统

 https://vjudge.d0j1a1701.cc/problem/HDU-1257

![image-20230402215714185](image-20230402215714185.png)

#### solve

考虑一个拦截系统怎么最优的拦截导弹：
能选就选： 证明如下：

------------

？？



------------

然后转换成求最长下降子序列问题：


#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 3E4 + 10;
const int inf = 1E9;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	while (cin >> n) {
		vector<int> a(n + 1);
		vector<int> d(n + 10, inf);
		d[0] = 0;
		for (int i = 1; i <= n; i++)
			cin >> a[i];
		int ans = 0;
		for (int i = 1; i <= n; i++) {
			int low = 0, high = ans + 1;
			while (low < high) {
				int mid = (low + high) / 2;
				if (d[mid] >= a[i]) {
					high = mid;
				}
				else low = mid + 1;
			}
			ans = max(ans, low);
			d[low] = a[i];
		}
		cout << ans << '\n';
	}
}
```



