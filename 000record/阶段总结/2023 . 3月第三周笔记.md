### 2023第三周

打codeforce是为了上分，积累更多的模型，掌握更多的思考方法，思考思路：
近期UVA开放，尝试板刷kuangbing题单。比较一些和平常的方法之间有什么差别。
凭自己直观的感觉，自己的目标是：
自己主攻的是离散模型。几点目标：

1. 强大的离散模型解的探究能力
   1. 指导dp设计
   1. 指导性质挖掘。
2. 对于非离散模型，比如概率等等，摸清竞赛中的难度。借这个学期的概率论， 把概率dp，概率计算给完成。
3. 追求更严格的概念。打造坚固的体系。

搜索 ， 字符串 ， 图论，进制模型， 基础的数据结构优化.....
他奶奶滴！！

蠢蛋学算法：

1. 图论
   1.  [基环树.md](..\Logrithm\图论\基环树\基环树.md) 
   1.  
2. 补数学：
   1.  [组合板子.md](..\Logrithm\数学\组合计数\组合板子.md) 
3. 搜索

   1.  [baic of dfs.md](..\Logrithm\搜索\DFS\baic of dfs.md) 
   2.  [双向搜索.md](..\Logrithm\搜索\DFS\双向搜索.md) 
   3.  [迭代加深.md](..\Logrithm\搜索\DFS\迭代加深.md) 
   4.  [双端队列.md](..\Logrithm\搜索\BFS\双端队列BFS\双端队列.md) 

4. 语言黑科技
   1.  [stl.md](..\programming language\C++&&C\basic of lanuge\stl\stl.md) （新录入bitset）
   2.  [库中算法函数使用.md](..\programming language\C++&&C\basic of lanuge\库中算法函数使用.md) 
5. dp
   1.  [单调队列优化.md](..\Logrithm\动态规划\动态规划优化\单调队列优化.md) （上周的题）

**麻蛋刷题**

蓝书

1. 搜索
   1. .dfs
      1. [Sudoku.md](..\Logrithm\搜索\DFS\典型\Sudoku.md) 
      2. [Sticks.md](..\Logrithm\搜索\DFS\典型\Sticks.md) 
      3. [生日蛋糕.md](..\Logrithm\搜索\DFS\典型\生日蛋糕.md) 
      4. [加成序列.md](..\Logrithm\搜索\DFS\典型\加成序列.md) 
      5. [非常可乐.md](..\Logrithm\搜索\BFS\problems\非常可乐.md) 
      6. [小猫爬山.md](..\Logrithm\搜索\DFS\典型\小猫爬山.md) 
      7. [送礼物.md](..\Logrithm\搜索\DFS\典型\送礼物.md)
   2. bfs
      1.  [Bloxorz I.md](..\Logrithm\搜索\BFS\problems\Bloxorz I.md) 
      2.   [Pots.md](..\Logrithm\搜索\BFS\problems\Pots.md) 
      3.   [电路维修.md](..\Logrithm\搜索\BFS\双端队列BFS\problems\电路维修.md) 

codeforces

1. 1500
   1.  [G. Garage.md](..\problems\codeforces\1400-1600\数论\各种运算\mod\G. Garage.md) (数学)
   2.  [C. Line Empire.md](..\problems\codeforces\1400-1600\贪心和执行\C. Line Empire.md) 
2. 2023.3.14
   1.  [F. Train Splitting.md](..\problems\codeforces\1700\构造\图构造\F. Train Splitting.md) 
   2.  [C. Quiz Master.md](..\problems\codeforces\1700\数论\因数问题\C. Quiz Master.md) 



**麻瓜补天：**

codeforces div2.

1.  [C. Pull Your Luck.md](..\problems\codeforces\1400-1600\规律挖掘\mod与循环\C. Pull Your Luck.md) 
2.  [D. Accommodation.md](..\problems\codeforces\1400-1600\贪心和执行\D. Accommodation.md) 
3.  [E. Routing.md](..\problems\codeforces\2000\图论\E. Routing.md) 



-------

**组合数板子**

一共提供了四种求组合数的方法：资料来源于acwing

### **第一种方法：**性质+递推+预处理：

将组合数得计算分解为小规模得问题实现：
$$
C_{r}^{n} = C_{r-1}^{n}+C_{r-1}^{n-1}
$$
最小规模得子问题如$C_{r}^{0},C_{r}^{1}$已知（容易计算。）

然后就可以把所有情况求出来：

#### code

```cpp
const int N_c = 3E3;
const int mod = 1E9 + 7;
int c[N_c][N_c];
void C_init() {
    for (int i = 1; i < N_c; ++i) {
        c[i][0] = c[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
        }
    }
}
//注意范围
//小心me
```

#### tips

1. 数组范围允许。

#### 第二种方法： 逆元+预处理+组合数定义

#### basic

$$
C_{n}^{a}=\frac{n!}{(n-a)!\times b!}
$$

可以考虑先将分母得阶乘法求出。然后求出其逆元（由于mod是一个质数，逆元可以通过费马小定理求出。）

综上：时间复杂度：

$n+alog(a)$: 

[AcWing 886. 求组合数 II-数论-C++ - AcWing](https://www.acwing.com/solution/content/22076/)

#### code

```cpp
using ll = long long;
const int N_c = 1E5 + 10;
const int mod = 1e9 + 7;

int fac[N_c] , infac[N_c];
ll quickly_pow(ll x, ll n, ll p)
{
	ll res = 1;
	while (n > 0)
	{
		if (n & 1)res = res * x % p;
		x = x * x % p;
		n >>= 1;
	}
	return res;
}
void init() {
	fac[0] = infac[0] = 1;
	for (int i = 1; i < N_c; i++)
	{
		fac[i] = 1LL * fac[i - 1] * i % mod;
		infac[i] = 1LL * infac[i - 1] * quickly_pow(i, mod - 2, mod) % mod;
	}
}
int c(int a , int b) {
	return 1LL * fac[a] * infac[b] % mod * infac[a - b] % mod;
}
/*
*记得初始化。
*/
```

————搜索

## DFS                      Defth first search

###  abstract

#### **应用模型：**

1. 树
2. 图
3. 表

模型非常多，但是统一关注的问题：

1. 可以对搜索结构进行一些子结构的分层次划分。
2. 分析搜索方向。
   **时间戳**：深度搜索树的过程中，标记节点的访问次序。
   **树的dfs序** 在对树进行深度优先搜索的过程中：对于每个节点， 递归和回溯前各记录一次该点的序号，最后产生的长度为$2\times N$的节点序列。

**树的深度**

****

**树的重心**：将树中的某一个节点删去，树将会被分成若干个部分。定义$max\_part(x)$表示在删除节点x之后产生的子树中，最大的一颗的大小。使得$max\_part(x)$取得最小的节点p称为树的重心。

**搜索树**：将搜索过程中，不断构造出的所有结构独立看成一个节点。统一它们的关系。

认识搜索树， 来指导自己进行搜索方向设计：把握好两个概念  **层次，分支**。

----

基本例子： [小猫爬山.md](典型\小猫爬山.md) 

#### 剪枝

dfs中的剪枝 ， 是一种减少搜索树规模 、尽早排除搜索树中不必要的分支的一种手段。
**常见的剪枝方法**

1. 优化搜索顺序。关注搜索结构中的一些属性，优先选择对解有利的一种属性。
2. 排除等效冗余： 
3. 可行性剪枝： check当前状态继续搜索下去是否有可能达到终点。
4. 最优性剪枝：关注已经搜索到的最优解。
5. 记忆化：        记录搜索状态的搜索结果。



-------

### **双向搜索**

#### 简介

双向搜索也是一种避免在深层子树上浪费时间的方法。这要求问题中不仅有明确的初态，也要有明确的终态。==从初态和从终态两个点出发各搜索一半状态，产生两颗深度减半的搜索树。在中间交会、组合形成最终的答案。==



#### 图示

<img src="node-1679238345425-1.png" alt="node" style="zoom:50%;" /> 

#### problems

 [送礼物.md](典型\送礼物.md) 

-------

### **迭代加深**

#### **背景**

深度优先搜索的dfs每一次选定一个分支，不断深入 ，直到递归边界才回溯。这种策略带有一定的缺陷。
**特殊情况**
如果每一个节点的分支特别多，那么如果开始就选错了时间，那么就会浪费很多时间。具体关注深搜的具体搜索行为。

**优化角度**

采用迭代加深的方法进行优化：
从小到达限制搜索的深度，如果在当前深度限制下搜索不了答案，就加大深度限制（==加深==）。
==迭代思想：==逐渐加大深度限制。

**缺陷**

随着限制深度的增长，问题规模将会变得非常大。所以使用该方法要保证答案在搜素树较浅层的节点中。

-----

### $stl$

用这个笔记总结出错的细节，以及总结一些黑科技技术。

### $one:\quad map$

##### 出错细节：

- 当map模板的赋值情况如下：
  map<string,s>mmap;
  要注意，数据结构会根据它们的字典序排序区分，查找，不会产生二义性。但是在比较字典序的时候，会花费很多的时间。当串不多，且比较小的时候，考虑用该数据结构管理一些列的字符串集合。此时一般使用字符串哈希，配合管理。

##### 使用技巧

- 当我们确认一个元素确实是存在的时候，我们去查询该关键字指向的卫星数据。有如下方案

  ```CPP
  map<int,int>mmap;
  mmap.insert({1,1});
  int t;
  if(mmap.count(1))
  //first
  t=mmap.find(1)->second;
  //second
  t=mmap[1];
  ```

------

### $two:\quad priority\_queue$

##### 出错细节：

- 默认情况下，优先队列是大顶堆。

  ```
  //小顶堆的定义方式。
  priority_queue<int, vector<int>, greater<int>> que;
  //大顶堆的定义方式
  //默认的方法。
  priority_queue<int>  que；
  //详细按照模板定义的方法
  priority_queue<int,vector<int>,less<int>>que;
  ```

**自定义堆**

### $three\quad vector$

- 注意到队列，栈能用的函数，这里都可以用到。
- 面向问题
  - emplace_back() 和push_back()之间有什么区别。
    - 只要记住emplace_back()效率更高就行。
  - 迭代器的作用。
    - 用来排序，用来遍历。
    - 对于rbegin(),rend()。可以用来逆序排序。降序
    - 对于begin(),end(),可以用来升序。
  - 遍历的方式
    - 使用下标索引即可。
    - 使用for(auto)语句。
- 常见函数汇总。
- 关于访问：
  - front();
    - 首元素。
  - back()
    - 尾元素。
- 关于插入：
  - push_back(),push_front().
    - 插入元素在头部尾部
  - insert(postion,x)
    - 在x位置上插入x的元素。复杂度为$O(n)$
  - emplace_back(x),emplace_front(x);
    - 和前面一样。
- 关于删除
  - clear()
  - pop_back();
  - pop_front();
  - erase(postion);
    - 在postion索引对应的元素。
  - erase(first,end);
    - 删除这一段元素。
- 关于vector的构造函数

> 第一种普通的一维向量。
>
> vector <int>p ( );
>
> 二维数组的构建：
>
> vector<vector<int>> vec;
>
> vector  c( m , vector<char> ( n ) );
>
> vector c( m , 0);      //自动检测类型并且自动完成初始化。构造m个当前提供的变量。
>
> vector <vector<int>> c(10,vector<int>(n));    //当前所有元素的默认值都为参数列给定的元素。

详细情况使用看文章  [atcoder_RANDOM.md](..\..\代码整洁之道\同一想法，不同实现\atcoder_RANDOM.md) 

- 其它一些可能会用到的函数。
  - 等号运算符。来判定两个是否相等。
  - 数据结构中一般都已经重载了该运算符。



###  $Four\quad set$

#### 迭代器的使用

1. 获取迭代器：(定位方式看具体需求。)

`auto iter = rec.begin();`

`iter = rec.lower_bound(val);//使用相关函数定位到对应的迭代器。` 

2. 迭代器使用

遍历：`终点判断：iter != rec.end();`

3. 释放迭代器的空间

注意，释放迭代器之后，释放元素的迭代器失去定义。如下两种情况

- 第一种（错误使用情形！！！）

```cpp
auto iter = rec.lower_bound(val);
rec.erase(iter);
iter ++;
```

会程序很可能会出bug。

- 第二种（正确情形）

```cpp
auto iter = rec.upper_bound(val);

//第一种
if(iter != rec.end())
{
    rec.erase(iter++);
}

//第二种
if(iter != rec.end())
{
    auto temp = iter;
    rec.erase(temp);
    iter++;
}
```

#### 初始化：以及插入

1. 多次插入示例如下：(通过列表的方式进行插入)；

```cpp
set<int>rec;
rec.insert({1 ,2 ,3 ,4});
```

2. 初始化

```cpp
set<int>rec({1 ,2 ,3 ,4 ,5});
```

3. 容器顺序定义

```cpp
set<int , greater<int>>rec;
```

这样意味着，从首到尾，元素变小。

默认下其实是

```cpp\
set<int , less<int>> rec;
```

递增的方式。

同时内置的lower_bound()也会呈现出相反的行为。

##### lower_bound的使用。

```cpp
//示例如下
//test1:
    set<int , greater<int >> rec({1 , 2, 3, 4, 5});
    for (auto i : rec)cout << i << ' ';
    cout << '\n';
    cout << *rec.upper_bound(3) << '\n';
	cout << *rec.lower_bound(3) << '\n';

//test2:
	set<int , less<int>> rec_({1 ,2 ,3 ,4 ,5});
	for(auto i : rec_)cout << i << ' ';
	cout << '\n';
	cout << rec_.upper_bound(3) << '\n';
	cout << rec_.lower_bound(3) << '\n';
```



输出如下：

```out
output1:
5 4 3 2 1 
2
3

output2:
1 2 3 4 5 
4
3
```



### $\large five\quad bitset$

#### 简介

bitset中，就是对实现若干位二进制数功能的结构。其中每八位一个字节，相当于状态压缩的二进制数组，并支持位运算操作。一般进行位运算的时间相当于其中用32位的位运算做一次整体计算。

#### 声明

`bitset<>10000> s;`
其中bitset的模板参数里填写常量。

#### 方法

1. 一般的位运算方法。
2. `count()`统计进制串中有多少1比特。
3. `any/none`检查当前进制串中是否存在/不存在 1
4. set / reset / flip
   1. `set()所有位变成1`
   2. `set(k , v)`把s的第k位改为v ， 即`s[k] = v``
   3. `reset()`将所有位变成0
   4. `flip()`将s的所有位取反
   5. `flip(k)`将第k位取反。

#### 使用tips

集合中的一些运算可以表达为位中的运算。对一个集合状态压缩之后，使用位运算可以利用更小的常数得到一个结果集合中的元素信息。

---------

### $\large  sort$

###### 库函数

- $\#include<algorithm>$

- 快速排序，默认升序排序,默认调用<运算符对应的函数。

```
问题：
  1. 定义降序排序的方法
  2.对于自定义定义的结构怎么对接，实现出自己想要的排序效果？
```

###### 关于问题1：降序

- 对于内置类型的排序。

  > `sort(num,num+10,greater<int>());`

- 对于自定义类型的排序

  - 关于函数设计。关注函数将一个对象放在前面。函数设计功能原理：首先，函数是一个有序的运算。两个比较对象传入参数，经过运算（函数，function），如果为true，那么将第一个参数指向的对像，放在前面，如果为false,那么九讲第二个参数指向的对象放在前面。前后指的是数组的相对位置。

###### 关于问题2：自定义结构的处理。

- $方式一$：自定义函数：

  ```cpp
  struct node{
      int h;
      int w;
  };
  bool cmp(A&a,A&b)
  {
      return a.h*a.w>b.h*b.w;
  }
  ```

- $方式二$: 数据结构中重载比较运算符号<。两种方式都可以:

  ```cpp
  struct node{
      int h;
      int w;
      bool operator<(const node & b) const
      {
          return h*w<b.h*b.w;
      }
  };
  
  或者友元方式，注意两种方式不能共存：
      struct node{
      int h;
      int w;
     friend bool operator<(const node& a;const node & b) const
      {
          return a.h*a.w<b.h*b.w;
      }
  };
  ```

- $方式三$:$lamda$表达式：

  ```cpp
  sort(begin,end,[](A x,A y){return x.w*x.h<y.h*y.w});
  ```

##### 使用细节

1. 提防函数定义不恰当导致的运行错误问题。

如下打算对一个long long 类型的数组进行一个升序排序：

`sort(a,a+n,[&](long long x, long long y){`

`return x>=y;});`

于是就出现了运行错误的问题。

应该写成如下形式：

`sort(a,a+n,[&](long long x, long long y){`

`return x>y;});`





----

###  $\large lower\_bound$

- $lower_bound()$ 函数用于在指定区域内查找不小于目标值的第一个元素
- 两种形式：

```cpp
//在 [first, last) 区域内查找不小于 val 的元素
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,
                             const T& val);
//在 [first, last) 区域内查找第一个不符合 comp 规则的元素
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,
                             const T& val, Compare comp);
```

- 细节
  - 返回一个迭代器，不用管太多，直接定义$auto$接受即可。
  - 如果查找成功，迭代器指向找到的元素；
  - 如果查找失败，迭代器的指向和 last 迭代器相同。

----

### $\large upper\_bound$

- upper_bound() 函数定义在`<algorithm>`头文件中，用于在指定范围$[first,last)$内查找大于目标值的第一个元素

- 两种形式

```cpp
//查找[first, last)区域中第一个大于 val 的元素。
ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,
                             const T& val);
//查找[first, last)区域中第一个不符合 comp 规则的元素
ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,
                             const T& val, Compare comp);
```

----

### $\large binary\_search()$

- binary_search() 函数定义在`<algorithm>`头文件中，用于查找指定区域内是否包含某个目标元素。
- 两种形式；

```cpp
//查找 [first, last) 区域内是否包含 val
bool binary_search (ForwardIterator first, ForwardIterjiangator last,
                      const T& val);
//根据 comp 指定的规则，查找 [first, last) 区域内是否包含 val
bool binary_search (ForwardIterator first, ForwardIterator last,
                      const T& val, Compare comp);
```

- 使用细节
  - 查找成功，返回bool值。
  - 注意要数组要已经排好序。

-----

### $\large memset()$

- ```cpp
  memset(首地址，一个字节的值key，size)；
  ```

- 使用细节。

  - 这里是把一个字节一个字节的初始化。把一个字节全部变为当前的key值。
  - 这里应该使用两位的一个十六进制来实现一个刷。
  - 一般而言有意义的刷是0，-1.其它的都是一些比较大，不特殊的数字。
  - 根据对二进制的理解使用即可。

- 例子

```cpp
memset(f,-1,sizeof f );
//f[0]=-1
memset(f,0,sizeof f );
//f[0]=0;
memset (f, 1 ,sizeof f);
//f[0].一个非常大的整数 二进制的形式为 0101010101010101.
```



### $\large fill()$

作用：Fill range with value
Assigns val to all the elements in the range [first,last).

使用例子：

1. 填充普通的数组

`int a[maxn];`

`fill( a ,a+maxn ,1);`

2. 填充容器，常见的是vector

`vector<int>a;`

`fill(a.begin(),a.end,1);`

3. 二维数组

全部初始化完是

`fill(a,a+sizeof(a),1);`

如果是局部初始化，就要注意定位地址位置，但是这一些段往往不是连在一起的，此时用循环逐一进行初始化。

`int a[maxn][maxm];`

`for(int i=1;i<=n;i++)`

`fill(a[i] , a[i] + m , 1 );`

进行一个初始化即可。

### $\large \_\_builtin系列$

注意builtin是指令集合相关的。并不是c++ , c独有的。可以认为是gcc的私货。所以编译选项中要选择gcc, g++ 而不是clang , vc。否则可能会喜提取compile error

https://blog.csdn.net/zeekliu/article/details/124848210

第二个函数尾缀位ll表示函数的运算对象是long long 类型变量。

1. **__builtin_ctz( )  /  __buitlin_ctzll( )**
   1. 返回括号内数的二进制表示形式中末尾0的个数。
2. **__buitlin_clz( )  /  __buitlin_clzll( )**
   1. 返回括号内数的二进制表示形式中前导0的个数。
3. **__builtin_popcount( )**
   1. 返回括号内数的二进制表示形式中1的个数。
4. **__builtin_parity( )**
   1. 返回括号内数的二进制表示形式中1的个数的奇偶性（偶：0，奇：1）。
5. **__builtin_ffs( )**
   1. 返回括号内数的二进制表示形式中最后一个1在第几位（从后往前）。
   1. 如果没有0.则返回0.否则就是返回二进制串中第一个1的位置。
6. **__builtin_sqrt( ) , __builtin_sqrtf( )**
   1. 快速开平方。
   2. 精确度上，一个4位一个八位。

#### $\large \_\_gcd(x, y)$

显然是求公约数的函数。使用细节，两个变量必须是整数。该函数被放置在algorithm标准库中。

---

## **单调队列**

#### 问题背景

转移过程中，花费时间去查询一个窗口的最大值。在状态迁移的过程中，伴随着等长窗口的移动。

#### 优化思路

优化思路一般有，st表，线段树。但是单调队列，虽然相比于前面的算法思想， 是最不深刻的一种思想，但确实常数最小。定义一些物理量以及概念：

---

$q_{front...tail}$, in , out其表达的意义看英文符号具有自明性。
做出一些变化：

### problems

#### **多重背包3**

http://oj.daimayuan.top/course/8/problem/168
参考博客：https://blog.csdn.net/weixin_72060925/article/details/128714489

  [多重背包问题.md](..\背包dp\背包九讲\多重背包问题.md) 

##### solve

用之前的方法去做，就是一个普通的三重背包问题：
定义状态$f_{i}$表示当前考虑了前某个物品中，总体积为i的最大价值。

根据一般的思路：这里的复杂度应该是：$O(n\times \sum a_i)$
现在考虑使用单调队列，对它进行一些优化：

**定义：**

$f_{i}$ 上一级子问题的dp数组。$g_{i}$表示当前考虑物品的dp数组。

**状态转移**
$$
g_{i}=max(f_{i} , f_{i-w}+v+...+f_{i-j*w}+j*v)
$$

其中j表示选择了多少物品。$j\in[0...a_{now}]$.$a_{now}$当前物品的数量。

**关注现象**
接下来的问题是：将迁移联系成与连续队列最值。

1. 发现对f数组进行mod分组。出现一个类似单调队列优化的结构：
   1. 精准的思考点是，观察出暴力过程中的枚举方式。运算对象信息的计算，可以利用预处理的信息就来快速计算出每次迁移的最大值。
   2. 做一些算数处理，从原数组映射到新的数组。并且单调队列优化就是在新的数组上进行。

![node](node-1678496079449-2.png)

常用的技巧如上，是代换的技巧。那么里面的除法

------------

上述描述是混乱且没有本质的。体会里面的数学原理，数学方法。

--------

**剩下解决的问题：**

1. 单调队列的维护问题：
2. 关注问题，需求；

​			其实就是滑动一个等长的区间，无论任何时刻，都可以正确的得到当前维护区间中的最大值。

3. 具体过程
   1. 进
      1. 将比它小的（看具体情形）元素都弹掉。
   2. 出
      1. 看最大值（队尾）是否为当前元素。如果是就弹掉。
         1. 必然不可能是中间的元素。因为入队的时候，比入队元素小的都要被弹掉。于是，如果当前元素没有被弹走必然是最大值。

-----------

##### code 这一份代码是tle的

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2E4 + 10;
const int inf = 1 << 29;

int que[N] , low , high;
//关于队列的初始化定义怎么处理？
//初始化之后怎么迁移？
ll f[N][2];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	int now = 1;
	for (int i = 1; i <= n; i++) {
		//体积， 价值 ， 可选个数：
		int v , w , l; cin >> v >> w >> l;
		for (int mod = 0; mod < v; mod++) {
			//先把队头的小元素弹出来。
			int low = 0 , high = -1;
			for (int j = mod; j <= m; j += v) {

				//弹出较大值

				if (low <= high && que[low] < j - l * v) low++;
				while (low <= high && f[que[high]][1 - now] - que[high] * w / v <= f[j][1 - now] - j * w / v) high--;
				que[++high] = j;
				f[j][now] = f[que[low]][1 - now] + (j - que[low]) * w / v;
			}
		}
		now = 1 - now;
	}
	cout << f[m][1 - now] << '\n';
}
```

##### 可以过的代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10010;

int dp[N], pre[N], q[N];
int n, m;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 0; i < n; ++i) {
		memcpy(pre, dp, sizeof(dp));
		int v, w, s;
		cin >> v >> w >> s;
		for (int j = 0; j < v; ++j) {
			int head = 0, tail = -1;
			for (int k = j; k <= m; k += v) {

				if (head <= tail && k - s * v > q[head])
					++head;

				while (head <= tail && pre[q[tail]] - (q[tail] - j) / v * w <= pre[k] - (k - j) / v * w)
					--tail;

				if (head <= tail)
					dp[k] = max(dp[k], pre[q[head]] + (k - q[head]) / v * w);

				q[++tail] = k;
			}
		}
	}
	cout << dp[m] << endl;
	return 0;
}
```

实在不理解差别究竟在哪里？

然后一步一步改：

最终改成了如下情况：

1. 主要是将dp更新的方式改了。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E4 + 10;
const int inf = 1 << 29;

int que[N];
//关于队列的初始化定义怎么处理？
//初始化之后怎么迁移？
int pre[N] , dp[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n , m; cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        //体积， 价值 ， 可选个数：
        int v , w , l; cin >> v >> w >> l;
        memcpy(pre , dp , sizeof(dp));
        for (int mod = 0; mod < v; ++mod) {
            //先把队头的小元素弹出来。
            int low = 0 , high = -1;
            for (int j = mod; j <= m; j += v) {

                //弹出较大值

                if (low <= high && que[low] < j - l * v) ++low;
                while (low <= high && pre[que[high]] - (que[high] - mod) / v * w <= pre[j] - (j - mod) / v * w) --high;
                if (low <= high) {
                    dp[j] = max(pre[que[low]] + (j - que[low]) / v * w , dp[j]);
                }
                que[++high] = j;

            }
        }
    }
    cout << dp[m] << '\n';
}
```

**下面这份是很久之前写的，也是顺利过了**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10010, maxv = 10010;
int f[maxn][maxv];
int que[maxv];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        int w, v, s;
        cin >> w >> v >> s;
        for (int tt = 0; tt < w; tt++)
        {
            int l = 0, r = -1;                            //双端队列实现单调队列。
            for (int j = tt, k = 1; j <= m; j += w, k++) //利用k这一个变量可以做一些什么样的记录？
            {
                if (k > s + 1) //代表着曾经有多少个元素进队列了。如果超过了三个就说明一些元素要弹队列。
                {
                    //还要确认当前队头元素是否为弹出的元素。
                    //只要弹出元素和它相等即可。
                    if (que[l] == f[i - 1][j - (s + 1) * w] - (k - (s + 1)) * v)
                        l++;
                }
                while (l <= r && que[r] + k * v < f[i - 1][j]) //滑动窗口对应的数组是什么？                            				  //添加的过程中可以加一些处理，这样并不会影响它们的次序同时也可以还原真实量的大小
                    r--;
                que[++r] = (f[i - 1][j] - k * v);
                f[i][j] = que[l] + k * v;
            }
        }
    }
    cout << f[n][m] << '\n';
}
```

**集中困惑点**

1. 对单调队列原理感到困惑：

   1. 从最简单的问题开始考虑：一个静态连续的数字序列上，滑动窗口同时逐步求出最值。
   2. 转移到上述问题：

2. 对上述复杂的转移方程的处理感到困惑。

   1. 关于转移方程的认知理解。
   2. 使用了什么样的数学处理方法？

------

1. 对于最后一份代码：使用了一种偏移还原的思维：

2. dls(y总)的思路，就是换了个元，进行处理：将涉及的dp数组中的索引做一个整体考虑。然后就将max运算的对象转变成了下面一种形式：

![node](node-1678544037180-4.png)

然后基于上面的启发：第一份代码改动如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2E4 + 10;
const int inf = 1 << 29;

int que[N] , low , high;
//关于队列的初始化定义怎么处理？
//初始化之后怎么迁移？
ll f[N][2];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	int now = 1;
	for (int i = 1; i <= n; i++) {
		//体积， 价值 ， 可选个数：
		int v , w , l; cin >> v >> w >> l;
		for (int mod = 0; mod < v; mod++) {
			//先把队头的小元素弹出来。
			int low = 0 , high = -1;
			for (int j = mod; j <= m; j += v) {

				//弹出较大值

				if (low <= high && que[low] < j - l * v) low++;
				while (low <= high && f[que[high]][1 - now] - 1.0 * que[high] * w / v <= f[j][1 - now] - 1.0 * j * w / v) high--;
				que[++high] = j;
				f[j][now] = f[que[low]][1 - now] + (j - que[low]) * w / v;
			}
		}
		now = 1 - now;
	}
	cout << f[m][1 - now] << '\n';
}
```

于是就过了。

**所做的换元方法是数学上的一般除法，但是事实上计算机处理方式是整除。要注意控制精度，防止精度丢失。**



#### 第二个问题：燃烧烟花：

**C. Watching Fireworks is Fun**

[Problem - 372C - Codeforces](https://codeforces.com/problemset/problem/372/C)

[CF Round #219 (Div. 1) C, Watching Fireworks is Fun - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/426)

**问题简介**

去到任意地方：

初始可以在任意地点：然后每一个时间单元可以去w单位内的任意地点：每个时刻在不同的地点看烟花会收获到不同大小的幸福值。问m个烟花放完之后，可以得到的最大快乐值是多少：可能为负数：

**solve**

状态设计：

$dp_{i , j}$表示第i个时刻在j街道处的最大快乐值是多少：

**状态转移方程：**
$$
dp_{i,j}=max(dp_{i-1,j-0..(t-1)*d,t*d},dp_{i-1,j+0..(k - 1)*d,k*d})+b_i-|a_i-j|
$$
对于一个$dp_{i,j}$的计算，可以使用一个单调队列进行优化。可以在$O(1)$的时间之内完成计算：

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 300010;
ll f[N][2];
int q[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n , m , d;
    cin >> n >> m >> d;
    int now = 1;
    int t1 = 1;//上一轮放烟花的时间。
    while (m--) {
        int a , b , t; cin >> a >> b >> t;
        //时间间隔之内可以移动的单向移动的范围
        int D = min(1LL * n , 1LL * (t - t1) * d);
        t1 = t;
        int low = 1 , high = 0 ;
        auto add = [&](int x) {
            while (low <= high && f[x][now ^ 1] >= f[q[high]][now ^ 1])
                high --;
            q[++high] = x;
        };
        for (int i = 1; i <= D; i++)add(i);
        for (int i = 1; i <= n; i++) {
            if (i + D <= n) add(i + D);
            while (low <= high && q[low] < i - D)low++;
            f[i][now] = f[q[low]][1 - now] + b - abs(a - i);
        }
        now = 1 - now;
    }
    ll ans = -1E18;
    for (int i = 1 ; i <= n; i++) {
        ans = max(ans  , f[i][1 - now]);
    }
    cout << ans << '\n';
}
```

---------



[P2254 [NOI2005\] 瑰丽华尔兹 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2254)

# [NOI2005] 瑰丽华尔兹

## 题目背景

你跳过华尔兹吗？当音乐响起，当你随着旋律滑动舞步，是不是有一种漫步仙境的惬意？

众所周知，跳华尔兹时，最重要的是有好的音乐。但是很少有几个人知道，世界上最伟大的钢琴家一生都漂泊在大海上，他的名字叫丹尼・布德曼・T.D.・柠檬・1900，朋友们都叫他 1900。

1900 在 20 世纪的第一年出生在往返于欧美的邮轮弗吉尼亚号上。很不幸，他刚出生就被抛弃，成了孤儿。1900 孤独的成长在弗吉尼亚号上，从未离开过这个摇晃的世界。也许是对他命运的补偿，上帝派可爱的小天使艾米丽照顾他。可能是天使的点化，1900 拥有不可思议的钢琴天赋：从未有人教，从没看过乐谱，但他却能凭着自己的感觉弹出最沁人心脾的旋律。当 1900 的音乐获得邮轮上所有人的欢迎时，他才 8 岁，而此时，他已经乘着海轮往返欧美大陆 50 余次了。

虽说是钢琴奇才，但 1900 还是个孩子，他有着和一般男孩一样的好奇和调皮，只不过更多一层浪漫的色彩罢了：这是一个风雨交加的夜晚，海风卷起层层巨浪拍打着弗吉尼亚号，邮轮随着巨浪剧烈的摇摆。船上的新萨克斯手迈克斯・托尼晕船了，1900 招呼托尼和他一起坐到舞厅里的钢琴上，然后松开了固定钢琴的闸，于是，钢琴随着海轮的倾斜滑动起来。准确的说，我们的主角 1900…

## 题目描述

不妨认为舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。

艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。

## 输入格式

输入文件的第一行包含 $5$ 个数 $N$, $M$, $x$, $y$ 和 $K$。$N$ 和 $M$ 描述舞厅的大小，$x$ 和 $y$ 为钢琴的初始位置；我们对船体倾斜情况是按时间的区间来描述的，且从 $1$ 开始计算时间，比如 “在 $[1, 3]$ 时间里向东倾斜，$[4, 5]$ 时间里向北倾斜”，因此这里的 $K$ 表示区间的数目。

以下 $N$ 行，每行 $M$ 个字符，描述舞厅里的家具。第 $i$ 行第 $j$ 列的字符若为 `.`，则表示该位置是空地；若为 `x`，则表示有家具。

以下 $K$ 行，顺序描述 $K$ 个时间区间，格式为：$s_i t_i d_i (1 \leq i \leq K)$。表示在时间区间 $[s_i, t_i]$ 内，船体都是向 $d_i$ 方向倾斜的。$d_i$ 为 $1$, $2$, $3$, $4$ 中的一个，依次表示北、南、西、东（分别对应矩阵中的上、下、左、右）。输入保证区间是连续的，即

$s_1 = 1$

$s_i = t_{i-1} + 1 (1 < i \leq K)$

$t_K = T$

## 输出格式

输出文件仅有 $1$ 行，包含一个整数，表示钢琴滑行的最长距离 (即格子数)。

## 样例 #1

### 样例输入 #1

```
4 5 4 1 3
..xx.
.....
...x.
.....
1 3 4
4 5 1
6 7 3
```

### 样例输出 #1

```
6
```

## 提示

钢琴的滑行路线：

 ![](https://cdn.luogu.com.cn/upload/pic/1307.png) 

钢琴在“×”位置上时天使使用一次魔法，因此滑动总长度为 $6$。

【数据范围】

$50\%$ 的数据中，$1\leq N, M\leq 200，T\leq 200$；

$100\%$ 的数据中，$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。

------------

**solve**

**状态定义**

$f_{i , j , k}$表示第k次倾斜之后，在（x , y )点时， 钢琴经历过的滑动距离：

**状态转移方程**

四种方向的状态迁移都是类似的。差别在于， 操作了不同的行与列， 滚动数组优化下，滚动的方向有点不一样。详细理解看代码就可以容易的体会到位：

*不妨先考虑向第k段的时候滑动：*

$f_{i , j ， k} = max(f_{i-(0..d),j,k-1}+d)$

**滚动数组优化如下：**

$f_{i , j}=max(f_{i-(0....d),j}+d)$

注意转移方向是从下往上。这样才可以保证计算某个状态时，想迁移的子问题没有丢失，以及某些子问题用完即丢。

#### code	

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2E2 + 10;
char G[N][N];
int f[N][N];
int ans;
struct XYZ {int x/*max值*/ ; int y;/*用以表示该值在序列下标*/} q[N];
int dx[5] {0 , -1 , 1 , 0 , 0} , dy[5] { 0 , 0 , 0 , -1 , 1};
void solve(int x, int y , int d , int to , int n) {
	//接下来的任务是，统一各种方向以及处理情况。
	int low = 0 , high = -1;
	for (int i = 1; i <= n; ++i) {
		if (G[x][y] == 'x')low = 0 , high = -1;
		else {
			int v = f[x][y] - i;
			while (low <= high && q[high].x <= v) --high;
			while (low <= high && i - q[low].y > d) ++low;
			q[++high] = {v , i};
			f[x][y] = q[low].x + i;
			ans = max(f[x][y] , ans);
		}
		x += dx[to];
		y += dy[to];
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m , k , x , y;
	cin >> n >> m >>  x >> y >> k;
	memset(f , -63 , sizeof f);
	f[x][y] = 0;
	for (int i = 1; i <= n; ++i) cin >> (G[i] + 1);
	for (int j = 1; j <= k; ++j) {
		int x , y , to;
		cin >> x >> y >> to;
		int t = y - x + 1;
		if (to == 1)for (int i = 1; i <= m ; ++i)solve(n , i , t , to , n);
		else if (to == 2)for (int i = 1; i <= m; ++i)solve(1 , i , t , to , n);
		else if (to == 3) for (int i = 1; i <= n; ++i)solve(i , m, t , to , m);
		else for (int i = 1; i <= n; ++i) solve(i , 1 , t , to , m);
	}
	cout << ans << '\n';
}
```



### 搜索

**Sudoku**

https://ac.nowcoder.com/acm/contest/1014/B

#### solve

1. 状态压缩的方式，更容易维护行列中的情况。
2. 优化
   1. 对于一个位置上通过行于列判定选择可选解。使用lowbit运算快速定位到可选数字。
   2. 从可选解少的位置开始填。
3. 注意维护搜索树。

#### 总结

。。。 tm的都是啥啊。卡常被卡麻啦。已经使用了关键的几个优化。

#### code，还是被卡。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
// #define x first
// #define y second
const int N = 10;
int h[10], w[10], g[10] , sum[N][N],  ans[N][N];
int m = 0;
pii arr[N * N];
//从现在在考虑第几个位置。
bool dfs(int now) {
	if (now >= m) {
		//cout << "\n yes \n";
		return true;
	}
	//快速找到符合要求的数字。
	//枚举并且递归：
	/*
	*1. 一位接一位的枚举
	*2. 利用lowbit的技巧枚举。
	*/
	int x = arr[now].first, y = arr[now].second;
	int id = x / 3 * 3 + y / 3;
	int can = h[x] & w[y] & g[id];
	while (can != 0) {
		//cout << to << '\n';
		int temp = can & -can;
		int to = __builtin_ffs(temp);
		h[x] ^= temp;
		w[y] ^= temp;
		g[id] ^= temp;
		can = can -  temp;
		ans[x][y] = to;
		if (dfs(now + 1))
			return true;
		ans[x][y] = 0;
		h[x] ^= temp;
		w[y] ^= temp;
		g[id] ^= temp;
	}
	// for (int i = 0; i < 9; i++) {
	// 	if (!(can >> i & 1)) {
	// 		ans[x][y] = i + 1;
	// 		h[x] ^= (1 << i);
	// 		w[y] ^= (1 << i);
	// 		if (dfs(now + 1))return true;
	// 		ans[x][y] = 0;
	// 		h[x] ^= (1 << i);
	// 		w[y] ^= (1 << i);
	// 	}
	// }
	return false;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0) , cout.tie(0);
	while (true) {
		string s;
		cin >> s;
		if (s == "end")break;
		//一堆 ，初始化。
		for (int i = 0 ; i < 9; ++i) {
			h[i] = w[i] = g[i] = 0;
			for (int j = 0; j < 9; ++j)ans[i][j] = 0;
		}
		for (int i = 0; i < 9; ++i) {
			for (int j = 0; j < 9; ++j) {
				char t = s[i * 9 + j];
				if (t != '.') {
					//保存答案数组。
					ans[i][j] = t - '0';
					h[i] |= 1 << (ans[i][j] - 1);
					w[j] |= 1 << (ans[i][j] - 1);
					int id = i / 3 * 3 + j / 3;
					g[id] |= 1 << (ans[i][j] - 1);
				}
			}
		}
		// for (int i = 0; i < 9; i++) {
		// 	for (int j = 0; j < 9; j++)
		// 		cout << ans[i][j] << " \n"[j == 8];
		// }
		m = 0;
		int t = (1 << 9) - 1;
		for (int i = 0; i < 9; ++i) {
			h[i] ^= t;
			w[i] ^= t;
			g[i] ^= t;
		}
		for (int i = 0; i < 9; ++i) {
			for (int j = 0; j < 9; ++j) {
				if (ans[i][j] == 0) {
					arr[m++] = { i , j };
					int id = i / 3 * 3 + j / 3;
					int t = h[i] & w[j] & g[id];
					//记录当前有多少个位置可以选择。
					sum[i][j] = __builtin_popcount(t);
				}
			}
		}
		//用1来表示，减少常数。
		//111111111
		sort(arr, arr + m, [&](const auto & a, const auto & b) {
			return sum[a.first][a.second] < sum[b.first][b.second];
		});
		dfs(0);
		for (int i = 0; i < 9; ++i)
			for (int j = 0; j < 9; ++j) {
				cout << ans[i][j] /*<< " \n"[j == 8]*/;
			}
		cout << '\n';
	}
}
```

#### 卡常优化角度：

1. inline大法。
2. 减少加减乘除位运算。
   1. 用空间换时间。
   2. 可以不用`__builtin_popcount()`等等。直接预处理即可。

#### 上网找的大佬代码

这份代码甚至连输入输出优化都没有开。

```cpp
#include<iostream>
#include<algorithm>
#define lowbit(x) ((x) & (-x))
using namespace std;

const int N = 9, M = 1 << N;

//ones表示0-2^9里每个数有多少个1，map快速地找出这行哪一列可以填，比如map[(10)2] = 1就知道第二列可以填1
int ones[M], map[M];
//分别表示行，列，大方格子有哪些数字没有填
int rows[N], cols[N], cell[3][3];
char s[100];

//is_set = true则在x, y填上t, 否则则把x,y处的数字删掉, t 是0-8
void draw(int x, int y, int t, int is_set) {
	if (is_set)  s[x * N + y] = '1' + t; //t 是0-8
	else s[x * N + y] = '.';

	int v = 1 << t;
	if (!is_set) v = -v;

	//如果某位没被放，则它的二进制位应该是1， 所以应该减去v
	//如果放了，它的二进制应该是0，则经过上面的取反，负负得正，-v实际上就是把二进制0变为1
	rows[x] -= v;
	cols[y] -= v;
	cell[x / 3][y / 3] -= v;
}

//x行y列可以填哪个数字, 最后得到2^i + 2^j..+..，这些i, j就是可以填的数字，最后通过map[2^i]来得到这个数字
int get(int x, int y) {
	return rows[x] & cols[y] & cell[x / 3][y / 3];
}

int init() {
	//cnt表示还剩多少个数字没有填
	int cnt = 0;
	//初始状态state的9位二进制全是1
	int state = (1 << N) - 1;

	//如果row[0] = 111111111 代表第一行可以填9个数, 这里行号是0-8
	fill(rows, rows + N, state);
	fill(cols, cols + N, state);
	fill(cell[0], cell[0] + N, state);

	for (int i = 0, k = 0; i < N; i++) {
		for (int j = 0; j < N; j++, k++) {
			if (s[k] != '.') {
				draw(i, j, s[k] - '1', true);
			}
			else cnt++;
		}
	}

	return cnt;
}

bool dfs(int cnt) {
	//填完所有数字，则返回
	if (!cnt) return true;
	//最多可以填多少个数字
	int minv = 10;
	int x, y;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (s[i * N + j] == '.') {
				//可以填的数字状态，如010001，是1则表示可以填
				int state = get(i, j);
				//选一个1的个数最少的，这样的分支数量最少
				if (ones[state] < minv) {
					minv = ones[state];
					x = i, y = j;
				}
			}
		}
	}

	//依次做lowbit操作，选择每个分支
	for (int i = get(x, y); i ; i -= lowbit(i)) {

		//这个t就是要填充的数字
		int t = map[lowbit(i)];

		//填这个数字
		draw(x, y, t, true);

		//这次填充成功，则返回
		if (dfs(cnt - 1)) return true;

		//失败则回溯
		draw(x, y, t, false);
	}

	return false;
}

int main() {
	//打表，快速地知道可以哪一个数字
	for (int i = 0; i < N; i++) map[1 << i] = i;

	//ones记录每个状态有多少个1，用于选择分支少的开始搜索, 其中M = 1 << N
	for (int i = 0; i < M; i++) {
		for (int j = i; j; j -= lowbit(j)) {
			ones[i] += 1;
		}
	}

	while (cin >> s, s[0] != 'e') {
		int k = init();
		dfs(k);
		puts(s);
	}

	return 0;
}
```

-------

**Sticks**

[A-Sticks_0x23 搜索-剪枝 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1015/A)

将小木棍分成若干组等长的木棍。

#### solve

**最暴力的做法：**
枚举原始产长度然后，确定分组，然后就开始搜索。搜索状态设计：

1. 硬颈瓶好地原始长度，正在拼地原始木棒的当前长度，每个木棍的使用情况。。
2. 边界设计： 木棒数量达标。无法继续拼接而以失败告终。

**优化角度**

1. 优化搜索顺序。优先放大的木棍。
2. 排除等效冗余。
   1. 限制新加入的木棍的长度是递减的。防止搜索过程中出现先拼长度x ， 再拼y。和先拼y再拼x出现的等效构造。（其实在1中已经排好了序。）用一个搜索树的角度来看。
   2. 如果基于某个状态搜索失败了，可以获得一些信息。比如：
      1. 如果当前分支搜索失败，记录最近一次尝试拼接的木棍长度。说明拼接上该长度的木棍最终都不会成功拼接。反证法证明。
      2. 如果当前原始木棒中尝试拼入的第一根木棍的递归分支返回失败。直接判断当前分支失败，立刻回溯。
      3. 如果当前原始木棍中拼入一根木棍后，木棍恰好被拼接完整，并且接下来拼接剩余原始木棒的递归分支返回失败，那么直接判定当前分支失败。反证法证明。


首先是对解空间的宏观挖掘。和dp是类似的能力：

1. 如果当前分支搜索失败了。可以获得什么启发？

#### code

无语，第一次交的代码不懂哪里常数大了。y总的代码10ms内过。

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 70;

int n;
int sum, length;
int sticks[N];
bool st[N];

bool dfs(int u, int cur, int start)
{
    if (u * length == sum) return true;
    if (cur == length) return dfs(u + 1, 0, 0);

    for (int i = start; i < n; i ++ )
    {
        if (st[i]) continue;
        int l = sticks[i];
        if (cur + l <= length)
        {
            st[i] = true;
            if (dfs(u, cur + l, i + 1)) return true;
            st[i] = false;

            // 剪枝3 如果是第一个木棒失败，则一定失败
            if (!cur) return false;

            // 剪枝4 如果是最后一个木棒失败，则一定失败
            if (cur + l == length) return false;

            // 剪枝2 跳过相同木棒
            int j = i;
            while (j < n && sticks[j] == l) j ++ ;
            i = j - 1;
        }
    }


    return false;
}

int main()
{
    while (cin >> n, n)
    {
        sum = 0, length = 0;
        memset(st, false, sizeof st);

        for (int i = 0; i < n; i ++ )
        {
            cin >> sticks[i];
            if (sticks[i] > 50) continue;
            sum += sticks[i];
            length = max(length, sticks[i]);
        }

        // 剪枝：优化搜索顺序
        sort(sticks, sticks + n);
        reverse(sticks, sticks + n);

        for (int i = 0; i < n; i ++ )
            if (sticks[i] > 50)
                st[i] = true;

        while (true)
        {
            if (sum % length == 0 && dfs(0, 0, 0))
            {
                cout << length << endl;
                break;
            }
            length ++ ;
        }
    }

    return 0;
}
```

#### code2

蓝书上的代码：爆T款

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 10000;
int n , a[N] , v[N] , cnt , len;

// 表示当前第几根木棒 ， 当前木棒的长度 ，考察的最后一个位置。
bool dfs(int stick , int cur_len , int last) {
	//终点条件。
	if (stick > cnt)return true;
	//继续搜索
	if (cur_len == len) return dfs(stick + 1 , 0 , 0);
	int fail = 0;
	for (int i = last; i < n; i++)
		if (a[i] != fail && cur_len + a[i] <= len && v[i] != len) {
			v[i] = len;
			if (dfs(stick , cur_len + a[i] , i + 1)) return true;
			fail = a[i];
			v[i] = 0;
			//第三个剪枝
			if (cur_len == 0 ||  cur_len + a[i] == len)return false;
		}
	return false;
}



int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	while (cin >> n && n) {
		int sum = 0;
		for (int i = 0; i < n; i++) {
			cin >> a[i];
			sum += a[i];
		}
		sort(a , a + n /*, greater<int>()*/);
		reverse(a , a + n);
		// for (int i = 0; i < n; i++) {
		// 	cout << a[i] << " \n"[i == n - 1];
		// }
		for (len = a[0]; len <= sum; len++) {
			if (sum % len)continue;
			cnt = sum / len;
			if (dfs(1 , 0 , 0))break;
		}
		cout << len << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

**生日蛋糕**

[B-生日蛋糕_0x23 搜索-剪枝 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1015/B)

#### solve

1. 搜索框架是什么？

   往前枚举第i层。维护总体积以及上一层的半径高度。

2. 剪枝优化的角度。

   ​       从上到下标记为：1....dep -1

   1. 上下界限剪枝。确定两个状态变量的范围。
      $$
      R\in[dep,min(\sqrt{N-v},R_{dep+1}-1)]\\
      H\in[dep,min((N-v))/R^2,H_{dep+1}-1]
      $$

   2. 优化搜索顺序。倒叙搜索。

   3. 可行性剪枝：

      1. 什么情况时，必然无解？
         1. 更上层的状态贪心的选取最小：剩下的状态无论怎么构造，体积都不满足要求。

   4. 最优性剪枝：

      1. 如果当前已知的表面积已经大于等于已经搜索到的答案。
      2. 一些关于数学性质挖掘。如果已经确定了下体积，下面积。那么就可以找到最终体积的一个下界。与当前已经搜索到的最优答案进行比较，产生了剪枝的机会。

      $$
      体积情况\\
      V=n-v=\sum _{i=1}^{dep-1} r_i^2\times h_{i}^2\\
      侧面积情况：\\
      S=2\sum _{i=1}^{dep -1}r_i\times h_i \\
      S=\frac{2}{r_{dep}}\sum_{i=1}^{dep-1}h_{k}\times r_{k}\times r_{dep} \ge \frac{2}{r_{dep}}\sum_{i=1}^{dep-1}h_{i}*r_{i}^2\ge\frac{2(n-v)}{r_{dep}}
      $$

      $$
      s :当前表面积：\\
      \frac{2(n-v)}{r_{dep}}+s大于已经搜到的答案时就可以剪枝。
      $$

      

**更深刻的把握模型：**

搜索算法面对的状态可以看作一个多元组，其中每一元都是问题状态空间中的一个维度。

1. 针对每个维度与该维度的边界条件，加以缩放，推导，得出一个相应的不等式，来减少搜索树分支的扩张。
2. 对未来需要花费的代价需要进行预算。
3. 结合各维度的联系得到更加精准的剪枝。



#### code

高仿y总的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 30;
const int inf = 1E9;

int n , m;
//表示最小面积 ， 表示最小体积。
int mins[N] , minv[N];
int H[N] , R[N];//表示第i层的高度体积情况。
int ans = inf;

//dep当前的层数 , s当前的总体积。当前的总体积。
void dfs(int dep , int s , int v) {
	//终点情况
	//1.可行 —— 体积角度
	if (v + minv[dep] > n)return;
	//最优性剪枝
	if (s + mins[dep] >= ans) return;
	//最优性剪枝2
	if (2 * (n - v) / R[dep + 1]  + s >= ans) {return;}
	if (!dep ) {
		if (v == n)
			ans = s;
		return;
	}
	for (int r = min((int)sqrt(n - v) , R[dep + 1] - 1); r >= dep; r--)
		for (int h = min((n - v) / r / r , H[dep + 1] - 1); h >= dep; h--) {
			if (dep == m) s = r * r;
			H[dep] = h; R[dep] = r;
			dfs(dep - 1 , s + 2 * r * h , v + r * r * h);
		}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		minv[i] = minv[i - 1] + i * i * i;
		mins[i] = mins[i - 1] + 2 * i * i;
	}
	R[m + 1] = H[m + 1] = inf;

	dfs(m , 0 , 0);
	if (ans == inf) ans = 0;
	cout << ans << '\n';
}
```



**加成序列**

[170. 加成序列 - AcWing题库](https://www.acwing.com/problem/content/172/)

#### solve

观察这一个模型发现：

1. 用二进制的角度。先在数组中搞出1 2 4 8 16 32 64 利用上述的做多4个就可以组合出100 以内的所有情况。因此m小于等于14
2. 对于某一个节点，分支特别的多。下方的搜索框架，确定一个点，要枚举前面数组的所有的二元组。分支达到10000以上的级别

因此上述符合迭代加深擅长模型：

**步骤**

1. 搜索框架：
   1. 当前构造到了第几个数字。
   2. 利用当前已经构造出的序列来枚举下一个数。
2. 剪枝方案
   1. 顺序剪枝。从大到小枚举方案。
   2. 判断重复。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 110;

int n;
int path[N];
int depth = 1;

bool dfs(int dep) {
	if (dep == depth)
		return path[dep - 1] == n;
	vector<bool> rec(n + 1 , 0);
	for (int i = dep - 1; i >= 0; i--)
		for (int j = i; j >= 0 ; j--) {

			int t = path[i] + path[j];
			if (t > n || rec[t] || t <= path[dep - 1]) continue;
			rec[t] = true;
			path[dep] = t;
			if (dfs(dep + 1))return true;
		}
	return false;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	path[0] = 1;
	while (cin >> n , n) {
		depth = 1;
		while (!dfs(1)) {
			depth++;;
		}
		for (int i = 0 ; i < depth; i++) {
			cout << path[i] << " \n"[i == depth - 1];
		}
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

**非常可乐**

[非常可乐 - HDU 1495 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/HDU-1495)

https://vjudge.csgrandeur.cn/problem/HDU-1495/origin

[非常可乐 - HDU 1495 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/HDU-1495)



#### 简介：

![image-20230315164516979](image-20230315164516979.png)

#### 20mins

探究可能出现的各种行为：

1. fi   ->  se ， se被倒满。
2. fi   -> se ,      fi倒空。
   枚举第一个杯子到第二个杯子，上述两种情况。一共有12种可能

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 200;
const int inf = 1E9;
bool vis[N][N][N];

struct node {
	int a;
	int b;
	int c;
	int now;
};

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int s , n , m;
	while (true) {
		cin >> s >> n >> m;
		if (s == 0 && n == 0 && m == 0) {
			break;
		}

		if (s % 2) {cout << "NO\n"; continue;}
		for (int i = 0 ; i <= s; i++)
			for (int j = 0 ; j <= n ; j++)
				for (int k = 0; k <= m; k++)
					vis[i][j][k] = false;

		//然后开始bfs搜索。
		queue<node> que;
		que.push({s, 0 , 0 , 0});
		int ans = inf;
		while (que.empty() == false) {
			node t = que.front(); que.pop();
			int a = t.a , b = t.b , c = t.c , now = t.now;
			if (a == b + c || c == a + b || b == a + c) {
				int t = 0;
				if (a == s / 2)t++;
				if (b == s / 2) t++;
				if (c == s / 2)t++;
				if (t == 2) {
					ans = now;
				} else ans = now + 1;
				break;
			}
			//然后就是一堆分类讨论：
			int ta = a, tb = b, tc = c, tn = now + 1;
			//a - > b; 1 (b满)
			if (a >= n - b) {
				ta = a - (n - b);
				tb = n;
				tc = c;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// a - > b a空
			if (a <= n - b) {
				ta = 0;
				tb = b + a;
				tc = c;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			//a - > c c满
			if (a >= m - c) {
				ta = a - (m - c);
				tb = b;
				tc = m;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// a - > c a空
			if (a <= m - c) {
				ta = 0;
				tb = b;
				tc = c + a;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}

			// b - > a a满；
			if (b >= s - a) {
				ta = s;
				tb = b - (s - a);
				tc = c;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// b - > a b空
			if (b <= s - a) {
				ta = a + b;
				tb = 0;
				tc = c;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			//b - > c c满
			if (b >= m - c) {
				ta = a;
				tb = b - (m - c);
				tc = m;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// b -> c b空
			if (b <= m - c) {
				ta = a;
				tb = 0;
				tc = c + b;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}

			//////
			// c - > a a满；
			if (c >= s - a) {
				ta = s;
				tb = b;
				tc = c - (s - a);
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// c - > a c空
			if (c <= s - a) {
				ta = a + c;
				tb = b;
				tc = 0;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			//c - > b b满
			if (c >= n - b) {
				ta = a;
				tb = n;
				tc = c - (n - b);

				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
			// c -> b c空
			if (c <= n - b) {
				ta = a;
				tb = b + c;
				tc = 0;
				if (vis[ta][tb][tc] == false) {
					vis[ta][tb][tc] = true;
					que.push({ta , tb , tc , tn});
				}
			}
		}
		if (ans != inf) {
			cout << ans << '\n';
		} else {
			cout << "NO\n";
		}
	}
}
```

~~有一个特殊处理， 需要刚好分成两杯？不理解~~

**小猫爬山**
https://ac.nowcoder.com/acm/contest/1014/A

#### solve

数据范围比较小尝试枚举所有的可能。

1. 怎么暴力枚举？
   1. 单纯划分。比较困难 ， 因为管理每一组维护要比较大的花费。
   2. 关注结构更多的属性。枚举到第now个。并且前面的所有的猫已经分成了k组。（组的打标记方式并不会影响结果。因此直接枚举）
      1. 该角度，可以通过回溯，方便维护。并且有序枚举，是比较优秀的枚举方法；
2. 一些小优化：
   1. 顺序上进行优化：减少分支：
      1. 从重的猫先开始枚举。然后可以有效的减少初始的分支数目。这样可以更快的减去不合法解。
   2. 及时剪枝。如果当前枚举状态的cnt已经大于等于ans就没有必要继续枚举下去了。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int a[N] , c[N] , ans = N;
int  n , m;

void dfs(int now , int cnt) {
	if (now == n + 1) {
		ans = min(ans , cnt);
		return;
	}
	//剪枝
	if (cnt > ans) return;
	for (int i = 1; i <= cnt + 1 ; i ++) {
		if (c[i] + a[now] <= m ) {
			c[i] += a[now];
			dfs(now + 1 , cnt + (i > cnt));
			c[i] -= a[now];
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1 , a + 1 + n , greater<int>());
	dfs(1 , 1);
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

**送礼物**

[B-送礼物_0x24 搜索-迭代加深 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1016/B)

#### solve

其实是超大型的背包问题。子问题的重叠概率非常小，用双向搜索，对大部分进行考虑。

**复杂度分析**
直接体会，双向搜索的优越性：

1. 如果暴力直接搜索复杂度将会是：$2^{45}$

双向搜索：将数组分成两部分，分别对这两部分进行深搜。然后得到了一个结果：A数组保存了所有的结果：

1. 对这个数组进行排序。

第二次深搜：对于当前搜索出来的某一个值，二分上一次的数组情况。然后通过当前的数组情况进行一个二分，找到当前方案下一个最接近$2^{31}-1$的解。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = (1 << 24) + 10;
const ll mx = (1LL << 31) - 1;
int n , m;
int w[50];
int rec[N] , cnt = 0;
int k;
int ans = 0;

void dfs1(int u , int sum) {
	if (u == k) {
		rec[cnt++] = sum;
		return;
	}
	if ((ll)sum + w[u] <= m) {
		dfs1(u + 1 , sum + w[u]);
	}
	dfs1(u + 1 , sum);
}

void dfs2(int u , int sum) {
	if (u == n) {

		int id = upper_bound(rec , rec + cnt , m - sum) - rec - 1;
		if (id >= 0 && rec[id] + sum <= m)
			ans = max(ans , rec[id] + sum);
		return;
	}
	if ((ll) sum + w[u] <= m) {
		dfs2(u + 1 , sum + w[u]);
	}
	dfs2(u + 1 , sum);;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> m >> n;
	for (int i = 0; i < n; i++) {
		cin >> w[i];
	}
	sort(w , w + n , greater<int>());
	k = n / 2;
	dfs1(0 , 0);
	sort(rec , rec + cnt);
	cnt = unique(rec , rec + cnt) - rec;
	dfs2(k , 0);
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**Bloxorz I**

[A-Bloxorz I_0x25 搜索-广度优先搜索 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1017/A)

[172. 立体推箱子 - AcWing题库](https://www.acwing.com/problem/content/description/174/)



#### solve

考虑bfs。
集中精力解决下面的问题：

1. 图的终点是什么？怎么表示？
2. 图上状态表示的方法
3. 优化迁移方案，减少代码量。

**关于图的起点**：3种情况

1. 一个格子。立起来
2. 两个格子
   1. 打横
   2. 打竖

因此要进行一些预处理判断起点的情况。

**关于状态表示：**

点上的状态标记几个维度：x , y ,lie。分别表示其最接近原点端的坐标。（x最小，y最小。）

**优化转移方案**

用一些数组来标记转移变化：
`next_x[3][4]`
`next_y[3][4]`
`next_lie[3][4]`

0 站， 1 横躺， 2竖躺。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N =  510;
char s[N][N];
struct node {int x , y , lie;};
node st , ed;
int n , m;
int d[N][N][4];
//优化转移减少if冗余。
//0 ， 1 ， 2 ， 3 左右上下
//0 , 1 , 2 站 ， 横躺 ， 竖躺
int next_x[3][4] = {{0 , 0 , - 2 , 1} , {0 , 0 , -1 , 1} , {0 , 0 , - 1 , 2 }};
int next_y[3][4] = {{ -2 , 1 , 0 , 0} , { -1 , 2 , 0 , 0} , { -1, 1, 0 , 0}};
int next_l[3][4] = {{1 , 1 , 2 , 2} , {0 , 0 , 1 , 1} , {2 , 2 , 0 , 0}};
int dx[4] = {0 , 0 , 1 , -1} , dy[4] = { -1 , 1, 0 , 0};
void get_st_ed() {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++)
			if (s[i][j] == 'X') {
				for (int k = 0 ; k < 4; k ++) {
					int x = i + dx[k];
					int y = j + dy[k];
					if (s[x][y] == 'X') {
						s[i][j] = s[x][y] = '.';
						st.x = min(x , i);
						st.y = min(y , j);
						st.lie = k < 2 ? 1 : 2;
					}
				}
				if (s[i][j] == 'X') {
					st.x = i; st.y = j;
					st.lie = 0;
				}
			} else if (s[i][j] == 'O') {
				ed.x = i; ed.y = j; ed.lie = 0;
				s[i][j] = '.';
			}
	}
}
bool check(int x, int y) {
	return x <= n && x >= 1 && y <= m && y >= 1;
}
bool valid(node next) {
	if (!check(next.x , next.y)) return false;
	if (s[next.x][next.y] == '#') return false;
	if (next.lie == 0 && s[next.x][next.y] != '.')return false;
	if (next.lie == 1 && s[next.x][next.y + 1] == '#')return false;
	if (next.lie == 2 && s[next.x + 1][next.y] == '#')return false;
	return true;
}
int bfs() {
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0 ; k < 3; k ++)
				d[i][j][k] = -1;
	queue<node> que;
	que.push(st);
	d[st.x][st.y][st.lie] = 0;
	while (que.empty() == false) {
		node cur = que.front(); que.pop();
		for (int i = 0; i < 4; i++) {
			int x = cur.x + next_x[cur.lie][i];
			int y = cur.y + next_y[cur.lie][i];
			int l = next_l[cur.lie][i];
			if (valid({x , y , l}) == false)continue;
			if (d[x][y][l] != -1)continue;
			d[x][y][l] = d[cur.x][cur.y][cur.lie] + 1;
			que.push({x , y , l});
			if (x == ed.x && y == ed.y && l == ed.lie) {
				return d[x][y][l];
			}
		}
	}
	return -1;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	while (true) {
		cin >> n >> m;
		for (int i = 1; i <= n; i++) {
			cin >> (s[i] + 1);
		}
		if (n == 0)return 0;
		get_st_ed();
		int ans = bfs();
		if (ans == -1) {cout << "Impossible\n"; }
		else cout << ans << '\n';
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**Pots**

[Pots - POJ 3414 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/POJ-3414#author=0)

#### 简介：

![image-20230316155349000](image-20230316155349000.png)

#### solve

和非常可乐类似：
都是往容器里装水：于是关于转移方向是一样的。但是这里更多了一个要求， 求转移路径的。

1. 专门开一个pre数组记录上一次转移的状态的关键字即可。

#### code

```cpp
#include<iostream>
#include<queue>
#include<stack>
using namespace std;
const int N = 300;
const int inf = 1E9;
// 记录当前状态的上一个点。 记录上达到这一次操作的上一个操作。
struct node {
	int x, y; string op;
	node() {};
	node(int x_, int y_, const string& op_) {
		x = x_;
		y = y_;
		op = op_;
	};
} pre[N][N];
struct ttt {
	int x ,  y , sum;
	ttt() {};
	ttt(int x_ , int y_, int sum_) {
		x = x_;
		y = y_;
		sum = sum_;
	};
};
bool vis[N][N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int a , b , c;
	cin >> a >> b >> c;
	queue<ttt> que;
	vis[0][0] = true;
	stack<string> stk;
	que.push(ttt(0 , 0 , 0));
	int ans = inf;
	while (!que.empty()) {
		int x = 0 , y = 0;
		ttt t = que.front(); que.pop();
		//get our ans
		if (t.x == c || t.y == c) {
			x = t.x , y = t.y;
			ans = t.sum;
			while (x != 0 || y != 0) {
				stk.push(pre[x][y].op);
				int tx = pre[x][y].x;
				int ty = pre[x][y].y;
				x = tx , y = ty;
			}
			break;
		}
		//转移：
		//1. 把1倒满。
		int sum = t.sum;
		if (!vis[a][t.y]) {
			x = a , y = t.y;
			que.push(ttt(x , y , sum + 1));
			vis[x][y] = true;
			pre[x][y] = node(t.x , t.y , "FILL(1)");
		}
		//把2给倒满
		if (!vis[t.x][b]) {
			x = t.x , y = b;
			que.push(ttt(x , y , sum + 1));
			vis[x][y] = true;
			pre[x][y] = node (t.x , t.y , "FILL(2)");
		}
		//把1抽空
		if (vis[0][t.y] == false) {
			x = 0 , y = t.y;
			que.push(ttt(x , y , sum + 1));
			vis[x][y] = true;
			pre[x][y] = node(t.x , t.y , "DROP(1)");
		}
		//把2给抽空。
		if (vis[t.x][0] == false) {
			x = t.x , y = 0;
			que.push(ttt(x , y , sum + 1));
			vis[x][y] = true;
			pre[x][y] = node(t.x , t.y , "DROP(2)");
		}
		//1 -> 2 ， 并且2满。
		if (t.x >= b - t.y) {
			x = t.x - (b - t.y);
			y = b;
			if (vis[x][y] == false) {
				que.push(ttt(x , y , sum + 1));
				vis[x][y] = true;
				pre[x][y] = node(t.x , t.y , "POUR(1,2)");
			}
		}
		//与上面相反
		if (t.x < b - t.y) {
			x = 0;
			y = t.y + t.x;
			if (vis[x][y] == false) {
				que.push(ttt(x , y , sum + 1));
				vis[x][y] = true;
				pre[x][y] = node(t.x , t.y , "POUR(1,2)");
			}
		}
		// 2 -> 1
		if (t.y >= a - t.x) {
			x = a;
			y = t.y - (a - t.x);
			if (vis[x][y] == false) {
				que.push(ttt(x , y , sum + 1));
				vis[x][y] = true;
				pre[x][y] = node(t.x , t.y , "POUR(2,1)");
			}
		}
		if (t.y < a - t.x) {
			x = t.x + t.y;
			y = 0;
			if (vis[x][y] == false) {
				que.push(ttt(x , y , sum + 1));
				vis[x][y] = true;
				pre[x][y] = node(t.x , t.y , "POUR(2,1)");
			}
		}
	}
	if (ans == inf) {
		cout << "impossible\n";
		return 0;
	}
	cout << ans << '\n';
	while (stk.empty() == false) {
		string s = stk.top();
		stk.pop();
		cout << s << '\n';
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**电路维修**

[A-电路维修_0x26 搜索-广搜变形 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/1018/A)

<img src="image-20230319220650805.png" alt="image-20230319220650805" style="zoom: 67%;" />

#### solve

1. 将问题转换为图上为题。

   1. 对于每个横竖线交叉点抽象为点。
   2. 如果初始电缆连接了两点，就建立权为0的边否则建立权为1的边。

   于是问题转变成寻找由（0 ， 0）到（n， m)的最短路径。

一个一疑惑：对于一个子图，是否其中的所有路径都合法（不存在回路）。可以映射到一个具体的方案，并且一个格子里面的电缆只有一种摆放方式，不产生矛盾。

1. 只要证明一个格子中的两个点不共存在一张图中即可。

----------







-------------

定义状态：队列维护的枚举状态， 从起点到（x , y）点的最短距离。

类似于广度搜索：

1. 从







----

**G. Garage**

[Problem - G - Codeforces](https://codeforces.com/contest/1725/problem/G)

#### 简介：

找出第n小的$b^2 - a^2$其中。a和b都是正整数。

#### solve

不妨设$b=a+1$ ， 那么$b^2-a^2 =2*a+1$
设$b= a+2$ 那么$b^2-a^2=4a+4$
设x为一个正整数：

1. 如果x为奇数。$x^2=(2*d + 1)^2=4d^2+1+4*d$此时mod 4结果为1.

2. 如果x味为偶数,$x^2=(2d)^2=4d^2$，此时mod4的结果为0.

因此由上述量种情况，已经找到了所有的解集合。这样直接计数统计即可。

1. 可以利用循环的思想。用一个计数手段直接计算。
2. 可以利用二分枚举解的方式计算：

#### code（二分操作）

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = lon long;

const int N = 1E6 + 10;
int n;
bool check(ll x) {
	ll one = (x - 1) / 2;
	ll two = x / 4 - 1;
	return one + two >= n;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	ll low = 3 , high = 1E18;
	if (n == 1) {
		cout << 3 << '\n';
		return 0;
	}
	while (low < high) {
		ll mid = (low + high) / 2;
		if (check(mid)) high = mid;
		else low = mid + 1;
	}
	cout << low + (low % 4 == 2) << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

直接统计的方法。

```cpp
	int n; cin >> n;
	n--;
	if (n == 0)cout << 3 << '\n';
	else if (n % 3 == 1)cout << (n + 2) / 3 * 4 + 1 << '\n';
	else if (n % 3 == 2)cout << (n + 2) / 3 * 4 + 3 << '\n';
	else cout << (n + 2) / 3 * 4 + 4
```

#### 生长思考：

1. 第一个关键应该是，怎么确认第几个解。
2. 根据平方差，尝试特殊的情况，通过mod运算，发现新枚举的解之间不相交。并且观察是否充分。

**C. Line Empire**

[Problem - 1659C - Codeforces](https://codeforces.com/problemset/problem/1659/C)

#### 简介：

从0点开始，要把所有的点都消灭掉：有如下几种方案：

1. 消灭：

   要求起点和消灭的城市之间没有存在，不被攻占的城市：

   $a*|x_{now} - x_{to}|$

2. 移动：

   $b*_{x_{now} - x_{to}}$

对于终点不做要求：问最小花费是多少？

[Line Empire - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF1659C)

#### solve

考虑所有的过程，就是不断地迁都，占领地过程。
如果要迁都，假设最终首都落到了$x_{i}$
那么来到$x_i$之前，考虑一种贪心的策略：

1. 由于攻占城市和距离差有关：
   1. 逐渐的迁移攻占；

枚举终点后，采取上述策略：转移上的花费不会受到影响：并且前面段的攻占难度最小：
于是枚举这种情况，贪心就前缀和优化，就可以求出最优的方案解。

#### code

```cpp
ll sum[N] , x[N];
void work(int testNo)
{
	int n , a , b; cin >> n >>  a >> b;
	for (int i = 1; i <= n; i++) {
		cin >> x[i];
		sum[i] = sum[i - 1] + x[i];
	}
	ll ans = 1E18;
	for (int i = 0; i <= n; i++) {
		ans = min(ans , x[i] * a + x[i] * b + (sum[n] - sum[i] - (n - i) * x[i]) * b);
	}
	cout << ans << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```



**F. Train Splitting**

[Problem - F - Codeforces](https://codeforces.com/contest/1776/problem/F)

# Train Splitting

## 题面翻译

有一个 $n$ 点 $m$ 边简单无向连通图，请用若干（至少为 $2$）种颜色对每条边染色，使得：

- 对于每种颜色，仅由该颜色的边组成的生成子图不连通。
- 对于每两种颜色，仅由该颜色的边组成的生成子图连通。

## 题目描述

There are $ n $ big cities in Italy, and there are $ m $ train routes between pairs of cities. Each route connects two different cities bidirectionally. Moreover, using the trains one can reach every city starting from any other city.

Right now, all the routes are operated by the government-owned Italian Carriage Passenger Company, but the government wants to privatize the routes. The government does not want to give too much power to a single company, but it also does not want to make people buy a lot of different subscriptions. Also, it would like to give a fair chance to all companies. In order to formalize all these wishes, the following model was proposed.

There will be $ k \ge 2 $ private companies indexed by $ 1, \, 2, \, \dots, \, k $ . Each train route will be operated by exactly one of the $ k $ companies. Then:

- For any company, there should exist two cities such that it is impossible to reach one from the other using only routes operated by that company.
- On the other hand, for any two companies, it should be possible to reach every city from any other city using only routes operated by these two companies.

Find a plan satisfying all these criteria. It can be shown that a viable plan always exists. Please note that you can choose the number $ k $ and you do not have to minimize or maximize it.

## 输入格式

Each test contains multiple test cases. The first line contains an integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. The descriptions of the $ t $ test cases follow.

The first line of each test case contains two integers $ n $ and $ m $ ( $ 3 \le n \le 50 $ , $ n-1 \le m \le n(n-1)/2 $ ) — the number of cities and the number of train routes.

The next $ m $ lines contain two integers $ u_i $ and $ v_i $ each ( $ 1 \le u_i, v_i \le n $ , $ u_i \ne v_i $ ) — the $ i $ -th train route connects cities $ u_i $ and $ v_i $ .

It is guaranteed that the routes connect $ m $ distinct pairs of cities. It is guaranteed that using the trains one can reach every city starting from any other city.

The sum of the values of $ n $ over all test cases does not exceed $ 5000 $ .

## 输出格式

For each test case, on the first line print an integer $ k $ ( $ 2 \le k \le m $ ) — the number of companies in your plan; on the second line print $ m $ integers $ c_1, \, c_2, \, \dots, \, c_m $ ( $ 1 \le c_i \le k $ ) — in your plan company $ c_i $ operates the $ i $ -th route.

If there are multiple valid plans, you may print any of them.

## 样例 #1

### 样例输入 #1

```
2
5 9
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
3 3
1 2
3 1
2 3
```

### 样例输出 #1

```
4
1 2 3 1 4 2 2 4 3
3
2 3 1
```

## 提示

In the first test case, the output is illustrated in the following picture, where different colors correspond to different companies (blue for $ 1 $ , red for $ 2 $ , green for $ 3 $ , and yellow for $ 4 $ ):

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1776F/1eaddc7b0f6d2a4f1f27940fa94f2aacb1f5a325.png)If we consider, for example, only companies $ 2 $ and $ 3 $ , we can see that from any city it is possible to reach every other city (picture on the left below). However, if we restrict to company $ 2 $ alone, it becomes impossible to reach city $ 5 $ from city $ 1 $ (picture on the right).

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1776F/31ecc8efdc21984e9ee7dfce5c89335fe0b0fc8e.png)In the second test case, the output is illustrated in the following picture:

 ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1776F/168f9819a179018b8d7faca3d4c3b94ba0dba5d9.png)



#### solve

从可以想到的简单角度进行构造：考虑只用两种颜色进行染色：

1. 找到一个节点，将该节点上的所有边染成颜色1
2. 其它边染上颜色2

**这个节点怎么找？有几个要求。如下**

1. 阻断其它的节点：至少有一个节点与它不产生连接。即$deg_{u} < n$
   1. 如果上述1的情况得到满足，那么已经构造成功了。
2. 如果是完全图，找不到这样的点。考虑引入第三种颜色。
   1. 只需要将1颜色中的边改变一条即可。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

void work(int testNo)
{
	int n , m; cin >> n >> m;
	vector<vector<pair<int , int>>> g(n);
	vector<int> ans (m , 0) , deg(n , 0);
	for (int i = 1; i <= m; i++) {
		int a , b; cin >> a >> b;
		a--; b--;
		g[a].push_back({b , i - 1});
		g[b].push_back({a , i - 1});
		deg[a]++; deg[b]++;
	}

	int u =  0;
	while (u < n && deg[u] == n - 1)u++;
	if (u == n)u--;
	for (auto &[v , i] : g[u]) {
		ans[i] = 1;
	}
	//cout << u << '\n';
    //注意特判完全图。
	if (u == n)u--;
	for (int i = 0; i < m ; i++) {
		if (ans[i] != 1)
			ans[i] = 2;
	}
	//cout << "no: " << testNo << ' ' << deg[u] << '\n';
	int sum = 2;
	if (deg[u] >= n - 1) {
		sum = 3;
		for (int i = 0 ; i < m ; i++) {
			if (ans[i] == 1) {
				ans[i] = 3;
				break;
			}
		}
	}
	cout << sum << '\n';
	for (int i = 0; i < m; i++) {
		cout << ans[i] << " \n"[i == m - 1];
	}
}
int main()
{
	// ios::sync_with_stdio(false);
	// cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/

```



**C. Quiz Master**

[Problem - C - Codeforces](https://codeforces.com/contest/1777/problem/C)

#### 简介

从一组数$a_1...a_n$中找到一子集。满足，该子集的因数集合包含集合$\left \{1...m\right \} $
找出符合题意子集中最大元素减去最小元素得最小值。



#### solve

发现一个性质。值关注最大最小值，夹在两者之之间得值不影响结果。所以能选就选。这样枚举一个最小值，然后找到第一个填满因数得最大值即可。
**关于细节处理**
怎么快速确定有边界？

1. 对于上一次最小值得枚举。显然可以重新利用。
   1. 假设上一次枚举到[l  , r]。当枚举l + 1为最小值时。那么有边界r 必定至少为r。反证法证明即可。否则，对于l，有边界应该更小。
2. 对于维护，可以维护几个变量：
   1. cunt , 表示当前有多少个数被覆盖。（1.....m）
   2. c[N] ， 表示当前 i 这个因数被贡献多少次。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int inf = 0x0fffffff;
const int N = 1E6 + 10;

void work(int testNo)
{
	int n, m; cin >> n >> m;
	vector<int> a(n), cunt(m + 1, 0);
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	sort(a.begin(), a.end());
	vector<vector<int>> g(n);

	int ans = inf;
	int c = 0;
	for (int low = 0, high = 0; low < n; low++) {
		while (c < m && high < n) {
			for (int i = 1; i * i <= a[high]; i++) {
				if (a[high] % i == 0) {
					if (i <= m) {
						g[high].push_back(i);
						int j = a[high] / i;
						if (i != j && j <= m)
							g[high].push_back(j);
					}
				}
			}
			for (auto j : g[high]) {
				cunt[j]++;
				if (cunt[j] == 1)
					c++;
			}
			++high;
		}
		if (c == m && high - 1 < n) {
			ans = min(a[high - 1] - a[low], ans);
		}
		for (auto j : g[low]) {
			cunt[j]--;
			if (cunt[j] == 0) {
				c--;
			}
		}
	}
	if (ans >= inf)ans = -1;
	cout << ans << '\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

------

**Pull Your Luck**

[Problem - C - Codeforces](https://codeforces.com/contest/1804/problem/C)

**简介**

定义正整数 h ,定义域为 $h\in[1,h_{max}]$。找到一个h满足$(1+2+...+h)\%n=k$



#### solve

1. 当h = 2n时。 $sum_{h}\%n=n*(2n + 1)\%n=0$

2. 当h > n 时 ， 求和的前缀mod去为0 .新赠的尾部 , 的表示为 n + d。n完蛋了，然后重新变回 $sum(1...(d-n))\%n$
3. 综上只需要，考察$min(2n , h+{max})$即可。

代码比较简单略。



----------

**D. Accommodation**

[Problem - D - Codeforces](https://codeforces.com/contest/1804/problem/D)

**简介**

![node](node-1679238673486-8.png)



还是看看题目好：

#### solve:

首先关注到对于每一行的处理都是独立的，因此独立处理即可。

先定义一些变量：（针对每一行的变量：）

$S$:  1的个数。
$A_{0}$(0 , 0)的个数。
$A_{1}$ (1 , 0 ) (1 , 0)的个数。
$A_{2}$（1 ， 1）的个数；
$B_{0}$(0)的个数。
$B_{1}$（0）的个数：


推演如下：
$$
S = A_{1}+A_{2}\times 2+ B_{1}.\\
sum = A_{1} + A_{2} + B_{1}\\
sum = S - A_{2}
$$

因此问题就转变成了就是最大化，最小化$A_2$

对于这种最优问题，可以有一种贪心策略。

1. 最大化

   1. 关注连续的1...1段。
   2. 能选就选.

2. 最小化：

   1. 优先选择（0 ， 0）， （0 ， 1）即可。

   上述可以使用dp来完成： 

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
char s[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	int mi = 0 , mx = 0;
	for (int i = 0; i < n; i++) {
		cin >> (s + 1);
		vector<int>dp(m  + 1, 0) , dp1(m + 1, 0);
		int sum = 0;
		for (int j = 1; j <= m; j++) {
			sum += s[j] == '1';
			if (j >= 2) {
				dp[j] = max(dp[j - 1] , dp[j - 2] + (s[j] == '1' && s[j - 1] == '1'));
				dp1[j] = max(dp1[j - 1] , dp1[j - 2] + (s[j] == '0' || s[j - 1] == '0'));
			}
		}
		mi += sum - min(m / 4 , dp[m]);
		mx += sum - max(0 , m / 4 - dp1[m]);
	}
	cout << mi << ' ' << mx << '\n';
}
```

------

**E. Routing**

[Problem - E - Codeforces](https://codeforces.com/contest/1804/problem/E)

#### 题意简介

给定一个连通的无向图。对每一个点建立参考点，例如$f_{u}$为u的参考点。对每个元素，尝试找出这种集合，满足：对于任意u , v。
关注：$u ，f_(u)， f_{f_{u}}$这样的递归方式中，v和其中一个点直接连接。（v不能是其中的点）

题目中用了一个递归的函数说明这种过程：

#### solve

对于任何一种指派方案:其模型都是一下的情形:

![node](node-1679238684273-10.png)

对于上述的情形:

1. $u:$环内的任意点:其与相邻点之间必须存在一条边.否则无法通过$f_a$去到v的附近.这样环内的点,在原有的图中也是成环的.
2. $u:$环外的任意点:其与环内的某一点距离至多为1.否则环内的点没有办法与u交流。

充分条件 : 存在可行方案 -> 原图存在一个环且，环外得点与环中得某一点距离为1.
必要条件：显然对于上述情况，存在一个环且环外的点到环的距离为1。容易构造出一个方案。环内互指，环外点指向环内点。

**在图中找到上述的环结构：**

所以下面补充一些内容：

1. 竞赛图
2. 状态压缩方法求哈密尔顿路径。
3. 哈密尔顿路径和求环：

**总结问题：**

关于2. [basic.md](..\..\..\..\Logrithm\动态规划\状压dp\basic.md) 初学状态压缩dp的笔记。
如果某个环存在，必然会被考虑到，求汉密尔顿路径的过程中可以考虑所有的环。

1. 求出一个状态之后。
   1. 关注起点终点。如果两点之间有路，那么成一个环。
2. 找到环之后呢？怎么检查环外点到环中的距离？
   1. 方案1：对于一种起点求出所有的环，然后check.
   2. ==方案2：使用一些rec数组，在迁移的过程中，记录下当前已经挂在环上的点的信息。（对于每一种图集合，其挂点情况都是一致的）。==
3. 求出一个具体的环后，怎么构造？
   1.  分析：解决路径还原的问题。
   2.  解决方法： 记录状态上一步的使用了什么点。逐渐溯源可以求出路径。



综上复杂度分析：

1. 枚举起点  + 状态压缩dp：$O(N^3\times2^N)$。
2. 考虑一种优化方案：
   1. 在枚举不同的起点的过程中，一些环会被重复计算。
   2. 对于一个序号的起点，只枚举由序号小于等于该点的序号的点组成的环。
   3. 于是复杂度可以控制在$N^2\times 2^\N$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 100;
int g[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int  n , m; cin >> n >> m;
	//构建图使用新的技巧。这样可以更加快的更新v.
	for (int i = 0; i < m; i++) {
		int u , v; cin >> u >> v;
		u-- , v--;
		g[u] |= (1 << v);
		g[v] |= (1 << u);
	}
	for (int i = 0 ; i < n; i++)
		g[i] |= (1 << i);
	//下面枚举起点且进行状态压缩dp;
	//先枚举起点：
	for (int st = 0; st < n; st++) {
		//算法实现过程中，需要的一些结构：
		//1,dp【ed】[cur]，表示以 ed为为end ， cur为当前遍历的集合的情况 是否存在方案？保证每一步存在方案即可。
		vector<vector<bool>>dp(st + 1 , vector<bool>(1 << (st + 1), false));
		//表示当前状态下，各种点的可达情况。
		vector<vector<int>>s(st + 1, vector<int>(1 << (st + 1) , 0));
		//表示各种状态的前驱。
		vector<vector<int>>pre(st + 1 , vector<int>(1 << (st + 1) , -1));
		//对上述的一些结构进行初始化：
		dp[st][1 << st] = true;
		s[st][1 << st] = g[st];
		//由于只关注小规模的环。
		for (int cur = 1; cur < 1 << (st + 1); cur++) {
			for (int ed = 0; ed <= st; ed++) {
				//当前状态不存在方案。
				if (dp[ed][cur] == false)continue;
				//检查当前方案是否已经满足成环。等等条件。
				//环外的点距离环距离为1.且起点终点之间存在边。
				if (s[ed][cur] == (1 << n) - 1 && (g[st] >> ed & 1)) {
					//先处理环外部的点；
					vector<int>ans (n);
					for (int k = 0 ; k < n; k ++)
						//检查当前枚举的点是否为环外的点。
						if (!(cur >> k & 1)) {
							for (int t = 0 ; t < n; t++) {
								//当前枚举一个点t满足。t点在图上，并且当前点在环上。

								if ((g[k] >> t & 1) && (cur >> t & 1)) {
									ans[k] = t; break;
								}
							}
						}
					//接下来处理的是环中的点。
					vector<int> cycle;
					int cur_ = cur , now = ed;
					while (now != - 1) {
						cycle.push_back(now);
						cur_ ^= 1 << now;
						now = pre[now][cur_ | (1 << now)];
					}
					//然后园内的点互相指向。
					for (int k = 0; k < (int)cycle.size(); k++)
						//指向上一个点。顺时针逆时针都没有影响。
						ans[cycle[k]] = cycle[(k + 1) % ((int) cycle.size())];
					//最后特判特殊的一类情况。形成自环。
					if ((int)cycle.size() == 1) {
						ans[cycle[0]] =  (cycle[0] + 1) % n;
					}
					cout << "YES\n";
					for (int i = 0 ; i < n; i++) {
						cout << ans[i] + 1 << " \n"[i == n - 1];
					}
					return 0;
				}
				//状态拓展更新。
				for (int k = 0 ; k <= st; k ++) {
					//当前点没有 ，当前点和终点有边。 当前的dp还有计算出来。
					if ((g[k] >> ed & 1) && !(cur >> k & 1) && !dp[k][cur | 1 << k]) {
						dp[k][cur | 1 << k] = true;
						pre[k][cur | 1 << k] = ed;
						s[k][cur | 1 << k] = s[ed][cur] | g[k];
					}
				}
			}
		}
	}
	cout << "NO\n";
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





