### **3月第四周**

**冬夜读书式示子聿  \[陆游 宋代]
古人学问无遗力，少壮功夫老始成。
纸上得来终觉浅，绝知此事要躬行。**

**训练方向：**

这周末校赛。所以主要是为校赛做一些准备。写一些题练练手，同时要复习之前的一些笔记，写过的题。线段树，树状数组，st表，单调栈等，各种基础dp。

vp一些场次：

**算法学习：**

1. 把启发式搜索算法给搞一下： 
2. 双指针写不顺手。

### **problems**

1.  [E Tree Master.md](..\Logrithm\杂篇\根号复杂度优化\problem\树模型\E Tree Master.md)  (其中的思想未体会完全。)
2.  [F. Interesting Function.md](..\Logrithm\杂篇\根号复杂度优化\problem\进制模型\进制变化规律\F. Interesting Function.md)  (精彩的进制模型。)（数位dp的方法未补充）

**动态规划：**

1.  [序列取数.md](..\problems\洛谷\动态规划\提高-\序列取数.md)  （未补）
2.  [C. Remove the Bracket.md](..\problems\codeforces\1400-1600\dp\C. Remove the Bracket.md) (dp)

codeforces

1.  [D. Valiant's New Map.md](..\problems\codeforces\1700\二分\压位优化max\D. Valiant's New Map.md) (压位优化max运算。)
2.  [bitset优化dp.md](..\problems\codeforces\1700\动态规划\优化\bitset优化dp.md) （表上的dp ， bitset优化大法。）
3.  ==[Even Subarrays.md](..\problems\codeforces\1700\位运算\Even Subarrays.md) （数论位运算，未总结）==
4.  [C. Sum on Subarrays.md](..\problems\codeforces\1400-1600\解的构造\数组模型\C. Sum on Subarrays.md) 构造

**数学**

1.  [D. Pythagorean Triples.md](..\problems\codeforces\1400-1600\数论\方程解枚举\D. Pythagorean Triples.md) 
2.  [等腰三角形(hard).md](..\problems\nowcoder\小白月赛\模型\网格模型\等腰三角形(hard).md)  （网格模型以及简单组合数学认知。）==补一下证明==

**构造**

1. [覆盖加法.md](..\Logrithm\基础算法设计思想\构造\1600-1800\四则运算模型\覆盖加法.md) 



# Remove the Bracket

## 题面翻译



### 题目描述

RSJ 得到了一个长为 $n$ 的序列 $a_1,a_2, \ldots, a_n$ 和一个正整数 $s$，他想要计算 $\prod\limits_{i=1}^n a_i$。对于 $a_2,a_3, \ldots, a_{n-1}$ 中的每一个，他都选取了一对**非负整数** $x_i,y_i$ 使得 $x_i + y_i = a_i$ 且 $(x_i-s) \cdot (y_i-s) \geq 0$。他使用如下的方法计算：

$$
\begin{aligned}
\text{Product} &= a_1 \cdot a_2 \cdot a_3 \cdot \ldots \cdot a_n \\
&= a_1 \cdot (x_2+y_2) \cdot (x_3+y_3) \cdot (x_4 + y_4) \cdot \ldots \cdot (x_{n-1}+y_{n-1}) \cdot a_n \\
&\overset{\text{?}}{=} a_1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot x_4 + y_4 \cdot \ldots \cdot x_{n-1}+y_{n-1} \cdot a_n
\end{aligned}
$$

但是他在计算时出现了错误，不小心把括号弄丢了（式子第 $3$ 行）。于是，他想要知道写错了的式子（$F = a_1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot x_4 + y_4 \cdot \ldots \cdot x_{n-1}+y_{n-1} \cdot a_n$）的最小值是多少。

~~这是原本的题面，审核改成了现在的样子（真就 remove the bracket 了，导致赛时式子有歧义，在此向大家道歉~~

### 输入格式

输入第一行一个正整数 $t$（$1\le t\le 10^4$）表示数据组数。

每组数据两行，第一行两个正整数 $n,s$（$3 \le n \le 2 \cdot 10^5$，$0 \le s \le 2 \cdot 10^5$），含义见题目描述。

第二行 $n$ 个正整数 $a_1,a_2,\ldots,a_n$（$0 \le a_i \le 2 \cdot 10^5$）表示序列 $a$。

保证所有测试数据的 $n$ 之和不超过 $2\cdot 10^5$。

### 输出格式

每组测试数据输出一行一个正整数表示 $F$ 的最小值。

## 样例 #1

### 样例输入 #1

```
10
5 0
2 0 1 3 4
5 1
5 3 4 3 5
7 2
7 6 5 4 3 2 1
5 1
1 2 3 4 5
5 2
1 2 3 4 5
4 0
0 1 1 1
5 5
4 3 5 6 4
4 1
0 2 1 0
3 99999
200000 200000 200000
6 8139
7976 129785 12984 78561 173685 15480
```

### 样例输出 #1

```
0
18
32
11
14
0
16
0
40000000000
2700826806
```

## 提示

In the first test case, $ 2\cdot 0+0\cdot 1+0\cdot 3+0\cdot 4 = 0 $ .

In the second test case, $ 5\cdot 1+2\cdot 2+2\cdot 2+1\cdot 5 = 18 $ .

-----------

#### solve

研究枚举空间，做一些解空间压缩：

1. 对于一种数字最优的选择是，分出一个最大值，一个最小值。

2. 转移过程中研究
   $$
   g(i)=a_1\times x_2 + .... +y_{i-1}\times  x_i + y_i
   $$
   对于一个数字有两种选择，最大的放前面，和前面的结构相乘，或者放后面。

   **状态定义：**

   $f_{i,0/1}$，处理到第i位。第i位选择最小/最大在前面的结构中，$g(i)-y_i$的最大值。

   **状态转移方程**

   $f_{i,0}=min(f_{i-1,0}+mx_{i-1}mi_{i},f_{i-1,1}+mi_{i-1}mi_i)$

   $f_{i,1}=min(f_{i-1,0}+mx_{i-1}mx_{i},f_{i-1,1}+mi_{i-1}mx_i)$

   **初始化**

   由于这种解的结构非常特殊，上述转移只适用于2.....n-1个状态。然后直接算出答案即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

ll a[N];
ll mi[N] , mx[N];
ll f[N][2];

void work(int testNo)
{
	int n , s; cin >> n >> s;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (a[i] >= 2 * s) mi[i] = s , mx[i] = a[i] - s;
		else mi[i] = max(a[i] - s , 0LL) , mx[i] = a[i] - mi[i];
	}
	//状态设计表示大的放前面。
	f[2][0] = a[1] * mi[2];
	f[2][1] = a[1] * mx[2];
	for (int i = 3; i < n; i++) {
		f[i][0] = min(f[i - 1][0] + mx[i - 1] * mi[i] , f[i - 1][1] + mi[i - 1] * mi[i]);
		f[i][1] = min(f[i - 1][0] + mx[i - 1] * mx[i] , f[i - 1][1] + mi[i - 1] * mx[i]);
	}
	cout << min(f[n - 1][0] + mx[n - 1]*a[n] , f[n - 1][1] + mi[n - 1]*a[n]) << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**D. Valiant's New Map**

[Problem - 1731D - Codeforces](https://codeforces.com/problemset/problem/1731/D)

#### 简介：

给定一个$n\times m$矩阵。找到一个最大的l满足。在矩阵中存在一个$l\times l$矩阵，且其最小值大于l.

#### solve

1. 假定l行。那么小于l的情形一定一行。符合二分前提。
2. check函数的设计。只关注数字的一个属性，是否大于等于l。将其抽象出01矩阵，在其上面进行一个前缀和判断即可。

综上复杂度为$O(nlogn)$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;


void work(int testNo)
{
	int n , m;
	cin >> n >> m;
	vector g(n  + 1 , vector<int>(m + 1 , 0));
	vector t(n + 1 , vector<int>(m + 1 , 0));
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> g[i][j];
		}
	}

	auto check = [&](int l) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (g[i][j] < l)t[i][j] = 0;
				else t[i][j] = 1;
			}
		}
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++) {
				t[i][j] += t[i - 1][j];
			}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				t[i][j] += t[i][j - 1];
			}
		}
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++) {
				if (i < l || j < l)continue;
				if (t[i][j] + t[i - l][j - l] - t[i - l][j] - t[i][j - l] == l * l) {
					return true;
				}
			}
		return false;
	};

	int low = 1 , high = max(n , m);
	while (low < high) {
		int mid = (low + high + 1) / 2;
		if (check(mid)) low = mid;
		else high = mid - 1;
	}
	cout << low << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



**1695C - Zero Path**

[Problem - 1695C - Codeforces](https://codeforces.com/problemset/problem/1695/C)

![image-20230323202627945](image-20230323202627945.png)

#### solve

1. **模型性质挖掘**
   显然如果（n + m）%2 == 0必然无解。
   关注路径的最大和，以及最小和。有如下发现：
   通过一种解，进行迁移，研究其它解；
   发现最小的路径可以逐步交换到最大路径：具体交换规则如下：

   1. LD -》 DL. 或者反之。
   1. 每次交换路径总和发生的变化有三种情况分别为0 -2 , 2.

   由于偶数和个+1 -1相加最终的结果必然是偶数。所以从最大到最小的过程中，必然会经历0的情况。

   因此问题转变成了求最大路径和 ， 最大路径的简单dp问题。

   ```cpp
   #include<bits/stdc++.h>
   using namespace std;
   typedef long long ll;
   
   const int oo = 0x0fffffff;
   const int N = 1E3 + 10;
   
   int a[N][N];
   
   int mx[N][N];
   int mi[N][N];
   
   void work(int testNo)
   {
   	int n , m;
   	cin >> n >> m;
   
   	for (int i = 1; i <= n; i++)
   		for (int j = 1; j <= m; j++) {
   			cin >> a[i][j];
   			if (j == 1) {
   				mx[i][j] = mx[i - 1][j];
   				mi[i][j] = mi[i - 1][j];
   			}
   			else if (i == 1) {
   				mx[i][j] = mx[i][j - 1];
   				mi[i][j] = mi[i][j - 1];
   			} else {
   				mx[i][j] = max(mx[i - 1][j] , mx[i][j - 1]);
   				mi[i][j] = min(mi[i - 1][j] , mi[i][j - 1]);
   			}
   			mx[i][j] += a[i][j];
   			mi[i][j] += a[i][j];
   		}
   	if ((n + m) % 2 == 0) {
   		cout << "NO\n";
   		return;
   	}
   	if (mx[n][m] >= 0 && mi[n][m] <= 0) {
   		cout << "YES\n";
   	} else cout << "NO\n";
   }
   
   
   int main()
   {
   	ios::sync_with_stdio(false);
   	cin.tie(0);
   
   	int t; cin >> t;
   	for (int i = 1; i <= t; i++)work(i);
   }
   
   /* stuff you should look for
   * int overflow, array bounds
   * special cases (n=1?)
   * do smth instead of nothing and stay organized
   * WRITE STUFF DOWN
   * DON'T GET STUCK ON ONE APPROACH
   */
   
   ```

   **另外一种很暴力的思路**

   最暴力的dp方案

   **状态：**

   $dp_{i , j ,k}$表示到i ， j 格子和为k的方案是否存在。

   **转移：**

   `if(a[i][j] == 1)`

   $dp_{i, j , k} = dp_{i - 1 , j , k -1}|dp_{i , j -1 , k -1}$

   `else`

   $dp_{i , j ,k} = dp_{i-1, j,k}|dp_{i,j -1 , k}$

   **复杂度是：$10^9$**

   使用bitset除上w刚刚好。

   #### 具体优化

   **状态**

   依然如上。

   **转移**

   直接做或运算即可。

   1. 如果a\[i][j]为0.dp数组保持不变。
   2. 如果a\[i][j]为1，dp数组左移动一位。

   ```cpp
   #include<bits/stdc++.h>
   using namespace std;
   typedef long long ll;
   
   const int oo = 0x0fffffff;
   const int N = 1E3 + 10;
   int a[N][N];
   int mx[N][N];
   int mi[N][N];
   void work(int testNo)
   {
   	int n , m;
   	cin >> n >> m;
   
   	for (int i = 1; i <= n; i++)
   		for (int j = 1; j <= m; j++) {
   			cin >> a[i][j];
   			if (j == 1) {
   				mx[i][j] = mx[i - 1][j];
   				mi[i][j] = mi[i - 1][j];
   			}
   			else if (i == 1) {
   				mx[i][j] = mx[i][j - 1];
   				mi[i][j] = mi[i][j - 1];
   			} else {
   				mx[i][j] = max(mx[i - 1][j] , mx[i][j - 1]);
   				mi[i][j] = min(mi[i - 1][j] , mi[i][j - 1]);
   			}
   			mx[i][j] += a[i][j];
   			mi[i][j] += a[i][j];
   		}
   	if ((n + m) % 2 == 0) {
   		cout << "NO\n";
   		return;
   	}
   	if (mx[n][m] >= 0 && mi[n][m] <= 0) {
   		cout << "YES\n";
   	} else cout << "NO\n";
   }
   int main()
   {
   	ios::sync_with_stdio(false);
   	cin.tie(0);
   
   	int t; cin >> t;
   	for (int i = 1; i <= t; i++)work(i);
   }
   ```



**C. Sum on Subarrays**

[Problem - C - Codeforces](https://codeforces.com/contest/1809/problem/C)

![image-20230325004048166](image-20230325004048166.png)

#### solve

**构造思想：**

1. 连续
1. 有序
1. 简洁
1. 特殊

**关键问题**

1. 怎么精准控制k的大小？

考虑==连续==的填一些正整数。发现不断填的过程中，每一步贡献的变化过程为：$+x$（x指的是当前已经有多少个连续的正数在数组中。）
逐渐的贡献会超过k ， 此时我们停止内部的贡献。
于是我们补上第一个负数。追求补回来。因为==控制负数的大小==可以使得贡献为$[0...remaind]$

为了使得其它段不会产生贡献：于是其它==特殊的==填上最小值： -1000

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;
int a[N];

void work(int testNo)
{
	int n , k;
	cin >> n >> k;
	int x = 0;
	while ((x + 1) * (x + 2) / 2 <= k)
		x++;
	//cout << x << '\n';
	for (int i = 1; i <= n; i++) {
		if (i <= x) {
			a[i] = 2;
		} else if (i == x + 1) {
			a[i] = -2 * x - 1 +  2 * k -  (1 + x) * x;
		} else a[i] = -1000;
	}
	for (int i = 1; i <= n; i++) {
		cout << a[i] << " \n"[i == n];
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```



**D. Pythagorean Triples**

[Problem - D - Codeforces](https://codeforces.com/contest/1487/problem/D)

#### 简介：

给定值域$[1,n]$求出范围之内的满足下面两个条件的方程的解：

1. $a^2+ b^2 = c^2$
2. $c = a^2 - b$

数学工具：等价消元，联立。式子等价变换成如下形式：
$$
c=c^2-b^2-b\\
c+b=c^2-b^2\\
c+b=(c + b)(c-b)\\
c=b+1\\
$$

$$
2c+1=a^2
$$

于是a的有效枚举域被降下来了。
继续分析该方程的性质：

1. a必须为奇数。
2. c必须为偶数，且c大于1.

所以只要a满足
$$
a\ge3\\
a
$$
枚举或者直接计算即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int oo = 0x0fffffff;
const int N = 1E6 + 10;
void work(int testNo){
	int n; cin >> n;
	ll ans = 0;
	for (int i = 3; i * i <= 2 * n - 1; i += 2) {
		ans ++;
	}
	cout << ans << '\n';
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```



**等腰三角形(hard)**

[F-等腰三角形(hard)_牛客小白月赛69 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/52441/F)



#### 简介：

![image-20230325001435442](image-20230325001435442.png)

#### solve

**关键结论：**

1. 网格上，3整数点不可能会组成等边三角形。

-----

**证明：**





----

所以不需要考虑对等边三角形去重。统计等腰三角形，以及对共线的情况做容斥即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 3E3 + 10;
int x[N] , y[N];
bool f[N][N];
ll g(int i, int j) {
	return (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);
}
long double check(int i , int j) {
	if (x[i] == x[j]) return 1E9;
	return (y[i] - y[j]) / (1.0 * (x[i] - x[j]));
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n; cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x[i] >> y[i];
		f[x[i] + 1500][y[i] + 1500] = true;
	}
	ll ans = 0;
	for (int i = 1; i <= n; i++) {
		vector<int> a;
		int cunt = 0;//统计多少种贡献情况。
		for (int j = 1; j <= n; j++) {
			a.push_back(g(i , j));
			int dx = x[j] - x[i];
			int dy = y[j] - y[i];
			if (f[x[i] - dx + 1500][y[i] - dy + 1500])
				cunt++;
		}
		a.push_back(1E9);
		sort(a.begin() , a.end());
		//然后扫描一遍统计个数。
		//然后统计个数。
		for (int j , i = 1; i < n; i = j) {
			for ( j = i + 1; j <= n; j++) {
				if (a[i] != a[j])break;
			}
			ans += (j - i) * (j - i - 1) / 2;
		}
		ans -= cunt / 2;
	}
	cout << ans << '\n';
}
```



#### 生长思考：

1. 首先是这个结论。在实际解决问题的过程中，有两种思路。
   1. 怎么去除贡献。
   2. 这种情况真的存在吗？
2. 赛时采取map大法。但是由于关键字比较复杂，因此没有卡过去。





#### 覆盖加法构造：

![image-20230325162055036](image-20230325162055036.png)



#### solve

关注最终结果为 xxxxxxx

拆分成三组，每一位独立贡献，每组100个就可以通过这三组构造出所有的可能。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
bool f[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout << 298 << '\n';
	for (int i = 1; i <= 99; i++) {
		cout << i << ' ';
	}
	for (int i = 1; i <= 99; i ++) {
		cout << i * 100 << ' ';
	}
	for (int i = 1; i <= 100; i++) {
		cout << i * 10000 << ' ';
	}
	cout << '\n';
}
```

