# $\large 2023/3/5$

$\large 青春须早为，岂能长少年$

## 1. 总括

**承上启下** [2023.2月下旬.md](2023.2月下旬.md) 

## 上一阶段的情况：

1. 算法学习进度 ， 
  2. 相对较慢。其中数位dp中的几道很难的问题，梦幻珠宝岛卡了两三天。
  3. dls的课程只是刷到区间dp（dp进阶第五节。）
4. 比赛强度：
   1. 有比赛基本都打了。包括一场牛客小白月赛。两场师兄拉的练习赛。div2  div1 + div2 , edu div2 atcoder abc 两场。
5. 练习强度：
   1. 虽然一天有三道题目情况。但是题目难度参差不齐。只要是比赛，课程内容的题。
6. 复习强度
   1. 对于上一阶段的总结复习。现在有了新的计划。在一个阶段结束之后。打印笔记。复习，具体的策略还要进一步研究。但是给予一定强度的复习 ， 再次生长思考以及记忆是必要的。

## **本阶段目标：**

#### 1. 尝试板刷：

1. 板刷图论基础专题。
1. 板刷各种动态规划专题。

#### 2.继续学习dls的课程内容。

1. 不会的问题就跳，掌握课程对于一个类型的dp的关键点。
2. 总结区域赛dp问题的难度水平。

#### 3.比赛上

1. atcoder
2. codeforces

#### 4. 为校赛做哪些准备？

1. 学学基础数学问题。
2. 常用的数据结构可以再熟练一点。
3. 各种类型的dp问题再做一遍。

----------------

## 笔记记录

#### 语法等的学习

1. 关于位运算中的一些函数使用：==**未补**==

#### 算法学习

动态规划：

1. 数位dp进阶
   1.  [数位dp进阶.md](..\Logrithm\动态规划\数位dp\进阶课\数位dp进阶.md) 

图论

1. 树哈希： [树哈希.md](..\Logrithm\图论\树上问题\树哈希.md) 

#### 补题

​	二分

1.  [D. Maximum Subarray.md](..\problems\codeforces\2000\二分\D. Maximum Subarray.md) 

2.  [D. Renting Bikes.md](..\problems\codeforces\1800\二分\D. Renting Bikes.md) 

​	提高string简单题速度。

1. 

​	div3 (2023/3.4)

1.  [2023.3上旬.md](2023.3上旬.md) 
2.  [树哈希.md](..\Logrithm\图论\树上问题\树哈希.md) 

**刷题**

动态规划：

1. 牛客
   1. [删括号.md](..\problems\nowcoder\板刷\动态规划\基础dp\括号匹配模型\删括号.md) 
   2. [美丽序列.md](..\problems\nowcoder\板刷\动态规划\基础dp\序列模型\美丽序列.md) 
   3. [codeforces.md](..\problems\nowcoder\板刷\动态规划\基础dp\逆序对模型\codeforces.md) 
   4. [和与或.md](..\problems\nowcoder\板刷\动态规划\数位dp\和与或.md) 
   5. [牛牛与数组.md](..\problems\nowcoder\板刷\动态规划\基础dp\序列模型\牛牛与数组.md)  
   6. [牛牛的回文串.md](..\problems\nowcoder\板刷\动态规划\基础dp\串模型\牛牛的回文串.md)
   7. [牛牛去买球.md](..\problems\nowcoder\板刷\动态规划\背包问题\01背包\牛牛去买球.md) 
   8. [牛牛的计算机内存.md](..\problems\nowcoder\板刷\动态规划\状态压缩dp\牛牛的计算机内存.md) 

**atcoder**

1.  [XYYYX.md](..\problems\atcoder\贪心\XYYYX.md) 

--------

## 数位dp进阶

### 数数3

[数数3 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/248)

求区间中有多少个数字a满足存在连续三个数位 $a_i , a_{i + 1} , a_{i + 1}$使得$a_{i} < a_{i + 1}<a_{i + 2}$

 [basic.md](..\basic.md) 参照题解：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

ll dp[20][2][20][5];


//用单词前三个的习惯。
ll dfs(int rem , int exit , int pre , int inc) {
	if (rem == 0) return exit;
	if (dp[rem][exit][pre][inc] != -1)
		return dp[rem][exit][pre][inc];

	ll &res = dp[rem][exit][pre][inc];
	res = 0;

	for (int i = 0; i <= 9; i++) {
		int inc_ = (i > pre) ? min(inc + 1 , 3) : 1;
		res += dfs(rem - 1 , exit || inc_ == 3 , i , inc_);
	}
	return res;
}

ll solve(ll x) {
	x++;//细节1
	vector<int> d;
	while (x) {d.push_back(x % 10); x /= 10;}
	//处理前导0的情况。
	ll ans = 0;
	int m = d.size();
	reverse(d.begin(), d.end());
	for (int i = 1; i < m; i++) {
		for (int j = 1; j <= 9; j++) {
			ans += dfs(i - 1, 0 , j , 1);
		}
	}
	//然后处理贴着上界走的情况。
	int exit = 0 , pre = 0, inc = 0;
	for (int i = 0; i < m; i++) {
		for (int j = (i == 0); j < d[i] ; j ++) {
			//同时要记录前缀的一些信息。
			int inc_ = (j > pre) ? min(inc + 1 , 3) : 1;
			ans += dfs(m - i - 1 , exit || inc_ == 3, j , inc_);
		}
		inc = (d[i] > pre) ? min(inc + 1, 3) : 1;
		pre = d[i];
		exit |= (inc == 3);
	}
	return ans;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	memset(dp , -1 , sizeof dp);
	ll l , r;
	cin >> l >> r;
	cout << solve(r) - solve(l - 1) << '\n';
}

```

### CF Round #739 (Div 3) F, Nearest Beautiful Number

[Problem - F2 - Codeforces](https://codeforces.com/contest/1560/problem/F2)

找到最小的 ， 满足大于等于n的， 美丽数位k的数字。

#### solve.

暴力搜索加剪枝：并不是数位dp的解法。

1. 可以估算复杂度非常小 ， 为n的字符值之和。

   1. dfs算法从可能的最小数字解开始进行枚举

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;

void work(int testNo)
{
	int  n , k; cin >> n >> k;
	vector<int> d;
	//尽量开大一点，拓展当前值域，增多可表达内容。
	int vis[10] {};
	while (n) {d.push_back(n % 10); n /= 10;}
	reverse(d.begin() , d.end());
	// x： 表示当前遍历的位置。 large，前缀是否大于规定的前缀。nums前面的k的前缀中数字的种数。
	function<bool (int , int , int , int)> dfs = [&](int x , int large , int nums , int cunt) {
		//能走到一步必然有解了。
		if (x == (int)d.size()) {
			cout << nums << '\n';
			return true;
		} else {
			//然后从哪里开始枚举呢？分情况。
			//如果已经large。那么就从0开始。否则从 d[x]开始
			for (int i = (large ? 0 : d[x]); i <= 9; i++) {
				//然后开始各种枚举枚举构造大法。
				vis[i] += 1;
				int ncunt = cunt;
				if (vis[i] == 1)ncunt += 1;
				if (ncunt <= k && dfs(x + 1 , large | (i > d[x]) , nums * 10 + i , ncunt)) {
					return true;
				}
				vis[i] -= 1;
			}
			return false;
		}
	};
	dfs(0 , 0 , 0 , 0);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

### **乘法**

[乘法 - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/185)

#### 简介：

将乘法转换成加减法组合的最小花费。

#### solve

1. 从高位到低位考虑：

   ​           定义$S_i$  = $a_{1}....a_i000000(i-1个0)$二进制串的值。T为前期操作地结果。

   1. 假设现在枚举到了第i位。要有解，必须满足：
      1. $S-T =0$或者$T-S=(1<<(i))$
      2. 否则，在低位进行任意加减操作。都不会把差异消除。

2. 状态设计

   从高位到低位对应 $i=1......i=n$

   $f_i$表示从高位开始考虑到了第i个位置。

   $g_i$表示从高位开始考虑到了第i个位置。$T_{i} - S_i=(2^{n-i})$

3. 初始化：

   1. $f_0=0,g_i=1$

4. 状态转移方程

   1. 如果$s_i='0'$
      1. 对于$f_i$有如下转移：
         1. $f_{i-1}$啥都不变。
      2. 对于$g_i$有如下方案
         1. $f_{i-1}$ , 对应方案加当前位权。
         2. $g_{i-1}$，对应方案减去当前位权。
   2. 如果$s_i='1'$
      1. 对于$f_i$
         1. $g_{i-1}$对应的方案减去当前位权。
         2. $f_{i-1}$对应的方案加上当前为位权。
      2. 对于$g_i$
         1. $g_{i-1}$对应的方案减去当前位权。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int f[N] , g[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	string s; cin >> s;
	int n = s.size();
	s = ' ' + s;
	fill(f , f + 1 + n , N);
	fill(g , g + 1 + n , N);
	f[0] = 0; g[0] = 1;
	for (int i = 1 ; i <= n; i++) {
		if (s[i] == '1' ) {
			f[i] = min(f[i - 1] + 1 , g[i - 1] + 1);
			g[i] = g[i - 1];

		} else {
			f[i] = f[i - 1];
			g[i] = min(f[i - 1] + 1 , g[i - 1] + 1);
		}
		//cout << "now is  " << i << "  " << f[i] << "  " << g[i] << '\n';
	}
	cout << f[n] * 2 - 1 << '\n';
}
```



-------------

###  P3188 [HNOI2007]梦幻岛宝珠

特殊的01背包问题。

特殊点：

1. 物品的重量大小比较特殊： $w = a2^b$

2. 背包总承受重量非常大。

#### 10mins

关注数字的特殊性：

1. 数字都是一个二进制数的倍数。
2. a , b都非常小。

可以优化值域，枚举一些特殊的二进制数字。

#### solve

考虑将背包按照b分组。

##### 关注几个现象

1. 同一组中的背包组合的体积大小都集中在部分区域：

![node](node.png)

面对这些现象可以采取什么样的策略？







### CCPC Changchun 2020 D, Meaningless Sequence

[CCPC Changchun 2020 D, Meaningless Sequence - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/315)

注意仔细地读标号。防止读错。

第一次读这道题地时候，没有发现 & 是位于下标中的。

#### solve

~~反正只知道 ， 是我一些不懂的规律。~~

打表可以发现 ， $a_n = c^{popcunt(n)}$

特别的有 ， $a_0 = 1$

自然而然地问题转换成了一道简单地数位dp。

##### solve1

dfs过程中枚举前缀。然后直接利用组合数计算贡献即可。

##### solve2

枚举任意前缀时，发现后缀的贡献总是：

$c^{pre(1)}\times(c + 1)^{sux\_len}$

##### code of solve1

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3E3 + 10;
const ll mod = 1E9 + 7;

string s;
ll c;
ll d[N][N][2] , C[N][N] , p[N];
int n;

ll dfs(int rem ,  int sum , bool larger) {

	if (rem == 0) return p[sum];
	if (larger == false) {
		ll res  = 0;
		for (int i = 0; i <= rem ; i ++)
			res += (p[sum] * C[rem][i] % mod) * p[i] % mod;
		return res;
	}
	ll res = 0;
	for (int i = 0; i <= s[n - rem] - '0'; i++) {
		res = (res + dfs(rem - 1, sum + (i == 1) , i == (s[n - rem] - '0'))) % mod;
	}
	return res;
}

void intit() {
	cin >> s >> c;
	n  = s.size();
	p[0] = 1;
	for (int i = 1; i < N; i++) p[i] = p[i - 1] * c % mod;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j <= i; j++) {
			if (j == 0) C[i][j] = 1;
			else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	intit();
	cout << dfs(n , 0 , true) << '\n';

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

##### code of solve2

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int mod = 1E9 + 7;
ll p[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	string s; int c;
	cin >> s >>  c;
	int n = s.size();

	p[0] = 1;
	for (int i = 1 ; i <= n; i++) {
		p[i] = p[i - 1] * (c + 1) % mod;
	}

	ll pre = 1 , ans = 0;
	for (int i = 0; i < n; i++) {
		if (s[i] == '1') {
			ans  = (ans + pre * p[n - i - 1]) % mod;
			pre = pre * c % mod;
		}
	}
	cout << (pre + ans ) % mod << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

### **CCPC Jinan 2020 L, Bit Sequence**

[CCPC Jinan 2020 L, Bit Sequence - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/316)

[L-Bit Sequence_第 45 届国际大学生程序设计竞赛（ICPC）亚洲区域赛（济南） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/10662/L)

#### 简介

定义$f_{i}$为i的二进制串中的1的个数。给定一个01序列$a_{0...m-1}$。求取$[0....x-1]$中，满足对于任意$0<=i<m,f(x+i)\%2=a_i$

#### solve

观察一些现象：

1. 由于m的范围比较小。因此两个数字相加，结果相比于x， m只能影响低7位。而前面高位的奇偶性，不会受到影响。

**树哈希**

#### 解决问题：

1. 快速判断树是否同构的问题：
   1. 同构的概念：对一棵树 ， 进行对同父亲的子树进行互换。进行若干次操作后，两颗树可以相等。那么称这棵树是同构的。



参考：[一种好写且卡不掉的树哈希 - 博客 - peehs_moorhsum的博客 (uoj.ac)](https://peehs-moorhsum.blog.uoj.ac/blog/7891)

#### 算法简介

关注树结构的属性： 定义一个哈希函数。
科学的定义一个哈希函数。

1. 根哈希函数，代表了当前子树的结构情况。
2. 哈希函数 ， 和子树的哈希函数联系。
   最终就是要降不同的子树结构不会落入同一个哈希值的概率。
     这里直接找一些大佬的哈希函数设计。

#### 入门问题

1. (https://codeforces.com/contest/1800/problem/G)

#### 板子

邓老师

```cpp
using ll = long long;
using Ull = unsigned long long;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
Ull bas = rnd();
//Ull bas = (Ull)1E18 + 7;
void work(int testNo)
{
	int n;  cin >> n;
	vector<vector<int>> e(n);
	for (int i = 1; i < n; i++) {
		int u, v; cin >> u >> v;
		u--; v--;
		e[u].push_back(v);
		e[v].push_back(u);
	}

	vector<Ull> h(n), f(n);
	function<Ull(Ull)> H = [&](Ull x) {
		return x * x * x * 19890535 + 19260817;
	};

	function<Ull(Ull)> F = [&](Ull x) {
		return H(x & (((1ll << 32) - 1))) + H(x >> 32);
	};

	function<void(int, int)> dfs = [&](int u, int par) {
		h[u] = bas;
//
		for (auto v : e[u]) if (v != par) {
				dfs(v, u);
				h[u] += F(h[v]);
//				rec[h[v]].push_back(v);
			}
		//cout << "no is " << u << " " << rec.size() << '\n';
		//通过节点的hash值情况进行一些哈希。
	};
}
```

----------------

# 补题

## 二分

**D. Maximum Subarray**
https://codeforces.com/contest/1796/problem/D

#### 简介

给定n组数组。每一个数组长度为m。
定义一种运算。选定数组$a , b$ 进行与运算 ，运算结果为$c_i = max(a_i ,  b_i)$ 。选定任意两个数组，运算得到值域{$c$}.找出, $min (max(b_i))$.

#### solve

1. 第一个点是敏锐的感受到是二分查找问题。
   1. 设计check函数上：枚举x。对于任意一个数组 ， 都映射到一个长度为n数字d上。如果$b_i >= x$ . $d_i =1 $else $d_i = 0$。如果存在两个数组之间进行max运算之后的最小值大于等于x。那么必然运算的结果是所有二进制位上都为1的数字。
2. 投射到小值域。鸽笼定理：只需要关注解的存在性。高达$2^5$的数组数量。对于d的集合。必然都映射到d的集合上。这样就将数字分成了若干类。只需要枚举$0  <= d <=1^m - 1$这几类的数字d即可。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int a[N][11];
int  n , m;
int a1 , a2;

bool check(int x)
{
	int t = 1 << (m);
	vector<int> rec(t , - 1);
	//然后
	for (int i = 0; i  < n; i++) {
		int now = 0;
		for (int j = 0; j < m; j++) {
			if (a[i][j] >= x) now |= (1 << j);
		}
		rec[now] = i;
	}
	t --;
	if (rec[t] != -1) {
		a1 = a2 = rec[t];
		return true;
	}
	for (int i = 0; i < t; i++)
		for (int j = i + 1; j <= t; j++) {
			if (rec[i] != -1 && rec[j] != -1 && (i | j) == t) {
				a1 = rec[i]; a2 = rec[j];
				return true;
			}
		}
	return false;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> a[i][j];
	int low = 0 , high = 1E9 + 10;
	while (low < high) {
		int mid = (low + high + 1) / 2;
		if (check(mid))
			low = mid;
		else high = mid - 1;
	}
	cout << a1  + 1 << ' ' << a2 + 1 << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

## 二分

***D. Renting Bikes***
https://codeforces.com/problemset/problem/363/D

#### 题目简介

有n个学生。他们之中有公共的可使用的钱 记为$a$ . 每一个学生有自己的钱。它们去租自行车。但是他们自己的钱买自己的自行车。公共的钱可以任意的分配。问最多可以有多少人拥有自行车。同时使得他们自己付出的钱最少。

#### solve

1. 尝试二分。枚举一个数字x ， check： 购买自行车的数量是否可以达到这个数字。
   1. 最保守的策略是，钱最多的x个人， 一一匹配买最便宜的x辆自行车。如果不够就去补
      1. 如果其它结构可以买到x辆。那么上述的购买策略也一定合理。
      2. 所以上述购买的策略是边界策略。作为check的标准。
2. 花钱最小
   1. 有多少补多少。显然就是$min(sum - a , 0)$.sum指的是所有单车的价格。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

ll  n , m , a;
ll p[N] , b[N];

bool check(int x) {
	ll sum = 0;
	for (int i = 1; i <= x; i++) {
		sum += max(0LL , b[i] - p[n - x + i]);
	}
	return sum <= a;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m >> a;
	for (int i = 1; i <= n; i++)cin >> p[i];
	for (int i = 1; i <= m; i++) cin >> b[i];

	int low = 0 , high = min(n , m);
	sort(p + 1 , p + n + 1);
	sort(b + 1, b + m + 1);
	while (low < high) {
		int mid = (low + high + 1) / 2;
		if (check(mid))low = mid;
		else high = mid - 1;
	}
	ll sum = 0;
	for (int i = 1; i <= low ; i++) {
		sum += b[i];
	}
	cout << low << ' ' << max(0LL , sum - a) << '\n';
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



## div3 位压

**F. Dasha and Nightmares**

https://codeforces.com/contest/1800/problem/F

#### 简介

1. 给定若干个字符串
2. 找出若干对字符串满足：

#### solve

管理字符串的方法： 

1. 压位，表示当前字符串中的各种字符出现了多少次。
   1. 如果简单的压位记录。会丢弃掉某个字母是否存在的信息。、

计算答案：

##### solve1

1. 枚举一个字母 ， 表示在拼接串中该字母不存在。
2. 然后扫一遍。
   1. 但是初始化f的花费将会非常的大。
   2. 算法复杂度会达到$\sum |s| + 2^26*26$



##### solve2

1. 在扫描的过程中。开一个巨大的map 或者 unorder_map
2. 直接记录 ， 统计即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n ;
	cin >> n;
	ll ans = 0;
	int mask = (1 << 26) - 1;
	unordered_map <int, int > rec[26];
	for (int i = 1; i <= n; i++) {
		string s; cin >> s;
		int ch = 0 , bit = 0;
		for (auto c : s) {
			ch |= 1 << (c - 'a');
			bit ^= 1 << (c - 'a');
		}
		for (int i = 0; i < 26; i++) {
			if (!(ch & (1 << i) )) {
				ans += rec[i][bit ^ mask ^ (1 << i)];
				rec[i][bit]++;
			}
		}
	}
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





##### solve3

认识到抽象出来的26位是比字符串数量更大的。考虑在1的基础上做出改进。

1. 初始化数组的时候，只要枚举所有字符串的种类即可。贡献是$O(n)*26$
2. 统计上的复杂度是$O(n)$
3. 预处理字符串的花费是$O(\sum |s|)$

```cpp
//这回只花了114514min就打完了。
//真好。记得多手造几组。ACM拍什么拍。 
#include "bits/stdc++.h"
using namespace std;
template<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }
template<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }
template<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }
template<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\n'; return cout; }
template<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }
template<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }
template<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }
template<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }
#if !defined(ONLINE_JUDGE)&&defined(LOCAL)
#include "my_header\debug.h"
#else
#define dbg(...) ;
#define dbgn(...) ;
#endif
typedef unsigned int ui;
typedef long long ll;
#define all(x) (x).begin(),(x).end()
// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }
// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }
const int N=1<<26;
int cnt[N];
int main()
{
	ios::sync_with_stdio(0); cin.tie(0);
	cout<<fixed<<setprecision(15);
	int n,i,j,k;
	cin>>n;
	vector<int> a(n),b(n);
	for (i=0; i<n; i++)
	{
		string s;
		cin>>s;
		for (auto c:s) a[i]|=1<<c-'a',b[i]^=1<<c-'a';
	}
	ll r=0;
	for (k=0; k<26; k++)
	{
		int B=(1<<26)-1^(1<<k);
		for (i=0; i<n; i++) if (1^a[i]>>k&1)
		{
			++cnt[b[i]];
			r+=cnt[b[i]^B];
		}
		for (i=0; i<n; i++) if (1^a[i]>>k&1) --cnt[b[i]];
	}
	// for (i=0; i<n; i++) for (j=i; j<n; j++) if (__builtin_popcount(a[i]|a[j])==25&&__builtin_popcount(b[i]^b[j])==25) ++r;
	cout<<r<<endl;
}

```

## 动态规划 刷题

**删括号**

[删括号 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21303)

#### solve

关注一些解结构：

1. 发现最终删除的括号必然是连续排的。

定义状态： $d_{i , j , k}$表示对于$s_{0..i}$删去k个删去若干个括号，此时左括号数目减去右括号数目为k情况下$s_{0....i}和t_{0....j}$是否匹配。

2. 考虑各种迁移情况：
   1. 假设当前$dp_{i , j , k}$为false。无论怎么对当前位怎么操作最后都是false.
   2. 如果当前$dp_{i , j ,k}$为true，且k为0.当前遇到了$')'$显然错误因为追求的是连续的删除。
   3. 如果当前$dp_{i, j , k}$为true ，遇到$'('$ ， 那么连续删除的括号加1.
   4. 如果当前$dp_{i , j , k}$为true ,  遇到$')'$，那么连续的$'('$被抵消掉一个。
3. 体会到迁移总是正确的。（复习的话体会不到就继续体会。qaq）

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 100 + 10;
bool dp[N][N][N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s , t;
    cin >> s >> t;
    s += ' ';
    t += ' ';
    s = ' ' + s;
    t = ' ' + t;
    int n = s.length()  -  1, m = t.length() - 1;
    dp[0][0][0] = true;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i ; j++)
            for (int k = 0; k < n / 2; k ++) {
                if (dp[i][j][k]) {
                    if (k == 0 && s[i + 1] == t[j + 1])
                        dp[i + 1][j + 1][k] = true;
                    if (s[i + 1] == '(')
                        dp[i + 1][j][k + 1] = true;
                    else if (k)
                        dp[i + 1][j][k - 1] = true;

                }
            }
    string ans[2] = {"Impossible\n" , "Possible\n"};
    cout << ans[dp[n][m][0]];
}
```

**美丽序列**
https://ac.nowcoder.com/acm/problem/21313

#### solve

这种问题的解空间非常清晰明了。
关注几种属性进行分类

1. i ，表示考虑了前i个元素。
2. j ，表示结构的尾数位j
3. k ,   表示连续下降的位数是k.
4. sum  结构的和位sum.

通过枚举上述情况 ， 就可以一条不漏的得到了所有的可能。并且完成迁移。这种模型的解是非常容易统计的。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 60;
const int mod = 1E9 + 7;

int a[N];
ll dp[N][N][3][1700];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;  cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	dp[0][0][0][0] = 1;
	//
	for (int t = 1; t <= n; t++) {
		//枚举当前位置上放的东西
		for (int now = 0; now <= 40; now ++)
			//枚举尾数
			for (int i = 0; i <= 40; i++)
				//枚举连续长度
				for (int j = 0; j < 3; j++)
					//枚举前面的平均数
					for (int k = 0; k <= 1600; k ++) {
						if (a[t] != -1 && now != a[t])continue;
						if ((now < i && j == 2) || (now * (t - 1) > k))continue;
						if (now < i)
							dp[t][now][j + 1][k + now] = (dp[t][now][j + 1][k + now] + dp[t - 1][i][j][k]) % mod;
						else dp[t][now][1][k + now] = (dp[t - 1][i][j][k] + dp[t][now][1][k + now]) % mod;
					}

	}
	ll ans = 0;
	for (int i = 0; i <= 40; i ++)
		for (int j = 0; j < 3; j ++)
			for (int k = 0; k <= 1600; k++)
			{	ans += dp[n][i][j][k];
				ans %= mod;
			}
	cout << ans << '\n';
}
```

**codeforces**

(https://ac.nowcoder.com/acm/problem/21314)

#### 简介

看题就行。



#### solve

1. 观察所有解空间 ， 枚举任何解。对于一组具体的方案。可以先考察问题的解决顺序 ，优秀子集。各种问题的解决顺序 ， 必然满足一些上界。
   1. 优秀子集这里自定义为 ：所有枚举的解都可以在这个子集中找到更优的等效解。

顺序的探究：
对于一组解中，任意相邻的任务(假设存在两个以上的任务。不妨标记其为1 ， 2。其中分别完成时间为$t_1 , t_i$，价值损失速度为$p_1 , p_2$。开始做第一个任务时候。其分数和为sum.
关注两个量：$s_{1 , 2}$表示先1后2.$s_{2,1}$反之。
$$
s_{12} = sum - t_1p_1 - (t_1 + t_2)p_2\\
s_{21} = sum - t_2p_2 - (t_1 + t_2)p_1\\
s_{12} - s_{21}=t_2p_1-t_1p_2.\\
s_{12}-s_{21}>=0\\
\frac{p_1}{t_1}>=\frac {p_2}{t_2}
$$

利用这个递推序列排一个序。满足任何相邻的元素都满足上述关系。

2. 利用上述规则

   1. 考察任何一个方案$a$。并且从优秀子集中的方案$b$映射到该方案。
   2. 通过对b不断地调整。发现一种总分数一直减少的方案可以构造到该方案中。而一个方案只有一个结构。上述构造逐步计算的过程是等价过程。

3. 综上，在上述顺序的数组上做01背包即可。

   $f_{i , j}$表示j状态下 ,完成j道题的最大方案。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const ll inf = 1E18;

ll t[N] , p[N] , f[N] , v[N];
int id[N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n , T; cin >> n >> T;
    for (int i = 1; i <= n; i++)
        cin >> v[i];
    for (int i = 1; i <= n; i++)
        cin >> p[i];
    for (int i = 1; i <= n; i ++)
        cin >> t[i];
    iota(id , id + n + 1 , 0);
    sort(id + 1 , id + 1 + n , [&](int i , int j) {
        return 1.0 * p[i] / t[i] > 1.0 * p[j] / t[j];
    });
    //  cerr << id[1] << '\n';
    //状态设计表示刚好完成i任务。j时间下的最大成就。
    ll ans = 0;
    for (int x = 1; x <= n; x++) {
        int i = id[x];
        for (int j = T; j  >= t[i]; j--) {
            f[j] = max(f[j] , f[j - t[i]] + v[i] - j * p[i]);
        }
    }
    for (int i = 0; i <= T; i++) {
        ans = max(ans , f[i]);
    }
    cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 生长思考：

1. 非常精彩的解空间压缩。

   这里的解空间优化。转换成了一个01背包问题。关注了一个优秀的解集。而这个解集就是做01背包的解集。


-----------

**和与或**

[和与或 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21336)

#### solve

观察出一个性质 ：从二进制的角度看 ，  若干个数相加，二进制串的某一个位上不能够有进位。

不断地枚举最终和的数字前缀：
对于任意二进制串前缀：

1. 当前位置为1时 ， 那么要有一个A提供1。其它的数在该位上提供0。

2. 按照这样的枚举方法。由乘法计数原理，所有情况都考虑齐全。
   观察枚举过程中 ， 一些可以重复利的信息。在枚举的过程中，对于$a_i$有两种属性——是否被限制（前缀是否贴着上界前缀走。）这决定了 ， 当前情形下 ， 这些数字是当前位置上可以取的数字。
     那么这时可以感受到， 后面的选择和当前的0 ， 1相关。（形象地看，就是后续发展的子树相同。可以记录这一类子树的叶子数）

3. 状态设计
   $dp_{i , j }$ 表示当前在枚举第i位情况下 ，j 表示限制情况（状态压缩的方法，如果i位上为0表示 第i个数字的枚举被限制。为1反之）

4. 始化化：
   初始化为-1。从dfs(62 , 0)$开始搜索。

5. 状态转移
   如果sum当前的位置上选择0  ， 其余所有项选0。此时那些原本被限制的 ， 并且当前位上为1的下沉。 
   如果sum当前位置上选择1 。有下面两种情况：
   1. 非限制数字选择1.
      1. 此时原本被限制的且上界的当前位上为1的 数字不再被限制。
   2. 限制位数字且上界该位置上本来就有1。
      1. 同上 。

#### 生长思考

1. ~~那么神奇，怎么思考？~~
2. 体会到了数位dp中贴上界问题在数位dp中存在的现象。多个数枚举制约下的限制 ， 以及上界数的下沉。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int mod = 1E9 + 9;

ll a[N] , dp[100][1050];
int n;

ll dfs(int pos , int limit) {
	if (pos == -1)return 1;
	if (dp[pos][limit] != -1) return dp[pos][limit];

	ll& res = dp[pos][limit];
	res = 0;
	//记录拿一些a在当前的pos上为1
	int rec = 0;
	for (int i = 0; i < n; i++)
		if (a[i] & (1LL << pos)) {
			rec |= 1LL << i;
		}
	res += dfs(pos - 1 , limit | rec);
	//考虑的当前pos上取1的情况。
	//枚举哪一一个1在这个位置上可以做出贡献
	for (int i = 0; i < n; i ++)
		if (limit & (1LL << i))
			res = (res + dfs(pos - 1 , limit | rec)) % mod;
		else if (rec & (1LL << i))
			res = (res + dfs(pos - 1 , (limit | rec) ^ (1LL << i))) % mod;
	return res;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	memset(dp , -1 , sizeof dp);
	cout << dfs(61 , 0) << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

--------------

**牛牛与数组**

https://ac.nowcoder.com/acm/problem/21738

#### 状态设计

1. 定义$f_{i , j}$表示当前数组 ， i位置上放置的是j元素。



#### 状态转移

前缀和优化 ， 再加上一个类似线性筛选的东西。类比埃氏筛法，复杂度为$klogk$

总复杂度为$n*k*log(k)$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int mod = 1e9 + 7;
ll f[20][N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , k; cin >> n >> k;
	f[0][1] = 1;
	for (int i = 1; i <= n ; i++) {
		//首先对这个数组的前缀和来一个小的处理：
		ll sum = 0;
		for (int j = 1; j <= k; j ++)
			sum = (sum + f[i - 1][j]) % mod;
		for (int j = 1 ; j <= k; j++) {
			f[i][j] = sum;
			for (int t = j * 2; t <= k; t += j)
				f[i][j] = (f[i][j] - f[i - 1][t] + mod) % mod;
		}
	}
	ll ans = 0;
	for (int i = 1; i <= k; i++) {
		ans = (ans + f[n][i]) % mod;
	}
	cout << ans << '\n';

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

----------

**牛牛的回文串**

[牛牛的回文串 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21337)

给定各种操作的代价。包括增，删 ， 改。
求将该字符串变成回文串的最小代价。

#### 10mins

这种解空间探究 ， 无从下手：

1. 小规模问题是什么？体会不了。
2. 解空间中。各种操作应用都非常灵活，看上去毫无联系。

#### solve

1. 第一个问题 ， 对于任何一个操作。就结果而言（比方说，换 ，删）并不只有一个方案。可以先改成某一些值再删除 ， 所以得先把这些最优操作的代价求出来。（解结构的优化之一）。
   1. 这一个操作可以通过floyed求取。
   2. 处理掉一个字符
      1. 直接的删掉。
      2. 先转换再删掉。
      3. 先在对称的位置增加一个字符，两个匹配掉（对其他字符不产生影响）。
      4. 在对称位置增加一个字符，两个字符同时成k字符。
   3. 字符转换：
      1. 转换中间字符最小代价。

2. 关于状态设计：
   $dp_{i , j}$表示将 i....j的子段变成回文串的最小花费。
3. 状态转移
   对于计算$dp_{i , j}$ ， 发现有几种策略。考虑各种方案。
   1. $s_i和s_j$进行匹配。
      1. 统一换成同一个字母。
   2. $删掉s_i$
   3. $删掉s_j$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
const int oo = 1E9;
//#define int ll
string s;
//表示转换
ll cost[26][26], add[26], erase[26];
ll deal[26];
//表示删除。或者增加成一个删掉。
ll dp[100][100];
void floyed() {
	for (int k = 0; k < 26; k++)
		for (int i = 0; i < 26; i++)
			for (int j = 0; j < 26; j++) {
				cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
			}
	//计算删除的最小信息。
	//删除的最小代价怎么统计？
	for (int i = 0; i < 26; i++) {
		deal[i] = erase[i];
		for (int j = 0; j < 26; j++) {
			//不借助中间字符。直接删增，匹配掉。
			//改删
			deal[i] = min(deal[i], cost[i][j] + erase[j]);
			// 改改。
			//增改改。
			for (int k = 0; k < 26; k++)
				deal[i] = min(deal[i], add[j] + cost[i][k] + cost[j][k]);
		}
	}
}
void init() {
	for (int i = 0; i < 26; i++) {
		for (int j = 0; j < 26; j++) {
			cost[i][j] = oo;
		}
		cost[i][i] = 0; add[i] = erase[i] = deal[i] = oo;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	init();
	int n; cin >> s >> n;
	for (int i = 1; i <= n; i++) {
		string ch; cin >> ch;
		char a, b; ll c;
		if (ch == "change") {
			cin >> a >> b >> c;
			cost[a - 'a'][b - 'a'] = min(cost[a - 'a'][b - 'a'], c);
		}
		else if (ch == "add") {
			cin >> a >> c;
			add[a - 'a'] = min(c, add[a - 'a']);
		}
		else {
			cin >> a >> c;
			erase[a - 'a'] = min(erase[a - 'a'], c);
		}
	}
	floyed();
	int sz = s.size();
	for (int i = sz - 1; i >= 0; i--) {
		for (int j = i + 1; j < sz; j++) {
			dp[i][j] = oo;
			if (s[i] == s[j])dp[i][j] = dp[i + 1][j - 1];
			dp[i][j] = min(dp[i][j], deal[s[i] - 'a'] + dp[i + 1][j]);
			dp[i][j] = min(dp[i][j], deal[s[j] - 'a'] + dp[i][j - 1]);
			for (int k = 0; k < 26; k++)
				dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + cost[s[i] - 'a'][k] + cost[s[j] - 'a'][k]);
		}
	}
	if (dp[0][sz - 1] == oo)
		cout << -1 << '\n';
	else cout << dp[0][sz - 1] << '\n';
	//return 0LL;
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

------------

**牛牛去买球**

[牛牛去买球 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21668)

#### solve

简化问题 ， 找一个解：

1. 每一个包里面的红球、蓝色球的数量变化1。无论如何变化 ， 同色的球的数量至少为k。
2. 寻找满足上条件 ， 花费最低的解。

关注几种解结构：

1. 所有商品中 ， 红球的数量都减1。
2. 所有商品中，蓝球的数量都减1。

只考虑这两种情况是不全面的。如下：

但是还是遗漏了一些解：反例如下：

```cpp
2 10
6 5
4 4
1 1
```

​       该情况下 ， 无法做到两个减到最小值。但是两个都选了， 由于一个包里面球数量守恒，无论怎么变化依然满足条件。其关键是两种球数目之和大于等于$2*k - 1$。很显然，平均使得最大值最小，依然大于等于k.

​        反之 ， 如果总的球数小于$2*k - 1$。解满足题意得充要条件是，两种球中的一种，减到极限了也依然满足数量大于等于k。前述两种情况下，01背包得到的就是这种解的最优值。

1. 不妨设当前的子问题为蓝色球（最劣情况）。显然$f_i$通过背包求解后，其解就是满足蓝色球减到极限了 ， 也满足题意的最小价值的解。那么我们枚举任意一种总球数小于2*k - 1的合法的（蓝色球减到极限，也满足大于等于k条件）解。显然可以属于上述子问题解集（并不一定是最优解，其实问题的解就是满足基本条件的解集中取最优值。）那么$f_i$更优。

1. 反之红色球亦然。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const ll inf = 1E15;
int a[N] , b[N] , v[N];
//当前的最小值是什么？
//考虑了前i个商品。
//选择了多少个商品。
//是哪一类球更多
ll f[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , k; cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) cin >> b[i];
	for (int i = 1; i <= n; i++) cin >> v[i];
	ll ans = inf;
	memset(f , 0x3 , sizeof f);
	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		int w = a[i] - 1;
		for (int j = 50000; j >= w ; j --)
			f[j] = min(f[j] , f[ j - w] + v[i]);
	}
	for (int i = k; i <= 500000; i++) {
		ans = min(ans , f[i]);
	}
	memset(f , 0x3 , sizeof f);
	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		int w = b[i] - 1;
		for (int j = 50000; j >= w ; j --)
			f[j] = min(f[j] , f[j - w] + v[i]);
	}
	for (int i = k; i <= 500000; i++) {
		ans = min(ans , f[i]);
	}
	memset(f , 0x3 , sizeof f);

	f[0] = 0;
	for (int i = 1; i <= n; i++) {
		int w = b[i] + a[i];
		for (int j = 50000; j >= w ; j --)
			f[j] = min(f[j] , f[j - w] + v[i]);
	}
	for (int i = k * 2 - 1; i <= 500000; i++) {
		ans = min(ans , f[i]);
	}
	if (ans == inf) ans = -1;
	cout << ans << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

----------

**牛牛的计算机内存**

[牛牛的计算机内存 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21873)

#### 简介

找出一种指令顺序，使得访存代价花费的时间最小：时间代价的计算方式是
新的访问代价为：

#### solve

状压dp.
将选择状态压缩为s ， 第i - 1位置上为1，意味着这个任务已经选了.
定义$dp_{s}$：当选择情况为s。前面的最小代价。（选择的先后，不影响最终内存的使用情况。）
状态转移方程：

1. $dp_{s}$枚举，上一个s的状态是什么。然后迁移即可。

完成的一些任务：

1. 字符串到二进制之间的转换。
2. 统计某些任务使用之后的，内存的剩余使用情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define end en

const int N = 1E6 + 10;
int bit[100];
int end[1 << 20];
ll dp[1 << 20];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		string s; cin >> s;
		int now = 0;
		for (int j = 0; j < m; j++) {
			if (s[j] == '0')continue;
			else now |= (1 << j);
		}
		bit[i] = now;
	}
	auto f = [&](int x, int y) -> int{
		//表示x。当前是选择哪一个任务？
		//y表示前面的额基础情况。
		//这个函数的目的就是计算出有多少的位置是不一样的。
		int k = 0;
		for (int i = 0; i < m; i++) {
			if (((bit[x] >> i) & 1) && (end[y] >> i & 1) == 0)
				k++;
		}
		return k;
	};
	memset(dp , 0x3f , sizeof dp);
	dp[0] = 0;
	for (int s = 1; s < (1 << n); s++) {
		for (int j = 0; j < n; j++) {
			//说明当前有
			if (s & (1 << j)) {
				int k = f(j, s ^ (1 << j));
				dp[s] = min(dp[s] , dp[s ^ (1 << j)] + k * k);
				end[s] = end[s ^ (1 << j)] | bit[j];
			}
		}
	}
	cout << dp[(1 << n) - 1] << '\n';

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

这是见过的一道最简单的状压dp了。

--------------

# ATcoder

**XYYYX**

[My Submissions - AtCoder Regular Contest 157](https://atcoder.jp/contests/arc157/submissions/me)

#### solve

定义一些概念：
x表示X符的个数。n表示字符长度。$pos_{i}$表示字符串中第（i + 1）个‘Y’的位置：

先分类讨论几种情况：

1. $x\ge k$，正常贪心。尽量使得YXXXY 之间的X被填满。设这种子串处理了 ， a个。那么相比于其它一些非同类操作，其贡献至少增加a个。
2. $x<k$，该情况下处理完‘X’字符后 ， 还有一些剩余的修改机会。
   1. ==证明==关于先处理完‘X’字符，显然，如果没有处理完，就说明有两次得到‘Y’的机会被白白浪费了。可以拿出处理Y的操作来处理x。无论何种情形，处理完‘X’总是最优的。
   2. 处理完x之后，那么剩下的操作次数在处理Y中如何分配？
      1. 使用等效转换的逆向思维。将问题转换成：土著‘Y’全部变成了‘X’，然后一定量操作机会下，它他们变成‘Y’。求最优解。于是转换成了第一种情况下同样的问题。

实现方式，先分类讨论，进行预处理，然后使用优先队列进行维护。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
int sum[N] , pre[N];
int  n , k , ans;;
string s;

void solve() {
	vector<int>pos;
	for (int i = 1; i <= n; i++)
		if (s[i] == 'Y')pos.push_back(i);
	if (pos.size() == 0) {
		cout << max( k - 1 , 0) << '\n';
		return;
	}
	priority_queue<int , vector<int> , greater<int>> que;
	//对于连续段应该怎么吃处理？
	for (int i = 1; i < (int)pos.size(); i++) {
		if (pos[i] == pos[i - 1] + 1)ans++;
		else que.push(pos[i] - pos[i - 1] - 1);
	}
	while (que.empty() == false && k) {
		int top = que.top(); que.pop();
		if (top <= k) {
			ans += top + 1;
			k -= top;
		} else {
			ans += k;
			k = 0;
		}
	}
    /*处理两端的情况*/
	ans += k;
	cout << ans << '\n';
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> k;
	cin >> s;
	s = ' ' + s;
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + (s[i] == 'X');
	}
	if (k > sum[n]) {
		for (int i = 1; i <= n; i++) {
			if (s[i] == 'X')s[i] = 'Y';
			else s[i] = 'X';
		}
		k = n - k;
	}
	solve();

}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*2023/3/5 陈九日
*/
```

# 区间动态规划进阶



### **ICPC Beijing 2017 J, Pangu and Stones**

[ICPC Beijing 2017 J, Pangu and Stones - 题目 - Daimayuan Online Judge](http://oj.daimayuan.top/course/8/problem/327)



#### 题目简介

1. 石子合并问题：

   对一堆石子，合并连续的连续长度为$[L,R]$的石子。

和最简单的区间动态规划问题不同。这里对连续合并的石堆个数有限制。

#### solve

1. 显然不能简单的枚举每一堆的分界点。

定义一个状态：

$f_{i,j,k}$表示$i,j$ ， 为和并为k堆的最小代价。

辅助状态的转移方程。

1. 枚举i , j。
2. 枚举k。
3. 枚举第一堆的的尾部。

$$
k\ge2;f_{i,j,k}=min(f_{i,mid,1}+f_{mid+1,r,k-1})\\
k=1;f_{i,j,1}=min(f_{i,j,2...k}+sum_{l...r})
$$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define f dp

const int N = 110;
const int inf = 1 << 29;
int n , L , R;
int f[N][N][N];
int sum[N];

void solve() {
	for (int i = 1; i <= n ; i++) {
		int x; cin >> x;
		sum[i] = sum[i - 1] + x;
	}
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= n; k++)
				f[i][j][k] = inf;
	for (int d = 0; d <= n ; d++) {
		for (int l = 1; l + d <= n; l++) {
			int r = l + d;
			if (d == 0) {
				f[l][r][1] = 0;
			} else {
				for (int k = 2; k <= n; k++) {
					for (int mid = l ; mid < r; mid ++) {
						f[l][r][k] = min(f[l][r][k] , f[l][mid][1] + f[mid + 1][r][k - 1]);
					}
					if (k >= L && k <= R) f[l][r][1] = min(f[l][r][k] , f[l][r][1]);
				}
				f[l][r][1] += sum[r] - sum[l - 1];
			}
		}
	}
	if (f[1][n][1] >= inf) cout << 0 << '\n';
	else cout << f[1][n][1] << '\n';
}


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	while (cin >> n >> L >> R)solve();

}
```

----------

# $\Large 2023/3/5$

