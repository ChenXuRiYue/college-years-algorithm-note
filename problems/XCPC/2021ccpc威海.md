# 2021ccpc威海

X 国是一个繁荣的自由贸易国家，有 $n$ 个城市由 $n-1$ 条双向道路连接。虽然 X 国一直非常稳定，但商人们普遍对城市安全非常敏感。他们希望 X 国能加强公安力量，确保城市安全。

此外，商人还关注周边地区的安全。因此，如果一個城市的保安力量加強了，但附近城市的保安力量沒有加 強，他們仍會擔心附近城市受到威脅。

从形式上看，要加强城市 $i$ 的安保力量，就要付出 $w_i$ 的代价。这样的努力不会白费，因为会吸引更多的商人，X 国也会从中受益。如果每个与城市 $i$ 距离小于或等于 $p$ 的城市都得到加强，城市 $i$ 将比以前获得 $v_p$ 更多的收入。(如果满足条件的 $p$ 不止一个，则只考虑最大的一个）。

现在，你作为国家官员，被任命来处理这个问题。你的目标是获得最大收益（增加的收入减去加强安全部队的成本）。

**输入**

第一行包含一个整数 $n$ ( $1 \le n \le 200$ )，代表 X 国的城市数量。

第二行包含 $n$ 个整数 $w_1,w_2,\cdots,w_n$ ( $1 \le w_i \le 10^5$ )，代表在城市 $i$ 加强安全部队的成本。

第三行包含 $n$ 个整数 $v_0,v_1,\cdots,v_{n-1}$ （ $1 \le v_i \le 10^5,\ v_i \le v_{i+1}$ ）。( $1 \le v_i \le 10^5,\ v_i \le v_{i+1}$ ) 代表上述收益。

接下来的 $n-1$ 行分别包含两个整数 $u,v$ ( $1 \le u,v \le n,\ u\neq v$ )，表示城市 $u$ 和 $v$ 之间有一条双向道路。

### solve

**网络流方法：**

转换成最小割：



### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 200 + 10;

int w[N] , v[N];

vector<int> adj[N] , d[N];

const int V = 50100;
const int E = 501000;
template<typename T>
struct FlowGraph {
    int s, t, vtot;
    int head[V], etot;
    int dis[V], cur[V];

    // 邻接表存储。
    // 这样可以方便建立反边^1。

    struct edge {
        int v, nxt;
        T f;
    } e[E * 2];
    void addedge(int u, int v, T f) {
        e[etot] = {v, head[u], f}; head[u] = etot++;
        e[etot] = {u, head[v], 0}; head[v] = etot++;
    }

    bool bfs() {
        for (int i = 1; i <= vtot; i++) {
            dis[i] = 0;
            cur[i] = head[i];
        }
        queue<int> q;
        q.push(s); dis[s] = 1;

        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; ~i; i = e[i].nxt) {
                if (e[i].f && !dis[e[i].v]) {
                    int v = e[i].v;
                    dis[v] = dis[u] + 1;
                    if (v == t) return true;
                    q.push(v);
                }
            }
        }
        return false;
    }

    T dfs(int u, T m) {
        if (u == t) return m;
        T flow = 0;
        for (int i = cur[u]; ~i; cur[u] = i = e[i].nxt)
            if (e[i].f && dis[e[i].v] == dis[u] + 1) {
                T f = dfs(e[i].v, min(m, e[i].f));
                e[i].f -= f;
                e[i ^ 1].f += f;
                m -= f;
                flow += f;
                if (!m) break;
            }
        if (!flow) dis[u] = -1;
        return flow;
    }

    T dinic() {
        T flow = 0;
        // 从起点开始bfs，确定分层图。 然后开始增广。
        //
        while (bfs()) flow += dfs(s, numeric_limits<T>::max());
        return flow;
    }
    void init(int s_, int t_, int vtot_) {
        s = s_;
        t = t_;
        vtot = vtot_;
        etot = 0;
        for (int i = 1; i <= vtot; i++) head[i] = -1;
    }
};

FlowGraph<int> g;

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> w[i];
    for (int i = 1; i <= n; i++)
        cin >> v[i];
    for (int i = 1; i < n; i++) {
        int u , v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    auto bfs = [&](int s) {
        vector<int> dis(n + 1 , inf);
        dis[s] = 1;
        queue<int> que;
        que.push(s);
        while (not que.empty()) {
            int u = que.front();
            que.pop();
            for (auto v : adj[u]) {
                if (dis[v] > dis[u] + 1) {
                    dis[v] = dis[u] + 1;
                    que.push(v);
                }
            }
        }
        d[s] = dis;
    };
    for (int i = 1; i <= n; i++) {
        bfs(i);
        // for (int j = 1; j <= n; j++) {
        //     cout << d[i][j] << " \n"[j == n];
        // }
    }
    ll sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += v[n];
    }
    auto get = [&](int i , int j) {
        return (i - 1) * n + j;
    };

    int s = n * n + n + 1 , t = n * n + n + 2;
    g.init(s , t , t);

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            g.addedge(s , get(i , j) , v[j] - v[j - 1]);
            g.addedge(get(i , d[i][j]) , n * n +  j , inf);
        }
        for (int j = n; j > 1; j--) {
            g.addedge(get(i , j) , get(i , j - 1) , inf);
        }
    }
    for (int i = 1; i <= n; i++) {
        g.addedge(n * n + i , t , w[i]);
    }

    // cerr << "aaa\n";
    auto f = g.dinic();
    cout << sum - f << "\n";
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





