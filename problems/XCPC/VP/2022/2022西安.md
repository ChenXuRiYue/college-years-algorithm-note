# 2022ICPC 西安
[Dashboard - The 2022 ICPC Asia Xian Regional Contest - Codeforces](https://codeforces.com/gym/104077)
铜尾： 差点铁首。

参考题解： [The 2022 ICPC Asia Xian Regional Contest / ICPC 西安 2022 题解(ABDHJKL) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/588162564)

## L. Tree

You are given a tree $T$ with $n$ nodes. The tree is rooted at $1$. Define $\mathrm{subtree}(u)$ as the set of nodes in the subtree of $u$.

Call a subset of nodes $S$ good if and only if $S$ satisfies at least one of the following contidions:

-   For all $u, v\in S$ where $u\neq v$, either $u\in \mathrm{subtree}(v)$ or $v\in \mathrm{subtree}(u)$.
-   For all $u, v\in S$ where $u\neq v$, both $u\notin \mathrm{subtree}(v)$ and $v\notin \mathrm{subtree}(u)$.

You need to partition all nodes of $T$ into several good subsets. Calculate the minimum number of subsets.

### solve



### code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>g[1000000 + 50];
int fa[1000000 + 50], dep[1000000 + 50];
int ans = 0;
vector<int>vec;
void dfs(int u, int f, vector<int>&p, int d) {
    ++p[d];
    fa[u] = f;
    dep[u] = d;
    ans = max(ans, d);
    for (auto v : g[u])dfs(v, u, p, d + 1);
    if (g[u].empty())vec.push_back(u);
}
void solve() {
    int n;
    cin >> n;
    vec.clear();
    ans = 0;
    for (int i = 1; i <= n; ++i)g[i].clear();
    for (int i = 2; i <= n; ++i) {
        int f;
        cin >> f;
        g[f].push_back(i);
    }
    vector<int>d(n + 2, 0);
    dfs(1, 0, d, 1);
    vector<int>vis(n + 2, 0);
    vis[0] = 1;
    vector<pair<int, int>>pii;
    sort(vec.begin(), vec.end(), [&](int x, int y) {
        return dep[x] > dep[y];
    });
    for (auto x : vec) {
        int t = x;
        vis[t] = 1;
        while (!vis[fa[t]]) {t = fa[t]; vis[t] = 1;}
        pii.push_back({dep[t], dep[x]});
    }
    map<int, int>cnt;
    for (auto ii : pii)cnt[ii.second - ii.first + 1]++;
    int tot = pii.size();

    ans = min(ans, tot);
    int sum = 0;
    for (auto j : cnt) {
        int len = j.first, res = j.second;
        // //tot=min(tot,tot-res+len-sum);
        // if (tot - res + len - sum < tot) {
        //  tot = tot - res + len - sum;
        //  sum = len;
        // }
        sum += res;
        ans = min(ans , tot - sum + len);
        // ans = min(ans, tot);
    }
    cout << ans << "\n";
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int t;
    cin >> t;
    while (t--)solve();
}
```

------

## E. Find Maximum

We define a function $f(x)$ over all non-negative integer $x$ as follows:

$$
f(x) = \begin{cases} 1 & (x = 0) \\ f(\frac{x}{3}) + 1 & (x &gt; 0\land x\bmod3 = 0) \\ f(x - 1) + 1 & (x &gt; 0\land x\bmod 3\neq 0) \end{cases}
$$
 Calculate $\max_{x = l} ^ r f(x)$.

You need to answer $T$ queries independently.

### solve



### code

```cpp
#include<bits/stdc++.h>
using namespace std;


#define int long long

const int inf = 1 << 29;
const int N = 1E6 + 10;

int p[1000];
int sum;

void work(int testno) {
	int l , r;
	cin >> l >> r;
	/*定义最高位置：*/
	int cunt1 = 0;
	int rr = r;
	while (rr > 0) {
		cunt1++;
		rr /= 3;
	}
	int ll = l;

	vector<int> d(sum + 1 , 0);
	int cunt2 = 0;
	while (ll > 0) {
		d[cunt2] = (ll % 3);
		// cout << d[cunt2] << " ";
		cunt2++;
		ll /= 3;
	}
	// cout << "\n";
	cunt2 --; cunt1--;
	int ans = 0;
	for (int i = cunt2 + 1; i <= cunt1; i++) {
		for (int k = 1; k <= 2; k++) {
			ll = p[i] * k;
			for (int j = 0; j < i; j++) {
				if (ll + p[j] * 2 <= r) {
					ll += p[j] * 2;
				} else if (ll + p[j] <= r) {
					ll += p[j];
				}
			}
			if (ll > r || ll < l) continue;

			int temp = 0;
			while (ll > 0) {
				temp += ll % 3 + 1;
				ll /= 3;
			}
			ans = max(temp , ans);
		}
	}

	ll = l;
	for (int i = 0; i < sum; i++)
	{
		//cout<<l<<' ';
		// cout << d[i] << "\n";
		if (d[i] == 0)
		{
			if (ll + p[i] * 2 <= r) ll += p[i] * 2;
			else if (ll + p[i] <= r)
			{
				ll += p[i];
			}
		}
		else if (d[i] == 1)
		{
			if (ll + p[i] <= r)
				ll += p[i];
		}
		//cout<<l<<'\n';
	}
	// cout << ll << "\n";
	long long temp = 0;
	while (ll > 0) {
		temp += ll % 3 + 1;
		ll /= 3;
	}
	ans = max(temp , ans);

	cout << ans << "\n";
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	p[0] = 1;
	for (int i = 1; i < N; i++) {
		p[i] = p[i - 1] * 3;
		if (p[i] <= 1E18) sum++;
		else break;
	}
	int t; cin >> t;
	for (int i = 1; i <= t; i++)
		work(i);
	return 0;
}
```

## D. Contests

There are $n$ contestants and they take part in $m$ contests. You are given the ranklist of each contest. The ranklist of the $k$\-th contest is a sequence $a_k$, indicating that the $a_{k, i}$\-th contestant's rank is $i$.

SolarPea and PolarSea are two of the $n$ contestants. SolarPea wants to prove that he is stronger than PolarSea.

Define $x$ is $l$\-stronger than $y$, if and only if there exists a sequence $b$ of length $l + 1$, such that $b_1 = x$, $b_{l + 1} = y$, and for all $1\leq i\leq k$, $b_i$ has a smaller rank than $b_{i + 1}$ in at least one contest.

There are $q$ queries. In the $i$\-th query, SolarPea is contestant $x$ and PolarSea is contestant $y$. Please find the minimum positive number $l$ such that SolarPea is $l$\-stronger than PolarSea.

### solve

用图论的角度上。序列中不断地增加新地元素 ， 可以看作选择了某个排列上偏序关系地过程。显然如果下一次使用某个排列上地关系。对于前面地策略，必然式相同步数下最后到达地元素在该排列上，位置下标越小越好。

$f_{i , j , k}$ 表示，从i开始， 花费j步数，能到达k序列的最小位置。 但是显然，这样状态会非常多。并且每一次处理查询，都要枚举步数进行检查。 总体的复杂度高达$O(N^2)$ 显然是会挂掉的。

**集中精力解决减小规模的问题：**

发现一些现象：

考虑倍增 ， $f_{i , j , k}$ 表示 从i出发， 最多花费$2^k$ 的步数。到达j排列上的最短位置。

**状态转移：**
$$
f_{i ,j , k} = min(f_{i , j , k - 1} , f_{u_l , j , k - 1})\\
u_l = a_{l ,f_{i , l , k - 1}}
$$
**初始化：**

和一般的倍增一致，初始化k = 0的数组即可。

**怎么通过上述的倍增数组得到询问的解？**

维护一个$p_i$ ， 表示更新过程中，各个排列可以到达的最早位置。

在上述$p_i$ 的基础上走$2^k$ 步数。得到一个被更新的$g_i$

1. 如果$g_i$ 状态下，已经可以到达y:(即存在$p_i \le pos_{i ,y}$)

   则不更新答案。

2. 否则 ， 更新ans , 以及$p_i$



### code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = (int)1E5 + 10;
const int M = 7;
const int LOG = 18;

int a[M][N] , pos[M][N];
int f[N][M][LOG];

void cmin(int& x , int y) {
	if (x > y) x = y;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
			/*记录第i个序列中a[i][j]的位置：*/
			pos[i][a[i][j]] = j;
		}
	}
	for (int k = 0; k < LOG; k++)
		for (int i = 1; i <= n + 1; i++)
			for (int j = 1; j <= m; j++)
				f[i][j][k] = n + 1;
	// 跳到k的最前位置：
	for (int k = 1; k <= m; k++) {
		// 从第i个序列进行枚举：
		for (int j = 1; j <= m; j++) {
			int mi = n + 1;
			for (int i = n; i > 0; i--) {
				cmin(mi , pos[k][a[j][i]]);
				cmin(f[a[j][i]][k][0] , mi);
			}
		}
	}
	for (int k = 1; k < LOG; k++)
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++) {
				f[i][j][k] = f[i][j][k - 1];
				for (int l = 1; l <= m; l++) {
					cmin(f[i][j][k] , f[a[l][f[i][l][k - 1]]][j][k - 1]);
				}
			}

	int q; cin >> q;
	while (q--) {
		int x , y; cin >> x >> y;
		/*首先做一些基础的特判：*/
		int ans = 0 , p[M];
		bool have_ans = false;
		/*然后怎么倍增得到最小值？*/
		for (int i = 1; i <= m; i++) {
			p[i] = pos[i][x];
			if (pos[i][x] <= pos[i][y]) {
				ans = -1;
				have_ans = true;
				goto print;
			}
		}
		for (int k = LOG - 1; k >= 0; k--) {
			int g[M] , flag = 0;
			/*更新g[j]*/
			for (int j = 1; j <= m; j++) {
				g[j] = p[j];
				for (int l = 1; l <= m; l++)
					cmin(g[j] , f[a[l][p[l]]][j][k]);
				if (g[j] <= pos[j][y]) {
					have_ans = true;
					flag = true;
					break;
				}
			}
			if (flag == false) {
				ans += 1 << k;
				memcpy(p , g , sizeof(p));
			}
		}
		//
print:
		if (have_ans) cout << ans + 2 << "\n";
		else cout << -1 << "\n";
	}
}
```
