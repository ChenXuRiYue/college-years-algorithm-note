[A Spy in the Metro - UVA 1025 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-1025)

**城市里的间谍：**
紫书页号： p268

#### 20mins

解决dp之前 ， 是否会使用暴力？

1. 怎么写一个暴力？

关注所有方案， 阶段中的一些标志性的量：

1. 时间发生的时间。
2. 当前在什么站点。

#### solve

这种面向一些现实中的模型的问题中  ， 时间是是天然有序的。感受这种天然有序的模型性质的其它问题，例如： [免费馅饼.md](..\..\..\kuangbing\基础dp\免费馅饼.md) 

分阶段的关注角度：时间。

**状态定义**

$dp_{i , j}$ ，表示 ， 当前处于i时刻， 间谍处于j站点的最小等待时间。

**转移方程：**

1. 等待一分钟。
2. 搭乘正向火车。
3. 搭乘反向火车。

**初始化**

1. 不存在解为无穷大。
2. 最小状态： $dp_{t, n} = 0$

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int Nmax = 100;
const int Tmax = 1000;
const int inf = 1e9 + 7;

int dt[Nmax] , tx[Nmax] , ty[Nmax];
int n , T , m1 , m2;
bool has_train[Tmax][Nmax][2];
int dp[Tmax][Nmax];
int sum[Nmax];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int _ = 1;
    while (cin >> n && n) {
        int T;
        cin >> T;
        for (int i = 1; i < n; i++) {
            cin >> dt[i];
            sum[i + 1] = sum[i] + dt[i];
        }
        for (int i = T; i >= 0; i--)
            for (int j = 1; j <= n; j++) {
                has_train[i][j][0] = has_train[i][j][1] = false;
            }
        cin >> m1;
        for (int i = 1; i <= m1; i++) {
            int t;

            cin >> t;
            for (int j = 1; j <= n; j++) {
                // cout << sum[j] + t << " \n"[j == n];
                if (sum[j] + t > T) continue;
                has_train[sum[j] + t][j][0] = true;
            }
        }
        cin >> m2;
        for (int i = 1; i <= m2; i++) {
            int t;
            cin >> t;
            for (int j = n; j >= 1; j--) {
                // cout << sum[n] - sum[j] + t << " \n"[j == 1];
                if (sum[n] - sum[j]  + t > T) continue;
                has_train[sum[n] - sum[j] + t][j][1] = true;
            }
        }
        for (int i = 1; i < n; i++)
            dp[T][i] = inf;
        dp[T][n] = 0;
        for (int i = T - 1; i >= 0; i--)
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i + 1][j] + 1;
                if (j < n && has_train[i][j][0] && i + dt[j] <= T) {
                    dp[i][j] = min(dp[i][j] , dp[i + dt[j]][j + 1]); //右
                }
                if (j > 1 && has_train[i][j][1] && i + dt[j - 1] <= T)
                    dp[i][j] = min(dp[i][j] , dp[i + dt[j - 1]][j - 1]); //左
            }
        cout << "Case Number " << _++ << ": ";
        if (dp[0][1] >= inf) cout << "impossible\n";
        else cout << dp[0][1] << "\n";
    }
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```









