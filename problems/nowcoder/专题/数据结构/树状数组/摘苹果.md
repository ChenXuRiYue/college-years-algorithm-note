**摘苹果**

[H-摘苹果_2023年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛（同步赛) (nowcoder.com)](https://ac.nowcoder.com/acm/contest/52244/H)

#### solve

注意到这种操作最多可以进行20次。维护未到尽头的点进行的单点修改即可。



赛时变量写错：惨痛经验。如果确定自己思路是对的。但是一直没有调出来。有可能是低级错误。

1. 变量名写错。

解决方法可以是： 

1. 重新写一遍。
2. 再次审查代码中变量名称的意义。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E5 + 10;
set<int> rec;
int n , m;
ll a[N];
class BIT {
	ll c[N];

public:
	ll query(int x) {
		ll res = 0;
		for (; x ; x -= x & (-x))
			res += c[x];
		return res;
	}
	void modify(int x, ll d) {
		for (; x <= n; x += x & (-x)) {
			c[x] += d;
		}
	}
};

BIT d1, d2;

//树状数组求区间和公式：
//cout << (x + 1)*d1.query(x) - d2.query(x) - (x)*d1.query(x - 1) + d2.query(x - 1) << '\n';
//区间修改仔细点，前加后减。小心记错结论。
//求和问题非常容易溢出。

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (a[i] >= 10) {
			rec.insert(i);
		}
		d1.modify(i , a[i]);
		if (a[i] < 100) {
			d2.modify(i , 1);
		}
	}
	for (int i = 1; i <= m; i++) {
		int op , l , r; cin >> op >> l >> r;
		if (op == 1) {
			auto ptr = rec.lower_bound(l);
			while (ptr != rec.end() && *ptr <= r) {
				ll t = a[*ptr];
				int no = *ptr;
				a[no] -= a[no] / 3 + (a[no] % 3 != 0);
				d1.modify(no , a[no] - t);
				if (a[no] < 100 && t >= 100) {
					d2.modify(no , 1);
				}
				ptr++;
				if (a[no] < 10) {
					rec.erase(no);
				}
			}
		} else if (op == 2) {
			cout << d2.query(r) - d2.query(l - 1) << '\n';

		} else if (op == 3) {
			cout << d1.query(r) - d1.query(l - 1) << '\n';
		}
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



