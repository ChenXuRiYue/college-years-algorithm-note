**牛牛的回文串**

[牛牛的回文串 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21337)

给定各种操作的代价。包括增，删 ， 改。
求将该字符串变成回文串的最小代价。

#### 10mins

这种解空间探究 ， 无从下手：
1. 小规模问题是什么？体会不了。
2. 解空间中。各种操作应用都非常灵活，看上去毫无联系。

#### solve

1. 第一个问题 ， 对于任何一个操作。就结果而言（比方说，换 ，删）并不只有一个方案。可以先改成某一些值再删除 ， 所以得先把这些最优操作的代价求出来。（解结构的优化之一）。
   1. 这一个操作可以通过floyed求取。
   2. 处理掉一个字符
      1. 直接的删掉。
      2. 先转换再删掉。
      3. 先在对称的位置增加一个字符，两个匹配掉（对其他字符不产生影响）。
      4. 在对称位置增加一个字符，两个字符同时成k字符。
   3. 字符转换：
      1. 转换中间字符最小代价。

2. 关于状态设计：
    $dp_{i , j}$表示将 i....j的子段变成回文串的最小花费。
3. 状态转移
   对于计算$dp_{i , j}$ ， 发现有几种策略。考虑各种方案。
   1. $s_i和s_j$进行匹配。
      1. 统一换成同一个字母。
   2. $删掉s_i$
   3. $删掉s_j$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1E6 + 10;
const int oo = 1E9;
//#define int ll
string s;
//表示转换
ll cost[26][26], add[26], erase[26];
ll deal[26];
//表示删除。或者增加成一个删掉。
ll dp[100][100];
void floyed() {
	for (int k = 0; k < 26; k++)
		for (int i = 0; i < 26; i++)
			for (int j = 0; j < 26; j++) {
				cost[i][j] = min(cost[i][k] + cost[k][j], cost[i][j]);
			}
	//计算删除的最小信息。
	//删除的最小代价怎么统计？
	for (int i = 0; i < 26; i++) {
		deal[i] = erase[i];
		for (int j = 0; j < 26; j++) {
			//不借助中间字符。直接删增，匹配掉。
			//改删
			deal[i] = min(deal[i], cost[i][j] + erase[j]);
			// 改改。
			//增改改。
			for (int k = 0; k < 26; k++)
				deal[i] = min(deal[i], add[j] + cost[i][k] + cost[j][k]);
		}
	}
}
void init() {
	for (int i = 0; i < 26; i++) {
		for (int j = 0; j < 26; j++) {
			cost[i][j] = oo;
		}
		cost[i][i] = 0; add[i] = erase[i] = deal[i] = oo;
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	init();
	int n; cin >> s >> n;
	for (int i = 1; i <= n; i++) {
		string ch; cin >> ch;
		char a, b; ll c;
		if (ch == "change") {
			cin >> a >> b >> c;
			cost[a - 'a'][b - 'a'] = min(cost[a - 'a'][b - 'a'], c);
		}
		else if (ch == "add") {
			cin >> a >> c;
			add[a - 'a'] = min(c, add[a - 'a']);
		}
		else {
			cin >> a >> c;
			erase[a - 'a'] = min(erase[a - 'a'], c);
		}
	}
	floyed();
	int sz = s.size();
	for (int i = sz - 1; i >= 0; i--) {
		for (int j = i + 1; j < sz; j++) {
			dp[i][j] = oo;
			if (s[i] == s[j])dp[i][j] = dp[i + 1][j - 1];
			dp[i][j] = min(dp[i][j], deal[s[i] - 'a'] + dp[i + 1][j]);
			dp[i][j] = min(dp[i][j], deal[s[j] - 'a'] + dp[i][j - 1]);
			for (int k = 0; k < 26; k++)
				dp[i][j] = min(dp[i][j], dp[i + 1][j - 1] + cost[s[i] - 'a'][k] + cost[s[j] - 'a'][k]);
		}
	}
	if (dp[0][sz - 1] == oo)
		cout << -1 << '\n';
	else cout << dp[0][sz - 1] << '\n';
	//return 0LL;
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

