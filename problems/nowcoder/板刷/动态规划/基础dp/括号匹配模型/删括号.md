**删括号**

[删括号 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21303)

#### solve

关注一些解结构：
1. 发现最终删除的括号必然是连续排的。

定义状态： $d_{i , j , k}$表示对于$s_{0..i}$删去k个删去若干个括号，此时左括号数目减去右括号数目为k情况下$s_{0....i}和t_{0....j}$是否匹配。

2. 考虑各种迁移情况：
   1. 假设当前$dp_{i , j , k}$为false。无论怎么对当前位怎么操作最后都是false.
   2. 如果当前$dp_{i , j ,k}$为true，且k为0.当前遇到了$')'$显然错误因为追求的是连续的删除。
   3. 如果当前$dp_{i, j , k}$为true ，遇到$'('$ ， 那么连续删除的括号加1.
   4. 如果当前$dp_{i , j , k}$为true ,  遇到$')'$，那么连续的$'('$被抵消掉一个。
3. 体会到迁移总是正确的。（复习的话体会不到就继续体会。qaq）

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 100 + 10;
bool dp[N][N][N];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s , t;
    cin >> s >> t;
    s += ' ';
    t += ' ';
    s = ' ' + s;
    t = ' ' + t;
    int n = s.length()  -  1, m = t.length() - 1;
    dp[0][0][0] = true;
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i ; j++)
            for (int k = 0; k < n / 2; k ++) {
                if (dp[i][j][k]) {
                    if (k == 0 && s[i + 1] == t[j + 1])
                        dp[i + 1][j + 1][k] = true;
                    if (s[i + 1] == '(')
                        dp[i + 1][j][k + 1] = true;
                    else if (k)
                        dp[i + 1][j][k - 1] = true;

                }
            }
    string ans[2] = {"Impossible\n" , "Possible\n"};
    cout << ans[dp[n][m][0]];
}
```

