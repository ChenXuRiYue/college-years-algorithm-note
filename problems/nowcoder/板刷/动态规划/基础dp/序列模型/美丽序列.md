**美丽序列**
https://ac.nowcoder.com/acm/problem/21313
#### solve
这种问题的解空间非常清晰明了。
关注几种属性进行分类
1. i ，表示考虑了前i个元素。
2. j ，表示结构的尾数位j
3. k ,   表示连续下降的位数是k.
4. sum  结构的和位sum.

通过枚举上述情况 ， 就可以一条不漏的得到了所有的可能。并且完成迁移。这种模型的解是非常容易统计的。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 60;
const int mod = 1E9 + 7;

int a[N];
ll dp[N][N][3][1700];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;  cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	dp[0][0][0][0] = 1;
	//
	for (int t = 1; t <= n; t++) {
		//枚举当前位置上放的东西
		for (int now = 0; now <= 40; now ++)
			//枚举尾数
			for (int i = 0; i <= 40; i++)
				//枚举连续长度
				for (int j = 0; j < 3; j++)
					//枚举前面的平均数
					for (int k = 0; k <= 1600; k ++) {
						if (a[t] != -1 && now != a[t])continue;
						if ((now < i && j == 2) || (now * (t - 1) > k))continue;
						if (now < i)
							dp[t][now][j + 1][k + now] = (dp[t][now][j + 1][k + now] + dp[t - 1][i][j][k]) % mod;
						else dp[t][now][1][k + now] = (dp[t - 1][i][j][k] + dp[t][now][1][k + now]) % mod;
					}

	}
	ll ans = 0;
	for (int i = 0; i <= 40; i ++)
		for (int j = 0; j < 3; j ++)
			for (int k = 0; k <= 1600; k++)
			{	ans += dp[n][i][j][k];
				ans %= mod;
			}
	cout << ans << '\n';
}
```

