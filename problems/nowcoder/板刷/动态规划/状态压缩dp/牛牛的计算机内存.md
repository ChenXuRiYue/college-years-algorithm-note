**牛牛的计算机内存**

[牛牛的计算机内存 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21873)

#### 简介

找出一种指令顺序，使得访存代价花费的时间最小：时间代价的计算方式是
新的访问代价为：

#### solve

状压dp.
将选择状态压缩为s ， 第i - 1位置上为1，意味着这个任务已经选了.
定义$dp_{s}$：当选择情况为s。前面的最小代价。（选择的先后，不影响最终内存的使用情况。）
状态转移方程：
1. $dp_{s}$枚举，上一个s的状态是什么。然后迁移即可。

完成的一些任务：
1. 字符串到二进制之间的转换。
2. 统计某些任务使用之后的，内存的剩余使用情况。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
#define end en

const int N = 1E6 + 10;
int bit[100];
int end[1 << 20];
ll dp[1 << 20];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		string s; cin >> s;
		int now = 0;
		for (int j = 0; j < m; j++) {
			if (s[j] == '0')continue;
			else now |= (1 << j);
		}
		bit[i] = now;
	}
	auto f = [&](int x, int y) -> int{
		//表示x。当前是选择哪一个任务？
		//y表示前面的额基础情况。
		//这个函数的目的就是计算出有多少的位置是不一样的。
		int k = 0;
		for (int i = 0; i < m; i++) {
			if (((bit[x] >> i) & 1) && (end[y] >> i & 1) == 0)
				k++;
		}
		return k;
	};
	memset(dp , 0x3f , sizeof dp);
	dp[0] = 0;
	for (int s = 1; s < (1 << n); s++) {
		for (int j = 0; j < n; j++) {
			//说明当前有
			if (s & (1 << j)) {
				int k = f(j, s ^ (1 << j));
				dp[s] = min(dp[s] , dp[s ^ (1 << j)] + k * k);
				end[s] = end[s ^ (1 << j)] | bit[j];
			}
		}
	}
	cout << dp[(1 << n) - 1] << '\n';

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

这是见过的一道最简单的dp了。