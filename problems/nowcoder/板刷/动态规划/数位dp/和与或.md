**和与或**

[和与或 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/21336)

#### solve

观察出一个性质 ：从二进制的角度看 ，  若干个数相加，二进制串的某一个位上不能够有进位。

不断地枚举最终和的数字前缀：
对于任意二进制串前缀：

1. 当前位置为1时 ， 那么要有一个A提供1。其它的数在该位上提供0。

2. 按照这样的枚举方法。由乘法计数原理，所有情况都考虑齐全。
    观察枚举过程中 ， 一些可以重复利的信息。在枚举的过程中，对于$a_i$有两种属性——是否被限制（前缀是否贴着上界前缀走。）这决定了 ， 当前情形下 ， 这些数字是当前位置上可以取的数字。
  那么这时可以感受到， 后面的选择和当前的0 ， 1相关。（形象地看，就是后续发展的子树相同。可以记录这一类子树的叶子数）

3. 状态设计
   $dp_{i , j }$ 表示当前在枚举第i位情况下 ，j 表示限制情况（状态压缩的方法，如果i位上为0表示 第i个数字的枚举被限制。为1反之）

4. 始化化：
   初始化为-1。从dfs(62 , 0)$开始搜索。

5. 状态转移
   如果sum当前的位置上选择0  ， 其余所有项选0。此时那些原本被限制的 ， 并且当前位上为1的下沉。 
   如果sum当前位置上选择1 。有下面两种情况：
   1. 非限制数字选择1.
      1. 此时原本被限制的且上界的当前位上为1的 数字不再被限制。
   2. 限制位数字且上界该位置上本来就有1。
      1. 同上 。

#### 生长思考

1. ~~那么神奇，怎么思考？~~
2. 体会到了数位dp中贴上界问题在数位dp中存在的现象。多个数枚举制约下的限制 ， 以及上界数的下沉。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int mod = 1E9 + 9;

ll a[N] , dp[100][1050];
int n;

ll dfs(int pos , int limit) {
	if (pos == -1)return 1;
	if (dp[pos][limit] != -1) return dp[pos][limit];

	ll& res = dp[pos][limit];
	res = 0;
	//记录拿一些a在当前的pos上为1
	int rec = 0;
	for (int i = 0; i < n; i++)
		if (a[i] & (1LL << pos)) {
			rec |= 1LL << i;
		}
	res += dfs(pos - 1 , limit | rec);
	//考虑的当前pos上取1的情况。
	//枚举哪一一个1在这个位置上可以做出贡献
	for (int i = 0; i < n; i ++)
		if (limit & (1LL << i))
			res = (res + dfs(pos - 1 , limit | rec)) % mod;
		else if (rec & (1LL << i))
			res = (res + dfs(pos - 1 , (limit | rec) ^ (1LL << i))) % mod;
	return res;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	memset(dp , -1 , sizeof dp);
	cout << dfs(61 , 0) << '\n';
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```