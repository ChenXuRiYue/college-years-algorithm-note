### **叠硬币**

[H-叠硬币_2022年中国高校计算机大赛-团队程序设计天梯赛（GPLT）上海理工大学校内选拔赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/30532/H)



#### solve

**定义dp状态：**

$f_{i,j}$表示考虑前i个情况下，当前硬币堆高度之和为j的最小的硬币堆数。

**状态转移方程：**

$f_{i,j}=min(f_{i-1,j},f_{i-1,j-w}+1)$注意判j - w的大小。

--------

**但是上面没有解决所有问题：**

对于找出转移路径：
定义$pre_{i,j}$表示$f_{i,j}$的解结构的尾部选择。

1. 转移更新时，保持记录即可。

关于还原：

1. 如果已经得到尾部的物品，可以计算上一个子问题状态$f_{i-1,h-a[pre[i][j]]}$

~~**但是还没有解决问题：**~~

还要求求出字典序最小的方案：
经典问题：倒过来考虑即可。进一步证明，在背包问题中的其它问法的笔记中写过：

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3E3 + 10;
const int inf = 1 << 29;
int f[N][N] , pre[N][N];
int a[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , H; cin >> n >> H;
	for (int i = 0; i <= n + 1; i++) {
		for (int j = 0; j <= H; j++) {
			f[i][j] = inf;
		}
	}
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	sort(a + 1 , a + 1 + n);
	f[n + 1][0] = 0;
	for (int i = n; i >= 1; i--) {
		int x = a[i];
		for (int j = 0; j <= H; j++) {
			f[i][j] = f[i + 1][j];
			pre[i][j] = pre[i + 1][j];
		}
		//动态规划中的复原的基本功没有做好：
		for (int j = H; j >= x; j-- ) {
			if (f[i + 1][j - x] + 1 <= f[i][j]) {
				f[i][j] = f[i + 1][j - x] + 1;
				pre[i][j] = i;
			}
		}
	}
	if (f[1][H] == inf) {cout << -1 << '\n';}
	else {
		cout << f[1][H] << '\n';
		queue<int> que;
		int id = pre[1][H];
		int h = H;
		while (id) {
			que.push(id);
			h -= a[id];
			id = pre[id + 1][h];
		}
		while (que.empty() == false) {
			cout << a[que.front()] << ' ';
			que.pop();
		}
		cout << '\n';
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
