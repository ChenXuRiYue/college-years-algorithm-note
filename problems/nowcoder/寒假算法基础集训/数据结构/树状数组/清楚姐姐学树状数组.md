[F-清楚姐姐学树状数组_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/F)

其实就是基于树状数组的原理；

利用二进制，管理统计数组。

研究点之间的关系，引入两个规则，建立一颗二叉树树：

1. 编号为i的节点的深度为$log2(lowbit(N))−log2(lowbit(i))$。
2. 二叉树中序遍历序为1....n

$N=2^k$

  ![img](https://uploadfiles.nowcoder.com/images/20221221/0_1671618561830/0F52D0FA42C2B3068A16F3DBCF149985)



#### solve

关于树的性质挖掘：提出问题，挖掘性质。

1. 儿子与父亲父亲之间的关系是什么？

由规则1 ， 2 .

儿子具有$log(lowbit(fa))$的10000..长度的后缀。

满足上述后缀的集合中。儿子离父亲最近。

中序定义了左右儿子大小关系。

综上：
$$
leftChirld(fa) = fa - 1<<(log2(lowbit(fa))-1)\\
=fa-lowbit(fa)>>1\\
=fa^{\wedge }lowbit(fa)^{\wedge}(lowbit(fa)>>1)
$$

$$
rightChirld(fa)=fa+1<<(log2(lowbit(fa))-1)\\
=fa+lowbit>>1\\
=fa^{\wedge}(lowbit(fa)>>1)
$$


2. 节点过多怎么处理：
   1. 如果更具规律直接统计左子树。$sum(leftChirld)=2\times lowbit(leftChirld)-1$

这样单次查询：就可以控制复杂度在$log(N)$

#### 生长思考：

1. 之前有没有遇到过相似的问题？

   比较新颖。二叉树遍历序问题。

2. 这种问题解决思路是什么？
   1. 挖掘模型性质。如果挖掘到这种二叉树模型的性质，后面就比较好做了。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

ll  n, q;

ll lowbit(ll x)
{
	return x & -x;
}

ll leftChirld(ll x)
{
	return x - (lowbit(x) >> 1);
}

ll rightChirld(ll x)
{
	return x + (lowbit(x) >> 1);
}

ll size(ll x)
{
	return (lowbit(x) << 1) - 1;
}

ll DLR(ll x)
{
	ll res = 1;
	ll now = 1LL << n;
	while (now != x)
	{
		res++;
		//cout << now << '\n';
		ll l = leftChirld(now);
		ll r = rightChirld(now);
		if (x < now) now = l;
		else
		{
			now = r;
			res += size(l);
		}
	}
	return res;
}

ll LRD(ll x)
{
	ll res = 0;
	ll now = 1LL << n;
	if (x == now)return now;
	while (true)
	{
		ll l = leftChirld(now);
		ll r = rightChirld(now);

		if (now == x)
		{
			res += size(now);
			return res;
		}

		if (x < now) now = l;
		else
		{
			now = r;
			res += size(l);
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> q;

	while (q--)
	{
		ll now;
		cin >> now;
		cout << DLR(now) << ' ' << now << ' ' << LRD(now) << '\n';
	}


}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 实现bug

1. 他妈一个漏long long 直接wa.还是全部开ll吧。

