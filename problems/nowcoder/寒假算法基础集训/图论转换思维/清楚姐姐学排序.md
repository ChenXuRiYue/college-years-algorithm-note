[J-清楚姐姐学排序_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/J)

#### 题意

对于一个整数数组（两两之间不相等。）

给定m个两两元素之间的大小关系：

求出第i位对应第几个元素。

如果不能确定输出-1/

#### solve 

#### first

很容易就关注每一个元素的bigger总数，和smaller总数。

将他们转换成图论问题，bfs，dfs求出每一个元素的更小元素总数和更大元素总数。

#### code_first

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;

int n , m;
vector<vector<int>>g , temp;
int deg1[10000];//记录入度。来进行d确定dfs。起点。
int deg2[10000];
int bigger[N], smaller[N];

bool passed[N];


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);


	cin >> n >> m;
	g.resize(n + 1);
	temp.resize(n + 1);
	for (int i = 1; i <= m; i++)
	{
		int x , y;
		cin >> x >> y;
		g[y].push_back(x);
		temp[x].push_back(y);
	}

	//计算smaller
	function < int(int , vector<vector<int>>&) > dfs = [&](int now , vector<vector<int>>& s)->int{
		ll res = 0;
		if (passed[now])
			return 0;
		passed[now] = true;
		for (auto i : s[now])
			res += dfs(i , s);
		return res + 1;
	};

	for (int i = 1; i <= n; i++)
	{
		memset(passed , 0 , n * 2);
		smaller[i] = dfs(i , g) - 1;
	}


	//计算bigger

	for (int i = 1; i <= n; i++)
	{
		memset(passed, 0 , n * 2);
		bigger[i] = dfs(i , temp) - 1;
	}

	vector<int>ans(n , -1);
	for (int i = 1; i <= n; i++)
	{
		if (bigger[i] + smaller[i] == n - 1)
			ans[smaller[i]] = i;
	}
	for (int i = 0; i < n; i++)
	{
		cout << ans[i] << " \n"[i == n - 1];
	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```





#### 生长以及总结

- 刚开始。我将其当作了简单的树形dp问题。但是这个图是复杂的。一次简单搜索，不可以把所有的值计算。会出现重复出现等等问题。但是确实是有更低复杂度的做法的。
- 可以用bitset进行常数优化。卡常大神的必经之路。



