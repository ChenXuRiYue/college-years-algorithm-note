这里有两个版本，考察对背包dp的理解。

其中easy  verson，鬼混过去了。

### easy_verson

[C-清楚姐姐学01背包(Easy Version)_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/C)

#### 题意



在对一些物品求经典的01背包。

现在将一个物品拿掉。如果剩余物品的最大价值小于原来的最大价值，称其该物品为必选。

考察每一个物品：

如果必选输出0.

否则求出一个最小修正值（给当前考察的物品加上一个值。）使得成为必选。

#### solve1

01背包加二分。水过去。

调了非常多的bug。经典就是初始化出现问题。

n , m 分不清；fill用错。忘记初始化等等。

##### code1

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E6 + 10;
const int oo = 1E9 + 10;

ll f[200];
ll w[N];
ll v[N];
int n, m;
ll mx;

bool check(ll x, int now)
{
	v[now] += x;
	fill(f, f + 1 + m, 0);
	for (int i = 1; i <= n; i++)
	{
		for (int j = m; j >= w[i]; j--)
		{
			f[j] = max(f[j], f[j - w[i]] + v[i]);
		}
	}
	v[now] -= x;
	return f[m] > mx;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];
	for (int i = 1; i <= n; i++)
	{
		fill(f, f + 1 + m, 0);
		for (int j = 1; j <= n; j++)
		{
			if (i == j)continue;
			for (int k = m; k >= w[j]; k--)
			{
				f[k] = max(f[k], f[k - w[j]] + v[j]);
			}
		}
		mx = f[m];
		//cout << mx << '\n';
		ll low = 0, high = mx;
		while (low < high)
		{
			ll mid = (low + high) / 2;
			if (check(mid, i))high = mid;
			else low = mid + 1;
		}
		cout << high << '\n';
	}

}
//在原来的程序中一定要被选上。

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

----

#### solve2

必选就是选择了它的方案必然是最大的。

我们只需要关注选择了该物品的最大方案。与整体上的最优方案做一个比较做一个修正即可。

##### step

- 先做整体01背包的最优方案。
- 计算选择了其它的项（空间只给m-w[i]）的最优方案。
- 基于上两个信息，进行修正即可。

##### 复杂度

$O(N^2\times M)$

##### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1E2 + 10;

ll v[N] , w[N] , f[N];
ll mx;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n , m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];

	for (int i = 1; i <= n; i++)
		for (int j = m; j >= w[i]; j--)
			f[j] = max(f[j], f[j - w[i]] + v[i]);

	mx = f[m];
	// cout << mx << '\n';

	for (int i = 1; i <= n; i++) {
		fill(f, f + 1 + m, 0);
		for (int j = 1; j <= n; j++)
		{
			if (i == j)continue;
			for (int k = m; k >= w[j]; k--)
				f[k] = max(f[k] , f[k - w[j]] + v[j]);
		}
		ll now = f[m - w[i]] + v[i];
		// cout << "now: " << now << '\n';
		// cout << "f[m]" << f[m] << '\n';
		if (f[m] < mx)cout << 0 << '\n';
		else cout << mx - now + 1 << '\n';
	}

}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



### hard verson

[D-清楚姐姐学01背包(Hard Version)_2023牛客寒假算法基础集训营4 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/46812/D)

#### 简介
和上述一样，不过N，M高达$5\times 10^3$

#### solve
##### 指导思想：
1. 是否有非常多重复计算的量？
2. 是否有等待被挖掘的性质？

动态规划中的，局部的资源修改问题。
很大部分的子问题并不会被影响。

##### tips
不妨设现在不考虑物品i。

1. 假设正推$f_{id，k}$指标函数，表示k容量，选择前$id$个物品的最大价值。
   那么$f_{j},j<i$中的子问题不会受到影响。
2. 假设逆推$g_{id,k}$指标函数，表示k容量，选择后$id$个物品的最大价值。
   那么$g_{j},j>i$中的子问题不会受到影响。

利用这两个指标函数就可以用$O(m)$的花费，计算不选i的最大价值，以及选择了i的最大价值。



#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 5E3 + 10;

int n , m;
ll f[N][N] , g[N][N];
ll v[N] , w[N];

void work()
{
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= m; j++) {
			if (j < w[i]) f[i][j] = f[i - 1][j];
			else
				f[i][j] = max(f[i - 1][j] , f[i - 1][j - w[i]] + v[i]);
		}

	for (int i = n; i >= 1; i--)
		for (int j = 0; j <= m; j++)
			if (j < w[i])g[i][j] = g[i + 1][j];
			else g[i][j] = max(g[i + 1][j] , g[i + 1][j - w[i]] + v[i]);
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];
	work();

	for (int i = 1; i <= n; i++)
	{
		//计算不选它的最大值。
		ll no = 0;
		for (int j = 0; j <= m; j++)
			no = max(no , f[i - 1][j] + g[i + 1][m - j]);
		//计算选它的最大值。
		ll yes = 0;
		for (int j = 0; j <= m - w[i]; j++)
			yes = max(yes , f[i - 1][j] + g[i + 1][m - w[i] - j]);
		yes += v[i];

		if (no < yes) cout << 0 << '\n';
		else cout  << no - yes + 1 << '\n';

	}
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

#### 生长思考；

遇见逐步修改问题。考虑没有被影响的子问题。

正推 ， 逆推。利用它们来用小花费求出目标子问题的解。

dp优化。







