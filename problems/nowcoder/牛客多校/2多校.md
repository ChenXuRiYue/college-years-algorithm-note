## 场外话：

反思：

1. 就个人习惯：
   1. 打比赛的过程中，保持情绪稳定。这个比赛一直在大喊大叫，把自己和荣栩的心态都搞炸了。
   2. 保持幽默感，不施加压力。
2. 策略上：
   1. 每个人都不应该死在一道题上： 包括荣栩。
   2. 同时得捏四道题，要不拿牌，要不签到题不过都无所谓。
   3. 为什么不开D呢？ 有时候必须正视签到没有卡了的情况：
      1. 给其他人开， 不听思路直接接盘。
      2. 合理分配 ， 减少损失： 
      3. 控制罚时，保守交签到题。
3. 合理分析，自己给出的小问题的答案：
   1. 比如这次，样例都没有过，但是自己就是死固执的死磕。

## 补题：

### F

[2023_牛客暑期多校训练营_2_Solution_Markdown.pdf (nowcoder.com)](https://uploadfiles.nowcoder.com/files/20230721/999991351_1689931950887/2023_牛客暑期多校训练营_2_Solution_Markdown.pdf)

[F-Link with Chess Game_2023牛客暑期多校训练营2 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57356/F)

博弈：其底层知识非常难想，其中大多数人都是靠猜出来的。

1. 这种复杂的博弈清形，即使是枚举优解都非常困难。

可以考虑的角度：

1. 简化博弈模型：
   1. 如果是一维的怎么样？
   2. 推广到三维怎么样？

有些许荒唐，但是这一场的后果说明，这是比手玩更加接近正确答案的方式。

其原理： 二分图博弈：

1. 若起始状态必定位于该二分图的最大匹配上，则先手必胜。否则先手必败。

如果n是偶数，显然很容易构造出一个完全匹配。

如果n是奇数：

1. 分类讨论点的情况： 如果$a + b + c$ 为偶数，那么这个点必须要作为最大匹配中的一个点。因为n是奇数情形下， 可以找到剩余1个点的匹配。如果a + b + c为偶数，那么省去这个点无法得到最大匹配。
2. 否则 ， $a + b + c$ 为奇数时，即使不考虑该点，也可以构造出一个最大匹配出来（剩余一个点。）

### H

[H-0 and 1 in BIT_2023牛客暑期多校训练营2 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57356/H)

思路比较简单就是，仔细考察其每一种操作的贡献： 然后使用前后缀硬搞即可。

1. 取反操作 ： 相当于贡献了一个规定长度内的超码。
2. 加一操作： 普通的加一操作。

先处理前后缀，再根据段的基本情况去计算出几个信息：

1. 段常数种的贡献情况。
2. 最后x是正数或是负数？

#### 犯了个很智障的错误：

1. 强制在线中，涉及到了l 到 $l_{real}$的计算： 找找差别？

   ```cpp
   cin >> l >> r >> str;
   // l = min((ans[qq - 1] ^ l) % n + 1 , (ans[qq - 1] ^ r) % n + 1);
   // r = max((ans[qq - 1] ^ l) % n + 1 , (ans[qq - 1] ^ r) % n + 1);
   
   
   // cout <<  l << " " << r << "\n";
   l = (ans[qq - 1] ^ l) % n + 1;
   r = (ans[qq - 1] ^ r) % n + 1;
   if (l > r) swap(l , r);
   ```

   

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 2E5 + 10;
const int M = 55;

// int A0[M][N] , A1[M][N] , B0[M][N] , B1[M][N];
int sum[N];
ll f[M][N];
ll ans[N];

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , q;
	cin >> n >> q;
	string s;
	cin >> s;
	s = '#' + s;
	for (int i = n; i >= 1; i--) {
		sum[i] = sum[i + 1] + (s[i] == 'A');
	}
	for (int k = 1; k <= 50; k++) {
		const ll mod = 1LL << k;
		for (int i = n; i >= 1; i--) {
			if (s[i] == 'A') {
				if (sum[i + 1] % 2) {
					// - (mod - 1)
					f[k][i] = (f[k][i + 1] + 1) % mod;
				} else {
					// (+ mod - 1)
					f[k][i] = (f[k][i + 1] + (mod - 1)) % mod;
				}
			} else {
				if (sum[i + 1] % 2) {
					// -1
					f[k][i] = (f[k][i + 1] - 1 + mod) % mod;
				} else {
					// + 1
					f[k][i] = (f[k][i + 1] + 1) % mod;
				}
			}
		}
	}

	for (int qq = 1; qq <= q; qq++) {
		ll l , r;
		string str;
		cin >> l >> r >> str;
		// l = min((ans[qq - 1] ^ l) % n + 1 , (ans[qq - 1] ^ r) % n + 1);
		// r = max((ans[qq - 1] ^ l) % n + 1 , (ans[qq - 1] ^ r) % n + 1);
		// cout <<  l << " " << r << "\n";
		l = (ans[qq - 1] ^ l) % n + 1;
		r = (ans[qq - 1] ^ r) % n + 1;
		if (l > r) swap(l , r);

		ll x = 0;
		int kk = (int)str.size();
		const ll mod = 1LL << kk;
		// cout << str << "\n";
		for (int i = 0; i < (int)str.size(); i++) {
			x = (str[i] == '1') + x * 2;
		}
		// cout << x << "\n";
		ans[qq] = ((f[kk][l] - f[kk][r + 1]) % mod + mod) % mod;
		if (sum[r + 1] % 2) {
			ans[qq] = (-ans[qq] % mod + mod) % mod;
			// 取一个mod.
		}

		if ((sum[l] - sum[r + 1]) % 2) {
			ans[qq] = ((ans[qq] - x) % mod + mod) % mod;
		} else ans[qq] = (ans[qq] + x) % mod;

		vector<int> p;
		x = ans[qq];
		for (int j = 1; j <= kk; j++) {
			p.push_back(x % 2);
			x /= 2;
		}
		reverse(p.begin() , p.end());
		for (auto Bit : p) {
			cout << Bit;
		}
		cout << "\n";
	}
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```



### G

[G-Link with Centrally Symmetric Strings_2023牛客暑期多校训练营2 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57356/G)

Manacher:

1. 和回文串相似的处理方式，得到一个元素中心的半径：使用当前的成果。
2. 寻求一个最小的覆盖：
   1. 如果一个字符串具有合法划分，那么其中，如果$ABSB`A`$ 中  A内涵了一个对称串，就可以对其进行分割成 A + $BSB`+ A`$ 
   2. 于是问题转换成一种贪心思路，每次基于当前的覆盖情况，寻求下一个最小覆盖。



```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;
const ll INF = 1E18 + 7;
const int N = 5E6 + 10;

string one = "bqdpnuosxz#";
string two = "qbpdunosxz#";

bool checkself(char s) {
	return s == 'o' || s == 's' || s == 'x' || s == 'z' || s == '#';
}
bool check(char s , char t) {
	for (int i = 0; i < (int)one.size(); i++) {
		if (one[i] == s) return t == two[i];
	}
	return false;
}
void work(int testNo)
{
	string s1 , s;
	vector<int> d;
	cin >> s1;
	int n = (int)s1.size();
	s.resize(n * 2 + 1);
	for (int i = 0; i < n; i++) {
		s[i * 2] = '#';
		s[i * 2 + 1] = s1[i];
	}
	s[n * 2] = '#';
	n =  n * 2 + 1;
	d.resize(n);
	for (int i = 1 , l = -1 , r = -1 , k; i < n; i++) {
		if (checkself(s[i]) == false) {
			d[i] = 0;
			continue;
		}
		k = i > r ? 1 : min(d[l + r - i] , r - i);
		while (i - k >= 0 && i + k < n && check(s[i + k] , s[i - k]))k++;
		d[i] = --k;
		if (i + k > r)
			r = i + k , l = i - k;
	}
	// 然后在上面的基础上怎么进行一个匹配？
	int r = -1;
	for (int i = 0; i < n; i++) {
		if (checkself(s[i]) == false) {
			continue;
		}
		if (i - d[i] <= r  + 1) {
			r += 2 * (i - r - 1) + 1;
			i = r;
		}
	}

	// for (int i = 0; i < n; i++) {
	// 	cout << s[i] << " ";
	// }
	// cout << "\n";
	// for (int i = 0; i < n; i++) {
	// 	cout << d[i] << " ";
	// }
	// cout << "\n";
	// cout << n << " " << r << "\n";

	if (r != n - 1) {
		cout << "No\n";
	} else cout << "Yes\n";
}

signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

