# 多校5

段错误极多 ， 手速极其慢：

[牛客竞赛_ACM/NOI/CSP/CCPC/ICPC算法编程高难度练习赛_牛客竞赛OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57359)

### [I-The Yakumo Family_2023牛客暑期多校训练营5 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57359/I)![image-20230731205559880](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230731205559880.png)

[一类二进制拆位算贡献的题目： - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/647165385)

生长： [H-Problem H. xor_2021 CCPC 新疆省赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/22754/H)

###  solve

1. 第一个观察：

$\sum XOR(l_1 , r_1)\times XOR(l_2 , r_2) \times XOR(l_3 , r_3)$

显然可以变成，不相交的三部分和的乘积。

2. tips2:

   考虑维护一些信息：

   1. $f_1(i)$ 表示：维护前缀： 1...i区间中所有异或段的和；
   2. $f_3(i)$ 表示：维护后缀： i...n区间中所有异或段的和：

   **求出上述维护的关键** 现在考虑$f_1$ 的求法：

   1. 显然$f_{i-1}$ -> $f_i$
   
   2. 所有新增的信息是以i为结尾的一些段： 不断地维护上个区间地尾部，从而转移到当前求取区间地尾部：具体的维护方法如下：
   
      1. 显然是不能和加减法进行分配律的。
   
      2. 当之前维护的尾段，异或上当前这个段后会发生什么变化？
   
         每一个尾段值，发生对应的异或运算的变化。
   
      3. 那么怎么统计这些变化？
   
         发现每一个数都可以拆位成若干权的进制位的变化。同时，我们可以记录每个位权对应的尾段个数。
   
         1. 如果j位上，$a_i$ 位上为1。该位为0 -> 1 ， 1 -> 0
         2. 如果j位上，$a_i$ 位上为0。那么原来维护的尾段不会发生变化。
         3. 同时增加尾段集合$a_i$ 对信息的贡献。
      
      4. 统计具体值：
      
         每一个位独立贡献。且每一个位上为1的尾段又独立贡献直接计算即可：
   ```cpp
   ll pre[32][2] {};
   for (int i = 1; i <= n; i++) {
       f1[i] = f1[i - 1];
       for (int j = 0; j <= 29; j++) {
           if ((a[i] >> j & 1)) {
               swap(pre[j][0] , pre[j][1]);
           }
           pre[j][a[i] >> j & 1]++;
           // cout << pre[j][1] << " \n"[j == 29];
           add(f1[i] , pre[j][1] * (1LL << j) % mod);
       }
   }
   
   int suf[32][2] {};
   for (int i = n ; i >= 1; i--) {
       f3[i] = f3[i + 1];
       for (int j = 0; j <= 29; j++) {
           if ((a[i] >> j & 1)) {
               swap(suf[j][0] , suf[j][1]);
           }
           suf[j][a[i] >> j & 1]++;
           add(f3[i] , suf[j][1] * (1LL << j) % mod);
       }
   }
   ```
----
进一步得到答案：
维护信息：$f_2(i) : $ 表示第二个段以i为结尾的的前两个段的方案数。
在上述的过程中，依然可以得到一些启发：

**第一个集中精力解决的问题：假设知道$f_2(i-1)$ , 对$f_2(i)$? 对有什么帮助**

1. 发现是在$f_2(i - 1)$尾端拼接$a_i$。尾段区间异或上这个数之后，$f_2(i -1)$相关的贡献变化如下：

   $(A)\times (B)$  , 就是考虑B中的变化

   另外一类贡献是,$a_i$ 单独做一个区间， 此时转移与$f1(i - 1)$ 相关。

**第二个集中精力解决的问题：把握$f_2(i - 1)$接上$a_i$之后， 即（A）$\times$ (B)的变化。**  

其实只需要考虑B中的变化， 于是我们拆位，然后就可以简单清晰的把握住接上$a_i$ 之后你， B结构的变化。用$pre[i][1/0]$ 来做相关的维护。$a_i$ 做独立区间的贡献此时也要考虑进去。这影响了问题的计算。

```cpp
for (int i = 2; i < n; i++) {
    f2[i] = f2[i - 1] + f1[i - 1] * a[i];
    for (int j = 0; j < 30; j++) {
        if ((a[i] >> j & 1) == 0) {
            continue;
            pre[j][0] += f1[i - 1];
        } else {
            f2[i] += pre[j][0];
            f2[i] %= mod;
            f2[i] -= pre[j][1];
            f2[i] = (f2[i] % mod + mod) % mod;
            pre[j][1] += f1[i - 1];
        }
    }
    add(ans , 1LL * f2[i] * f3[i + 1] % mod);
}
```







```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 2E5 + 10;
const int mod = 998244353;

int a[N];

int f1[N];
int f2[N];
int f3[N];
ll pre[32][2];

void add(ll & a , int b) {
	a += b;
	if (a >= mod) a -= mod;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	f1[1] = a[1];
	int ppre = a[1];
	for (int i = 2; i <= n; i++) {
		ppre = (ppre ^ a[i]) + a[i];
		f1[i] = f1[i - 1] + ppre;
		f1[i] %= mod;
	}

	f3[n] = a[n];
	int suf = a[n];
	for (int i = n - 1; i > 0; i--) {
		suf = (suf ^ a[i]) + a[i];
		f3[i] = f3[i + 1] + suf;
		f3[i] %= mod;
	}
	ll ans = 0;

	for (int i = 2; i < n; i++) {
		f2[i] = f2[i - 1] + f1[i - 1] * a[i];
		for (int j = 0; j < 30; j++) {
			if ((a[i] >> j & 1) == 0) {
				continue;
				pre[j][0] += f1[i - 1];
			} else {
				f2[i] += pre[j][0];
				f2[i] %= mod;
				f2[i] -= pre[j][1];
				f2[i] = (f2[i] % mod + mod) % mod;
				pre[j][1] += f1[i - 1];
			}
		}
		add(ans , 1LL * f2[i] * f3[i + 1] % mod);
	}
	cout << ans << "\n";
}

/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```









