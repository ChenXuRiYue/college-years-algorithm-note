# F2. Korney Korneevich and XOR (hard version)

[Problem - F2 - Codeforces](https://codeforces.com/contest/1582/problem/F2)

**This is a harder version of the problem with bigger constraints.**

Korney Korneevich dag up an array $a$ of length $n$. Korney Korneevich has recently read about the operation [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR), so he wished to experiment with it. For this purpose, he decided to find all integers $x \ge 0$ such that there exists an **increasing** subsequence of the array $a$, in which the bitwise XOR of numbers is equal to $x$.

It didn't take a long time for Korney Korneevich to find all such $x$, and he wants to check his result. That's why he asked you to solve this problem!

A sequence $s$ is a subsequence of a sequence $b$ if $s$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements.

A sequence $s_1, s_2, \ldots , s_m$ is called increasing if $s_1 \lt s_2 \lt \ldots \lt s_m$.

**这是一个难度更大、限制条件更多的问题**。

科尼-科尔涅维奇（Korney Korneevich）在一个长度为 $n$的数组 $a$中添加了一个数组。科尼-科尔涅维奇最近读到了关于 [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) 操作的信息，因此他想做个实验。为此，他决定找出所有整数$x \ge 0$，使得数组$a$存在一个**递增的**子序列，其中数字的位XOR等于$x$。

科尼-科尔涅维奇不费吹灰之力就找到了所有这样的 $x$，他想检验一下自己的结果。这就是为什么他要求你解决这个问题！

如果通过删除几个（可能是零个或全部）元素可以从序列 $b$得到序列 $s$，那么序列 $s$就是序列 $b$的子序列。

如果序列 $s_1 , s_2 \ldots s_m$是递增的，则序列 $s_1, s_2, \ldots , s_m$称为递增序列。

**Input**

The first line contains a single integer $n$ ($1 \le n \le 10^6$).

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 5000$) — the elements of the array $a$.

### solve

==**考虑简单版本的问题: **==
**状态设计:**
$f_{i , j}$ 表示,枚举到i时 , 其亦或和为j的最小尾部.
**状态转移方程:**
枚举$f_{i - 1 , j}$ , 考虑在这些序列中拼接上$a_i$ , 进行状态更新;

==**困难版本下的问题**==
针对，所有$a_i$的值域较小维护一些信息：

$f_{i , v}$ : 表示枚举到i尾段小于$v$的序列的可能取值。 显然用滚动数组实现，可以大幅度减少拷贝花费;
$f_{v} :$ 表示滚动到当前枚举元素时，所有序列中，满足末元素小于v ， 序列异或和的取值。

$kth_v$ ， 记录当前考虑的所有序列中， 异或和为v的方案的最小末元素。

**维护上述结构：**

每次考虑一个新的元素时，

**关于更新**

由上述定义，直接使用$f_v$的信息就可以得到新一轮合法的所有方案。但是如果每一次都大规模更新，其复杂度将是$O(N^3)$ : 枚举一个元素更新后方。

**维护花费上的优化**
观察发现，存在相当大部分更新是浪费的。可能曾经的更小尾巴，已经贡献过一次该异或和，已经没必要继续往上更新了。因此考虑一种维护方式，使得最终每一个$f_v$中的元素不会重复出现。

1. 怎么推断某一个后缀已经出现过该异或和？ 曾有一个较小的尾段贡献过该后缀（如果暴力的更新，显然是扫完所有后缀的。因为大尾巴的方案，兼容小尾巴的方案。）
2. 于是使用$kth_v$数组标记当前计算出的异或和为v的最小尾巴 ， 就可以知道$f_{j > kth_v}$  都已经被更新过。只需要更新未更新的部分。

**复杂度估计：**

$O(A^2 + N)$ 即1E6量级。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int M = 1 << 13;
const int N = 5010;
const int NN = 1E6 + 10;
// 记录尾段小于i , 可行异或值。
vector<int> f[N];
// 记录当前记录过i的最低：
int kth[M + 10];
int a[NN];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n; cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];

	for (int i = 0; i < M; i++) {
		kth[i] = 5001;
	}
	for (int i = 0; i <= 5000 ; i++) {
		f[i].push_back(0);
	}
	kth[0] = 0;
	for (int i = 1; i <= n; i++) {
		int v = a[i];
		while (f[v].size()) {
			// 取出当前f的所有异或和，进行更新。
			int s = f[v].back(); f[v].pop_back();
			int t = v ^ s;
			while (kth[t] > v) {
				f[kth[t]--].push_back(t);
			}
		}
	}
	vector<int> ans;
	for (int i = 0; i < M; i++) {
		if (kth[i] != 5001) {
			ans.push_back(i);
		}
	}
	cout << sz(ans) << "\n";
	for (auto x :  ans) {
		cout << x << " ";
	}
	cout << "\n";
}
```

