# C2. Dual (Hard Version)

[Problem - C2 - Codeforces](https://codeforces.com/contest/1855/problem/C2)

[Popskyy & tiasu - Dual](https://soundcloud.com/popskyy/popskyy-tiasu-dual)

给你一个整数数组 $a_1, a_2,\dots, a_n$（正数、负数或 $0$）。你可以对数组进行多种运算（可能有 $0$种运算）。
在一次操作中，您可以选择 $i, j$（$1 \leq i, j \leq n$，它们可以相等）并设置 $a_i := a_i + a_j$（即将 $a_j$加到 $a_i$）。
使数组在最多$31$次运算中不递减（即$a_i \leq a_{i+1}$次为$1 \leq i \leq n-1$次）。您不需要尽量减少运算次数。

### solve

典型的构造观察题：

1. 考虑一个简单的问题： 其实就是简单版本中的正解：对于全正或全负的数组的处理方式：
   1. 做一个前缀和或者后缀和：
2. 想到怎么将问题转换成上述问题： 用31次卡过去：事实上（由于长度为20 ， 1操作只花费19次，因此12次花费可以支配：）

3. 关注序列的正负情况： 数量分别为a  , b：（反之同理）
   1. a等于b。a , b中的绝对值最大者：容易解决问题 一共操作29次：
   2. a = 9 , b = 11: 取绝对值较大的一边，然后可以至多在11 + 19 = 30次类似上述情况：解决问题：
   3. a = 8 , b = 12 : 同上：12 + 19 = 31
   4. a = 7 , b = 13 : 现在其拥有更多的倍增机会， 为5（5 + 7 + 19 = 31）次倍增：（2 * 2 * 2 * 2 * 2 = 32）
   5. 后续同上：

### 生长思考：

不够敏锐： 

1. 意识到长度更短之后，倍增机会更多之后。进一步分类讨论，进行深化；
2. 并且要非常精准的把握住31次机会操作的特殊性。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;
const ll INF = 1E18 + 7;
const int N = 1E6 + 10;

void work(int testNo)
{
	int n;
	cin >> n;

	vector<int> a(n + 1);
	int mi = inf;
	int mx = -inf;
	int sum1 = 0, sum2 = 0;
	int idmx, idmi;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (a[i] > 0)sum1++;
		else if (a[i] < 0) sum2++;
		mi = min(a[i], mi);
		mx = max(a[i], mx);
	}

	vector<pair<int, int>> ans;
	auto pre = [&]() {
		for (int i = 2; i <= n; i++) {
			ans.push_back({ i , i - 1 });
		}
	};

	auto suf = [&]() {
		for (int i = n - 1; i >= 1; i--) {
			ans.push_back({ i , i + 1 });
		}
	};

	auto update1 = [&]() {
		for (int i = 1; i <= n; i++) {
			if (a[i] < 0) ans.push_back({ i , idmx });
		}
	};
	auto update2 = [&]() {
		for (int i = 1; i <= n; i++) {
			if (a[i] > 0) ans.push_back({ i , idmi });
		}
	};

	for (int i = 1; i <= n; i++) {
		if (a[i] == mx) idmx = i;
		if (a[i] == mi) idmi = i;
	};


	if (mi >= 0) {
		pre();
	}
	else if (mx <= 0) {
		suf();
	}
	else {
		if (sum1 == sum2) {
			if (abs(mi) >= mx) {
				update2();
				suf();

			}
			else {
				update1();
				pre();

			}
		}
		else if (abs(sum1 - sum2) <= 4) {
			if (mx > abs(mi)) {
				update1();
				pre();
			}
			else {
				update2();
				suf();
			}
		}
		else if (sum1 > sum2) {
			while (mx + mi < 0) {
				mx += mx;
				ans.push_back({ idmx , idmx });
			}
			update1();
			pre();
		}
		else {
			while (mx + mi > 0) {
				mi += mi;
				ans.push_back({ idmi , idmi });
			}
			update2();
			suf();
		}

	}
	cout << sz(ans) << "\n";
	for (auto p : ans) {
		cout << p.first << " " << p.second << "\n";
	}
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

