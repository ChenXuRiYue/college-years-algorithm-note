# A2. Burenka and Traditions (hard version)

https://codeforces.com/contest/1718/problem/A2

![image-20230716152638793](C:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20230716152638793.png)

## solve

### easy verson:

1. 一个贪心的角度： 任何一种操作都可以等效转换成一种模式： 若干个2 + 0 或者 1个 1的方式。
2. 探究解集： 发现任何方案可以转换成，从前到后依次处理每一个位置：

**状态设计：**

1. $f_{i,j } :$表示已经处理了前i位，当前第i位为j的最小代价:

**状态转移方程：**

1. 操作区间长度为1 ：$f_{i + 1 , a_{i + 1}} min( f_{i, j} ，f_{i + 1 , a_{i + 1}})$
2. 操作区间长度为2 ：$f_{i + 1 , a_{i + 1} \oplus j} = min(f_{i , j} + 1, f_{i + 1 , a_{i + 1} \oplus j})$

### code1 easy verson

```cpp
const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 5010;
const int M = 1 << 13;
int a[N];
int f[N][M + 10];
void work(int testNo) {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= M; j++) {
			f[i][j] = inf;
		}
	}
	f[1][a[1]] = 0;
	for (int i = 1; i < n; i++) {
		f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]] , f[i][0]);
		for (int j = 1; j <= M; j++) {
			f[i + 1][a[i + 1]] = min(f[i + 1][a[i + 1]] , f[i][j] + 1);
			f[i + 1][a[i + 1] ^ j] = min(f[i + 1][a[i + 1] ^ j] , f[i][j] + 1);
		}
	}
	int ans = f[n][0];
	for (int i = 1; i <= M; i++) {
		ans = min(ans , f[n][i] + 1);
	}
	cout << ans << "\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```


### hard verson

具体分析解集： 

1. x不是任意选。任何一个阶段，都是前面一大段的异或和。
2. 与普通的n个处理相比什么时候才有效果？
   1. 当某一个操作选择长度为2的区间，使得$a_{i + 1}$ 为0。就是优越的操作。
   2. 于是问题最多不相交的异或和为0的异或段。
3. 上述问题的解：
   1. 贪心，如果发现当前枚举的尾下 就立刻选：
   2. 其实就是一个非常经典的贪心问题。选取最早结束的线段。使得得到的不相交线段数最大。


### code2  hard verson

```cpp
int a[N];
void work(int testNo) {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	set<int> rec;
	int pre = 0;
	int ans = n;
	rec.insert(0);
	for (int i = 1;  i <= n; i++) {
		pre ^= a[i];
		if (rec.count(pre)) {
			rec.clear();
			pre = 0;
			ans--;
		}
		rec.insert(pre);
	}
	cout << ans << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

