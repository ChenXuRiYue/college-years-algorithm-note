# D. Ball Sorting
https://codeforces.com/contest/1839/problem/D

有 $n$个彩球排成一排。这些球被涂上$n$种不同的颜色，用数字从$1$到$n$表示。从左边开始的第$i$个球被涂上了$c_i$种颜色。你想重新排列球的顺序，使左起第 $i$个球的颜色是 $i$。此外，你还有颜色为 $0$的 $k \ge 1$个球，可以在重新排序的过程中使用。

由于球的奇特属性，它们只能通过执行以下操作来重新排序：

1.  将颜色为$0$的小球放在序列中的任意位置（任意两个连续小球之间、最左边小球之前或最右边小球之后），同时保持其他小球的相对顺序。由于只有 $k$个颜色为 $0$的球，因此您最多只能进行 $k$次这样的操作。
2.  选择任意一个颜色为**非零**的球，使得与其相邻的球中至少有一个颜色为$0$，然后将该球（颜色非零）移动到序列中的任意位置（任意两个连续的球之间、最左边的球之前或最右边的球之后），同时保持其他球的相对顺序。您可以任意多次进行此操作，但每次操作都要支付 $1$ 枚硬币。

您可以按照任意顺序执行这些操作。在最后一次操作之后，所有颜色为 $0$的球都会神奇地消失，留下一连串颜色不为 0 的 $n$个球。

为了使从左边开始的第$i$个球的颜色为$i$，从$1$到$n$的所有$i$个球的颜色都为$i$，第二种类型的操作至少需要花费多少硬币？**所有颜色为零的球消失后**？可以证明，在问题的约束条件下，总是有可能按要求重新排列球的顺序。

求解从 $1$到 $n$的所有 $k$。

### solve

**观察一些现象：， 研究解空间：**

1. 如果只放入一个0球，并且确定了位置，其最优策略是什么？

   放入一个求之后，意味着将选择0球附近的若干元素：都可以被放放入任意对应的位置。观察到，其实就是选择0球附近的段操作，整个序列将被划分成两段（空段也考虑进去），然后前后端升序关系。上述两段的球不需要被操作。

2. 因此最优的贪心思路是：

   1. k = 1 , 选择一段后，A + B + C； A 与 C中满足，整体上是上升的关系。并且使得总数最大。

   2. 推广到k段；

      去除一些段之后，使得总体上剩余的一些段整体呈上升关系且总数最大。

**状态定义**

$f_{i , j}$ : 表示选择以$a_i$ 为尾部， 将数组去掉j段。剩余整体上升的序列元素的最大个数。

**状态转移方程：**
$f_{i , j} <- f_{i-1,j} + 1$   ==IF==   $a_i> a_{i -1}$
$f_{i ,j} <- f_{k , j - 1} + 1$ ==IF==   $a_{i} > a_{k}$ && $k \ge j - 1$
**初始化：**
1.  暴力初始化：不优雅但是稳妥：
1.  巧妙地始终j = 0 的状态。如果是非上升的，前缀是非上升的初始化为0 ， 否则就是前缀长度。
**计算答案：**
确定球数 ： sum 
枚举上升序列终点： $f_{i , sum - 1}$ 即可：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()

const int inf = 1E9 + 7;;
const ll INF = 1E18 + 7;
const int N = 510;


void cmax(int& x , const int y) {
	if (x < y) x = y;
}
void solve() {
	int n;
	cin >> n;

	vector<vector<int>> f(n + 1 , vector<int>(n + 1 , 0));
	vector<int> a(n + 1);

	bool flag = true;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		flag = flag && (a[i] > a[i - 1]);
		if (flag) f[i][0] = f[i - 1][0] + 1;
	}
	// 有点模糊感：
	for (int j = 1; j <= n; j++) {
		for (int i = j + 1; i <= n; i++) {
			f[i][j] = 1;
			if (a[i] > a[i - 1]) cmax(f[i][j] , f[i - 1][j] + 1);
			for (int pos = i - 1; pos >= j; pos--) {
				if (a[i] > a[pos]) cmax(f[i][j] , f[pos][j - 1] + 1);
			}
		}
		// cout << "k :: " << j << "\n";
		// for (int i = 1; i <= n; i++)
		// 	cout << f[i][j] << " \n"[i == n];
	}
	// for (int i = 1; i <= n; i++) {
	// 	cout << "k : " << i << "\n";
	// 	for (int j = 1; j <= n; j++) {
	// 		cout << f[j][i] << " \n"[j == n];
	// 	}
	// }
	// 可以为空段：
	int mx = f[n][0];
	// int mx = 0;
	for (int j = 1; j <= n; j++) {
		cmax( mx , f[n][j]);
		for (int i = j; i < n; i++) {
			cmax(mx , f[i][j - 1]);
		}
		cout << n - mx << " \n"[j == n];
	}
}


signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	while (t--) solve();
}
```
