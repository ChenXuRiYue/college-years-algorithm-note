#### 问题简介

```txt
给定n。找出一个长度为n的数组。该数组满足：
1.奇数位置之间的数，做xor运算等于偶数位上做xor运算
2.数组之中的数字，两两不同。
```

#### 分析

```txt
异或（xor运算）：相同结果为0，不同结果则为1。
对于整体上众多数的亦或运算中。对于一个位，如果是奇数，那么数就是1，如果是偶数这位上就是0。
按照某种规律，奇数位上放奇数位，偶数上放偶数位。对于最后这两位进行特殊的处理。如果n是奇数，就特殊的把0放在最后一位。如果是偶数，就进行就特殊处理奇数的最后一位保证第一位上的1有偶数个。
```

##### solve

```txt
贪心，有规律的选择一些数：
对于奇数组选择  3 5 7 9 11 .....
对于偶数组选择  2 4 6 8 10 .....
发现相同数量的贡献之后，
比特位上 ：  2，，，，31位上是完全相同的。
对于一组，当贡献次数为偶数数次数时。第一位也是相同的。
       ，当贡献次数为奇数次数时，第一位的1贡献次数的奇偶性不一致
        让总多数中某一个少贡献一，又不影响其它位置上的情况。就是选取对奇数组和中某一个数
        （将元素一一对应，然后更好的发现，并且检验操作的可行性，方向性。）
        取对应的偶数，防止重复，直接在一些不可能遭遇的位置上加一个足够大的权。再去选取一个位置，加上该权
        抵消掉，使该为xor运算结果为0。
        
如果n为奇数。直接在最后补一个0即可。
```

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 2e5 + 10;
ll p[33];
ll ans[maxn];
void solve()
{
    int n;
    cin >> n;
    for (int i = 1, j = 3; i <= n; i += 2, j += 2)
        ans[i] = j;
    for (int i = 2, j = 2; i <= n; i += 2, j += 2)
        ans[i] = j;
    if (n & 1)
        ans[n] = 0;
    if ((n / 2) & 1)
        ans[1] = 2 + p[30], ans[3] += p[30];
    for (int i = 1; i <= n; i++)
        cout << ans[i] << ' ';
    cout << '\n';
}
int main()
{
    int t;
    cin >> t;
    p[1] = 1;
    for (int i = 2; i <= 31; i++)
        p[i] = p[i - 1] * 2;
    while (t--)
        solve();
}
```



