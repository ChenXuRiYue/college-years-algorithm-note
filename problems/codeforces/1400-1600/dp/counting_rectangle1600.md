#### 问题简介

```txt
给定一系列的正方形（rectangle）,现在有q个询问：
对于每一个询问，给出两个正方形
求能满足包住第一个正方形，被第二个正方形包住的正方形的面积和。
```

#### 题解：

```txt
动态规划：
f(i,j)表示，记录了众多正方形之中，满足a<=i,b<=j的正方形的面积和。
答案最终会是 ans=f[c-1][d-1]-f[a-1][b-1];//表示重复h为a宽度为b的正方形的总面积。
状态迁移，求出指标函数
迁移：
   f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];至于其它的贡献，恰好贴边的类型在输入数据的时候就已经贡献。
   a.b.c.d
ans=f[c-1][d-1]-f[a][d-1]-f[c-1][b]+f[a-1][b-1];
这里一个个指标相当于一个集合，要仔细观察这一个集合，去重，去冗余的解。

体会：
首先最重要，最具有启发性的，是寻找一个存储来记录一些解。称为子问题的指标函数。（子问题的解）
然后对它们进行转移。这就是总的思路，这和递推的思维模式，一直都存在。
难题就在于
1.寻找相邻规模子问题的状态的转移关系。
2.初始化状态。
```

###### code

```cpp
const int maxn = 1e3 + 10;
ll f[maxn][maxn];
int a, b, c, d;
void solve(){
    memset(f, 0, sizeof(f));
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++){
        cin >> a >> b;
        f[a][b] += a * b;
    }
    for (int i = 1; i <= 1000; i++)
        for (int j = 1; j <= 1000; j++)
            f[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1];
    for (int i = 1; i <= q; i++){
        cin >> a >> b >> c >> d;
        cout << f[c - 1][d - 1] - f[c - 1][b] - f[a][d - 1] + f[a][b] << '\n';
    }
}
int main(){
    int t;
    cin >> t;
    while (t--)solve();
}
```

