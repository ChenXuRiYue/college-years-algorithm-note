# D2. Zero-One (Hard Version)
https://codeforces.com/contest/1733/problem/D2

参考题解：
https://www.luogu.com.cn/blog/endlesscheng/solution-cf1733d2
https://codeforces.com/blog/entry/83109

You are given two binary strings *a* and *b*, both of length *n*. You can do the following operation any number of times (possibly zero).

- Select two indices *l* and *r* (*l*<*r*).
- Change $(1 - a_l)$ and $a_r$ to $1 - a_r$
- If *l*+1=*r*, the cost of the operation is *x*. Otherwise, the cost is *y*.

You have to find the minimum cost needed to make *a* equal to *b* or say there is no way to do so.

## solve

### solve 1: $O(N^2)$

~~比O(N)的还复杂,性价比不高~~

### solve 2 : $O(N)$

首先做分类讨论。

1. y <= x : 容易解决； 如下代码：
2. y > x :

预处理： 对每个$a_i \ne b_i$的位置记录有序成一个数组。并且在这个数组的基础上进行dp。

**状态定义**

$f_i$ 表示将前i项处理完的最小代价。

**状态转移**

1. 当前选择非相邻的方式消除。
   1. $f_i -> f_{i - 1} + \frac{y}{2}$  // 这里使用了一些精妙地代价计算地方法。
2. 当前选择不断地向前相邻重置消除。
   1. $f_i -> f_{i -2} + (p_i - p_{i - 1})$

**初始化：**

1. $f_0 = 0 ,f_1 = y$

**处理一些困惑：**

1. 对于y/2能否不引入double，直接处理。可以先对所有地贡献项数乘上2。最后只需要将答案除于2即可。
   1. 一定是偶数吗？ y必定有偶数个。，因为y的转移涉及了奇数偶数的转换。奇数问题的求解，有奇数个第一次操作。（从记忆化搜索的角度来看。）
   
2. 为什么x总是和前面的位置进行第x操作相消？
   1. 如果是选当前i之前的元素进行操作，贪心的来看，选择最近是最优的，转移法证明，
   

还有一些疑惑： 其非相邻的选择方式中可以考虑一些更后方的没有考虑过的点。这很奇怪， 和自己经验冲突了。



#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
	int n;
	ll x ,  y;
	cin >> n >> x >> y;
	vector<int> pos;
	string s , t;
	cin >> s >> t;
	for (int i = 0; i < n; i++)
		if (s[i] != t[i]) {
			s[i] = '1';
			pos.push_back(i);
		} else s[i] = '0';
	int m = pos.size();
	if (m & 1) {
		cout << -1 << "\n";
		return;
	}
	if (y <= x) {
		if (n >= 5) {
			if (m == 2 && pos[0] == pos[1] - 1) {
				cout << min(2 * y , x) << "\n";
			} else {
				cout << m / 2 * y << "\n";
			}
		} else {
			// 无语了。
			if (s == "0110")
				cout << min(3 * y , x) << "\n";
			else if (s == "110" || s == "011" || s == "11")
				cout << x << "\n";
			else if (s == "1100" || s == "0011") cout << min(x , 2 * y) << "\n";
			else cout << m / 2 * y << "\n";
		}

	} else {
		//接下来特殊的用dp解决。

		vector<ll> f (m + 2 , 0);
		f[0] = 0; f[1] = y;
		for (int i = 2; i <= m; i++) {
			f[i] = min(f[i - 2] + (pos[i - 1] - pos[i - 2]) * x * 2 , f[i - 1] + y);
		}
		cout << f[m] / 2 << "\n";
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t; cin >> t;
	while (t--)solve();
}
```

