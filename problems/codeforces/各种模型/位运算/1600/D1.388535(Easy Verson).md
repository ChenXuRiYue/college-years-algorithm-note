https://codeforces.com/contest/1658/problem/D1

找出一个数字x，数组$a_i$

使得$a_i\quad xor \quad x$成一个排列。(0...r)



#### 20mins

唯一的突破是翻译了问题，

并且发现两两不同的数字xor同一个数字，最终也必然不相同。



solve

排列结构，xor运算。

挖掘一个性质。性质展示如下：

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int oo = 0x0fffffff;
const int N = 1E6 + 10;


void work(int testNo)
{

	int l , r;
	cin >> l >> r;
	int rec[32][2] {};

	for (int i = 0; i <= r; i++) {
		int x;
		cin >> x;
		for (int j = 0 ; j <= 30; j++, x >>= 1)
			rec[j][x & 1]++;
	}
	int ans = 0;
	for (int j = 0; j <= 30; j++) {
		ans |= ((rec[j][1] > rec[j][0]) * (1 << j));
	}
	cout << ans << '\n';
}


int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```


#### 生长思考：

最后只是研究这种模型找出一个结论。应该规划到位运算下。

几点认识：

- 为了成一个排列，超出范围的1的位必然是由X带来的。

- 对这个排列的每一个结构都xor X。对于某一个位置上：0的个数必然是不少于1的。

  - 简单证明如下。研究某位置上。假设y在第i位上为1。那么将该位置变成0之后也在范围之内。并且按照这样的匹配方式不会产生冲突。

  - 在变化过程中，对于某一个特定的位置：如果当前x的位置上选择1。那么0，1变化。此时$sums(1)>=sums(0)$否则

    相反。sum(0)>=sum(1);

- 对于另外一个角度：当两者的数目相同时。无论选择哪个当前位置上选择哪个本质都一样。还是像上面一样的匹配思维。



综上，排列意味着xor的资源。xor运算的特性。关注每一位置上的0，1个数情况。















