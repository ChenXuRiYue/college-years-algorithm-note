# D1. Xor-Subsequence

https://codeforces.com/contest/1720/problem/D1
https://codeforces.com/contest/1720/problem/D2

### 简介：

给定一个数组：$a_i$ ,选出0 .... (n - 1)的子序列满足：
$$
a_{b_p} \oplus b_{p+1} < a_{b_{p+1}} \oplus b_p
$$
找出该子序列的最大长度：

### solve

特殊的: 简单版本中每个元素小于200。启发 ：枚举一个数字被这个范围的数字至多影响为 +-256（事实上会更小一点）。 因此当$b_p$ 足够小时，$b_{p + 1} - b_{p} > 516$ 。 $a_{b_p} , a_{b_{p + 1}}$ 无论怎么调护，都不会使得大小左右大小关系转化。因此只需要枚举增量为516附近的元素即可。

### code

```cpp
int a[N];
void work(int testNo)
{
	int n;
	cin >> n;
	int mx = 0;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		mx = max(a[i] , mx);
	}
	vector<int> f(n , 1);
	int ans = 0;
	for (int i = 1; i < n; i++) {
		for (int j = max(0 , i - m); j < i; j++) {
			if ((a[j] ^ i) < (a[i] ^ j)) {
				f[i] = max(f[i] , f[j] + 1);
			}
		}
		ans = max(f[i] , ans);
	}
	cout << ans << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
```

## hard verson

进阶：$a_i$ 推广到了一般的$10^9$。上述的结论就不再适用：

1. 一个优化角度： 怎么将限制转变成单方面的限制？ 即，当确定i , $a_i$之后，就可以从知道从哪些状态转移？ 换而言之，记录状态关注更深刻的属性。

考察这个运算系统：
$$
a_{j} \oplus i < a_{i}\oplus  j
$$


集中精力解决得问题是：当前已经确定了$i , a_i$ ， j , $a_j$ 应该符合什么条件？尝试一个参数，容易记录。

设置 X= $a_j \oplus i$ , $Y = a_i \oplus j$ 。 假设对于同一个位，它们的上的比特分别是：
$$
a_j : A\\
i:B\\
a_i:C\\
j: D\\
$$

从X， Y高位开始考察： 假设前k位是相同的：
有：$A\oplus B=C\oplus D$ 移项得 ， $A\oplus D = B\oplus C$ 。
考察第k + 1 位（第一个不同的位）： $A\oplus B < C\oplus D$ 。总结得：

1. $A=B$
1. $C\ne D$
1. $A=B=C$ 或 $A=B=D$

1. 当$B= 1 ， C= 1$时：  $A= 1 , D = 0$
2. 当$B = 1 , C =0时:$    $A= 1  , D = 1$  
3. 当$B = 0 , C = 1$时:    $A = 0 , D = 0$
4. 当$B = 0 , C = 0$时：   $A = 0, D = 1$

总结：
$$
若B\oplus C =1 则 A\oplus D = 0\\
若B\oplus C = 0 则A\oplus D = 1\\
$$
维护用字典树$a_i \oplus i$ ，的01比特串。同时维护比特状态下的最大值即可。  

### jls's code

```cpp

#include <bits/stdc++.h>

using i64 = long long;

constexpr int N = 300000 * 31;

int cnt;
int trie[N][2];
int f[N][2];

int newNode() {
	++cnt;
	trie[cnt][0] = trie[cnt][1] = 0;
	f[cnt][0] = f[cnt][1] = 0;
	return cnt;
}
void solve() {
	int n;
	std::cin >> n;

	std::vector<int> a(n);
	for (int i = 0; i < n; i++) {
		std::cin >> a[i];
	}
	cnt = 0;
	newNode();

	std::vector<int> dp(n);
	for (int i = 0; i < n; i++) {
		int x = a[i] ^ i;
		int p = 1;
		for (int j = 29; j >= 0; j--) {
			int v = x >> j & 1;
               // 为什么向f[trie[p][!p]][i >> j & 1] 转移？
               //  这个也是一一对应的。
               // 即使是异或和下也对应了两种状态。表示A的取值。而发现，一一对应项A和B是相等的
               //                                         i >> j & 1 对应B
 			dp[i] = std::max(dp[i], f[trie[p][!v]][i >> j & 1]);
			p = trie[p][v];
			if (!p) {
				break;
			}
		}
		dp[i]++;
		p = 1;
		for (int j = 29; j >= 0; j--) {
			int v = x >> j & 1;
			if (!trie[p][v]) {
				trie[p][v] = newNode();
			}
			p = trie[p][v];
            	// a[i] >> j 对应A
			int &res = f[p][a[i] >> j & 1];
			res = std::max(res, dp[i]);
		}
	}
	int ans = *std::max_element(dp.begin(), dp.end());
	std::cout << ans << "\n";
}

int main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);

	int t;
	std::cin >> t;

	while (t--) {
		solve();
	}
	return 0;
}
```



### 生长：

1. 怎么使用字典树？

   关注jls的几个主要操作：

   1. 初始化：

      ```cpp
      cnt = 0;
      newNode();
      ```
   
   2. 查询：
   
      ```cpp
      int p = 1;
      for (int j = 29; j >= 0; j--) {
          int v = x >> j & 1;
          // 为什么向f[trie[p][!p]][i >> j & 1] 转移？
          //  这个也是一一对应的。
          // 即使是异或和下也对应了两种状态。表示A的取值。而发现，一一对应项A和B是相等的
          //                                         i >> j & 1 对应B
          dp[i] = std::max(dp[i], f[trie[p][!v]][i >> j & 1]);
          p = trie[p][v];
          if (!p) {
              break;
          }
      }
      ```
   
   3. 插入
   
      ```cpp
      p = 1;
      for (int j = 29; j >= 0; j--) {
          int v = x >> j & 1;
          if (!trie[p][v]) {
              trie[p][v] = newNode();
          }
          p = trie[p][v];
          // a[i] >> j 对应A
          int &res = f[p][a[i] >> j & 1];
          res = std::max(res, dp[i]);
      }
      ```
   
   4. 建立新节点：以及基本结构
   
      ```cpp
      int cnt;
      int trie[N][2];
      int f[N][2];
      
      int newNode() {
      	++cnt;
      	trie[cnt][0] = trie[cnt][1] = 0;
            // 维护的信息。
      	f[cnt][0] = f[cnt][1] = 0;
      	return cnt;
      }
      ```
   
   5. 封装成一个板子：
   
      详细看字典树笔记： [字典树.md](..\..\..\..\..\Logrithm\string\字典树\字典树.md) 

