### $\huge 2021周赛江西$

- chenjiuri201

#### $\large A:Mio visits ACGN Exhibition$

```
走网格问题。
网格上遍布1，0；
从1，1开始往下走，问有多少种走法，达到n,m
同时满足条件，路径上经历的1和0的数目达到
q以及p个。
```

#### 20min

```txt
考虑动态规划。
dp[n][m][p][q];
直接爆破；
```

#### 参考

```txt
第一个优化 ：经历的过程中，发现p+q<=n+m;
所以两者不会太大。 p 1000  :   q 1000;
另外发现
看到这一点，算法复杂度优化为 n*m*1000*1000; 依然爆破。
还有一个角度，非黑即白的发现。两种状态的数目和总是等于 x+y;(两个方向上行走的距离。)
所以只需要对一个做讨论，经历1的个数即可。

此时优化到：       n*m*1000.n*n勉强可以卡过去了。

但是从空间上看：   空间复杂度依然是 高达 1e8.

这里可以用滚动数组来优化。
保存两行即可，一个是当前计算的行，一个是上一行。
关于怎么将它们转化；
可以通过一个now来表达；now=1;
发生转行时，就now^=1就达到了一种转化。

最后的问题，怎么进行初始化？？

```

-----

#### $code：$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5e2 + 10;

int f[2][maxn][maxn << 1]; //第二个表示第几列
int now;
int s[maxn][maxn];
int mod = 998244353;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m, p, q;
    cin >> n >> m >> p >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> s[i][j];

    if (s[1][1])
        f[1][1][1] = 1;
    else
        f[1][1][0] = 1;
    for (int i = 1; i <= n; i++)
    {
        now ^= 1;
        for (int j = 1; j <= m; j++)
        {
            if (i == 1 && j == 1)
                continue;
            if (s[i][j])
            {
                f[now][j][0] = 0;
                for (int k = 1; k <= i + j - 1; k++) // k的下界应该取什么？
                    f[now][j][k] = (f[now][j - 1][k - 1] + f[now ^ 1][j][k - 1]) % mod;
            }
            else
                for (int k = 0; k <= i + j - 1; k++)
                    f[now][j][k] = (f[now][j - 1][k] + f[now ^ 1][j][k]) % mod;
        }
    }
    ll ans = 0;
    for (int i = q; i <= n + m - 1 - p; i++)
        ans = (ans + f[now][m][i]) % mod;
    cout << ans << '\n';
}
```

#### 代码地细节回顾

- $first：$ 初始化， 注意对$f(1,1)$这一个点初始化。并且对该点特判。本来的想法是，统一步骤，对$f[0][0][0]$这个初始化。但是由于这里并不是普通的数组。后面的转移中也会再次用到这一个似乎用不到位置。但事实上，会影响转移。

- $second：$注意滚动数组上，是多个重叠的。要及时更新。当$s[i][j]=1$的时候，迁移更新不涉及$d[now][j][0]$事实上，它保存着前两列的$d[now][i-2][j][0]$;

#### 生长思考：

- 还要取$mod$的这一种，不要妄想通过一个分类讨论计算来解出问题。
- 思路前进，源于当前成果，也源于优化。
  - 明确当前应该使用动态规划来进行计算。
  - 明确当前问题的方向是，动态规划。所以向上一步，不断地解决空间的问题，优化循环迁移等等。

- 记忆化搜索不能使用滚动数组，所以相对来说，是从动态规划中抽象出二重循环，是动态规划的基本能力。防止卡空间。减少常数。数位$dp$并没有采取该种策略，一般可以使用二维数组就很好的实现，是因为它的对应的记忆空间一般较小。



-----



#### $\large H.\quad Hearthstone So Easy$

```
两个人玩游戏：
n,k.
初始生命值为 n；
一个人一轮会失去大小等于虚弱值得血量。这个虚弱值增加一倍。
经历上一轮之后，两人有两种选择，一是，处理让对手扣除k得血量.二是，让自己增加k得血量。
```

#### 20min

```
游戏是公平的，最先出牌的人虚弱值越来越高，最后越来越容易扛不住。

采取某一种策略：
后手如果没有死，可以保持生命值相等。
那么最终必然是先手先死。

如果第一次先手的攻击没有杀死后手。
后面的轮数保持相等。
假设这样持续下去，先手终于死了。
假设历经其中的某一轮，先手可以杀死后手。
s+k>n;
但是两者的血量相等，上一轮中由于后手还没有死，这样就可以有策略使先手受到该大小的伤害。
这样先手是输的。

综上所，用一个完整的判定条件应该是，先手第一轮就杀死了后手。

注意特判，血量为1的情况：
```

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;

void solve(){
    int a, b;
    cin >> a >> b;
    if (a == 1)
    {
        cout << "freesin" << '\n';
        return;
    }
    if (b + 1 >= a)
        cout << "pllj" << '\n';
    else
        cout << "freesin" << '\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int t;
    cin >> t;
    while (t--)
        solve();
}
```

#### 生长思考：

- 博弈问题中，如同这一种，深搜基本上做不了。
- 向这一种，后手追求某一种策略，先手追求某一种策略。看是否发现什么东西。

- 上面这个思路，也可以参见[even number addics](https://codeforces.com/problemset/problem/1738/C)，题解编号chenjiuri101；用typroa搜索一下。

