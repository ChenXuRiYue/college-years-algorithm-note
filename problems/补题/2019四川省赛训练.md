#### A

[addressing](https://codeforces.com/group/cQGUBWxrFs/contest/399752/problem/A)

题目大意:

```
Autochess
一个一维棋盘上。
对于棋子，有两种属性： name and level（最多有三级）
每次放置棋子，我们放等级为1的棋子
当我们把它放在棋盘中时，有三种情况；
1.如果当前盘中已经有同名的棋子，且该棋子的等级为3不放这个手上的棋子。开始选择下一个棋子的放置。
2.当，同名的一级棋子已经有k-1个。盘上k-1个棋子将消失。手上的棋子的等级将上升一级。依次类推，2级变三级。
3.在最左边的空位上，放置该棋子。
```

##### 概况

```txt
吐了，一直用一些数据结构来优化。但是stl用的不够熟练。一堆指针，有一些地方出错。
进行实践优化的时候也出现了一些问题。
```

$第一个垃圾代码\quad code$

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int maxn = 2e5 + 10;
int t = 0;
typedef pair<string, int> p;

void solve()
{
    priority_queue<int, vector<int>, greater<int>> que;
    map<string, int> mmap;
    map<string, queue<int>> ad;
    int m, n, k;
    cin >> m >> n >> k;
    vector<string> a(n + 1);
    for (int i = 1; i <= n; i++)
        a[i] = "-1", que.push(i);
    for (int kk = 1; kk <= m; kk++) //消除上花了很多的时间。
    {
        string s;
        cin >> s;
        string temp = s;
        int level = 1;
        if (mmap.count(s) == 0)
            mmap.insert({s, 0});
        auto p = mmap.find(s);
        //来一个分类讨论？？
        //第一个发展。
        if (mmap[temp + '3'])
            continue;
        //第二个发展
        if (p->second == k - 1)//当前数组中，有一级s的个数
        {
            level++;
            p->second = 0;
            auto pp = mmap.find(s + '2');//用来看当前2级的量的个数
            auto ptr1 = ad.find(s);
            while (!ptr1->second.empty())
            {
                a[ptr2->second.front()] = "-1";
                ptr2->second.pop();
            }
            if (pp->second == k - 1)//当前二级串的数量为k-1.
            {
                level = 3;
                auto ppp = ad.find(s + '2');
                while (!ppp->second.empty())
                {
                    a[ppp->second.front()] = "-1";
                    ppp->second.pop();
                }
                s = s + '3';
            }
            else
                s = s + '2';
        }
        mmap[s]++;
        int next = que.top();
        que.pop();
        a[next] = s;
        ad[s].push(next);
    }
    cout << "Case " << t << ": ";
    for (int i = 1; i < n; i++)
        cout << a[i] << ' ';
    cout << a[n] << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n;
    cin >> n;
    for (t = 1; t <= n; t++)
        solve();
}
```

- $情况总结$

```txt
由于程序量比较庞大，容易忽略一些问题
删掉 s+'2'类型之后没有及时更新 mmap[s+2]//计数用的一个stl容器。导致后面出现不可控的结果。（即使算法设计正确但是没有，实现到位。大模拟常态。比较长的代码，书写的时候，比较容易出现错误。）
删除一个数，把数组中的某一个元素变成-1之后，没有及时更新空位。
```

##### $ac\quad code$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;
int t = 0;
typedef pair<string, int> p;
void solve(){
    priority_queue<int, vector<int>, greater<int>> que;
    map<string, int> mmap;
    map<string, queue<int>> ad;
    int m, n, k;
    cin >> m >> n >> k;
    vector<string> a(n + 1);
    for (int i = 1; i <= n; i++)
        a[i] = "-1", que.push(i);
    for (int kk = 1; kk <= m; kk++) //消除上花了很多的时间。
    {
        string s;
        cin >> s;
        string temp = s;
        int level = 1;
        level = 1;
        if (mmap.count(s) == 0)
            mmap.insert({s, 0});
        auto p = mmap.find(s);
        //来一个分类讨论？？
        //第一个发展。
        if (mmap[temp + '3'])
            continue;
        //第二个发展
        if (p->second == k - 1)
        {
            level++;
            p->second = 0;
            auto pp = mmap.find(s + '2');
            auto ptr2 = ad.find(s);
            while (!ptr2->second.empty())
            {
                a[ptr2->second.front()] = "-1";
                que.push(ptr2->second.front());
                ptr2->second.pop();
            }
            if (pp->second == k - 1)
            {
                pp->second = 0;
                level = 3;
                auto ppp = ad.find(s + '2');
                while (!ppp->second.empty())
                {
                    a[ppp->second.front()] = "-1";
                    que.push(ppp->second.front());
                    ppp->second.pop();
                }
                s = s + '3';
            }
            else
                s = s + '2';
        }
        mmap[s]++;
        int next = que.top();
        que.pop();
        a[next] = s;
        ad[s].push(next);
    }
    cout << "Case " << t << ": ";
    for (int i = 1; i < n; i++)
        cout << a[i] << ' ';
    cout << a[n] << '\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n;
    cin >> n;
    for (t = 1; t <= n; t++)
        solve();
}
```

#### 回顾tips

- 各种存储结构的作用

```txt
mmap<string,int> :             当前的某一个串的出现次数。
ad   <string,vector<int>>      存储某个串出现的地址（用一个queue常数应该比vector小）
priority_queue<int> que        存储空位的数据结构。同时可以保证，第一个空位可以快速得到。
```





------

#### [Inventory](https://codeforces.com/gym/102821/problem/I)

```txt
就是给出一组 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10....sn
构造一组数   v1 v2 v3 v4 v5 v6 v7 v8 v9 v10....vn
     其中  sum of(vi)=V;
求出  s1/v1+s2/v2+......+sn/vn
```

##### 题解

```txt
数论，柯西不等式。
数学问题，没有学明白。我的小学以100分作为结尾.初中以104分，高中以90分。而大学以84分作为结尾。
是很精妙但是，我会恐惧。
```

##### CODE

```CPP
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;
int t = 0;
void solve(){
    int n, v;
    cin >> n >> v;
    long double ans = 0;
    for (int i = 1; i <= n; i++)
    {
        double a;
        cin >> a;
        ans += sqrt(a);
    }
    cout << "Case " << t << ": ";
    cout << fixed << setprecision(6) << (ans * ans) / v << '\n';
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int tt;
    cin >> tt;
    while (tt--)
        t++, solve();
}
```











