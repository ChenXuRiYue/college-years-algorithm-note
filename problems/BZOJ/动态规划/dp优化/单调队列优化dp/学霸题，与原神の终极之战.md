###  学霸题，与原神の终极之战

#### 题目来源：

1.  bzoj
2. 省赛筛选赛问题：

#### introduces

![image-20230425234401381](image-20230425234401381.png)

#### solve

**状态定义：**

$f_{i}$表示 ， 到达 i 点时 最低疲劳数。

**转移方程：**
$$
f_{i} = min(f_{i - k -1.......i -1} + (a_j <= a_i))
$$
**初始化：**

$f_1 =1$

**优化角度**

1. 对转移方程优化一下： 发现函数都是增加1的。因此最多只需要变化1即可。由于转移中只涉及1的常量。选最小值即可：两种选择在结果上是等效的：
2. 然后就可以转换成单调队列问题：
   1. 对于同大小的指标函数对应的位置，尽量维护最大值。
   2. 上面有个小贪心成分。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ull = unsigned long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
int a[N];
ll f[N];
int que[N] , low , high;
int n;
void work(int testNo) {
	int k;
	cin >> k;
	fill(f  , f + n + 1 , INF);
	f[1] = 0;
	low = 0;
	high = -1;
	for (int i = 2; i <= n; i++) {
		while (low <= high && i - que[low]  > k)low++;
		while (low <= high) {
			if (f[que[high]] > f[i - 1])high--;
			else if (f[que[high]] == f[i - 1] && a[que[high]] < a[i - 1])
				high--;
			else break;
		}
		que[++high] = i - 1;
		f[i] = f[que[low]] + (a[que[low]] <= a[i]);
	}
	cout << f[n] << "\n";
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int t; cin >> t;
	for (int i = 1; i <= t; i++)work(i);
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```