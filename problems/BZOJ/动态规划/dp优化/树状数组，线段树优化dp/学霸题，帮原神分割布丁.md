# 学霸题，帮原神分割布丁

## 题目描述

$N(1\leq N\leq 10^5)$ 个布丁，第 i 个布丁的甜度为 $A_i(-10^9\leq A_i\leq 10^9)$。

现在原神要从左往右依次吃掉一段连续的布丁。如果连续一段布丁的甜度总和为负数，那么原神就会痛苦。

请问使得原神享用完所有布丁并且不痛苦的方案数。输出方案数 $\mod 1e9 + 9$（注意!!!）。

## 输入格式

第一行：一个整数 $N$

第二行：$N$ 个整数 $A_i$，分别表示第 $i$ 个补丁的甜度

## 输出格式

输出一个整数表示布丁的划分方案数 $\mod 1e9 + 9 $的结果

## 样例 #1

### 样例输入 #1

```
4
2
3
-3
1
```

### 样例输出 #1

```
4
```

## 提示

样例解释：一共 4 种分割方案:[2 3 -3 1]、[2] [3 - 3 1]、[2 3 -3][1]、[2][3 -3] [1]。

时间限制：2s

空间限制：128MB

## solve

**状态定义：**

$f_i$以， 前缀和为$s_i$ 为前缀中 ， 内部划分的方案数。

**状态转移：**

枚举到某一个位置： 根据其前缀， 更新其它$s_i$的答案。最终的解为。对小于等于$s_{last}$的状态做一次求和。



实现上：

1.  离散化。
2. 维护前缀和 ， 可以用树状数组， 线段树。

#### 生长：

1. 离散化找到了一个更加好看的写法。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll = long long;
using i64 = long long;
using ld = long double;
using uint = unsigned int;
using pii = pair<int , int>;
using pli = pair<ll , int>;
using pll = pair<ll , ll>;

#define dbg(x) cerr << "[" << __LINE__ << "]" << ": " << x << "\n"

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define pb push_back
#define fi first
#define se second

const int inf = 1 << 29;
const ll INF = 1LL << 60;
const int N = 1E6 + 10;
const int mod = 1E9 + 9;

int a[N] , id[N];
int n;
ll sum[N];
ll c[N];

void modify(int x , ll d) {
	for (; x <= n; x += -x & x) {
		c[x] = (c[x] + d) % mod;
	}
}
ll query(int x) {
	ll res = 0;
	for (; x; x -= -x & x) {
		res = (res + c[x]) % mod;
	}
	return res;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++) {
		sum[i] = sum[i - 1] + a[i];
	}
	//然后做离散化。
	sort(sum + 1 , sum + n + 1);
	int last = unique(sum + 1 , sum + n + 1) - sum;
	ll pre = 0;
	for (int i = 1; i <= n; i++) {
		pre += a[i];
		id[i] = lower_bound(sum + 1, sum + last , pre) - sum;
	}
	for (int i = 1; i < n; i++) {
		ll d = (sum[id[i]] >= 0) + query(id[i]);
		modify(id[i] , d);
	}
	ll res = query(id[n]) + (sum[id[n]] >= 0);
	cout << res % mod << "\n";
}
/* stuff you should look for
* int overflow, array bounds
* special cases (n=1?)
* do smth instead of nothing and stay organized
* WRITE STUFF DOWN
* DON'T GET STUCK ON ONE APPROACH
*/
```

