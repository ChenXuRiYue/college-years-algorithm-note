#### 920

#### 问题简介

```txt
语音打印机出现了一些我问题：语音打印机，就是把语音转化为文字。
正常情况下，它是没有问题的。
现在出现一下问题：
m   -》  n，n
w   -》  u, u
同时意味着，不可能出现  m和w。

求出所有可能的真实字符串：
并对结果对1e9+7取模。

字符串长度为 1e5;
```

##### 20min分析

```txt
就是关注连续的n n 和u  u
对上面进行计数.
问题转化为
对于一个串，前后两两当成一个整体，可以变化为多少个整体？
f[i]  记录以当前第i个为后一位，共有种上述的分发。
f[i]=f[i-2]+f[i-1]//分别表示，当前这个位置于前面的位置选或者不选。

分步乘法计数即可。
```

##### code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 10;
ll f[maxn];
ll mod = 1e9 + 7;
string s;
int n;
int c_u(int now){
    while (now <= n && s[now] == 'u')
        now++;
    return now;
}
int c_n(int now){
    while (now <= n && s[now] == 'n')
        now++;
    return now;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> s;
    n = s.length();
    s = '#' + s;
    f[0] = 1;
    f[1] = 1;
    for (int i = 2; i <= n; i++)
        f[i] = (f[i - 1] + f[i - 2]) % mod;
    ll ans = 1;
    bool flag = false;
    for (int i = 1; i <= n; i++){
        if (s[i] == 'w' || s[i] == 'm'){
            flag = true;
            break;
        }
        if (s[i] == 'u'){
            int temp = c_u(i);
            ans = ans * f[(temp - i)] % mod;
            i = temp - 1;
        }
        if (s[i] == 'n'){
            int temp = c_n(i);
            ans = ans * f[temp - i] % mod;
            i = temp - 1;
        }
    }
    if (flag)
        cout << 0 << '\n';
    else
        cout << ans << '\n';
}
```