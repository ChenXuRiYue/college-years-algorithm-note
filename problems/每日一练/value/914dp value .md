##### 简述

```
给出两个整数：N，M。求出满足三个条件的序列的数量。对mod=998244353取模。
三个条件要求如下：
1.长度为n。
2.每个元素在1到M的范围之内。
3.最长上升序列的长度为3。
```

######  借鉴思路

- 动态规划

  ```tcl
  状态定义：
  dp[i][a][b][c]。表示在长度为i的序列之中，最长上升子序列中，长度为1的最小序列末尾为a。长度为2的序列中最小末尾为b.长度为3的最末尾为c。满足上条件的序列的数量。同时肯定也要满足题意中的一些条件。
  
  状态迁移方程：比如说现在放进一个k。枚举所有可以更新的相关状态，对该状态做贡献。
  dp[long][a][b][c];
  第一类贡献  dp[long-1][i][b][c]。 a<=i<=b;
  第二类贡献  dp[long-1][a][j][c]。 b<j<=c;
  第三类贡献  dp[long-1][a][b][k]。 c<k<=m; 
  从这一个贡献的视角。
  发现f[b][b][c]类的一定为0.在总多之中相当于没有。根据t的顺序。
  
  换一个角度可以这样看：
  枚举小规模，的子问题来计算它们对更大规模的问题的解。
  当枚举完这些子问题之后，下一个规模的子问题就被枚举完成了。
  
  dp[long-1][a][b][c]---> dp[long][t][b][c],t<=a;
                     ---> dp[long][a][t][c],a<=t<=b;
                     ---> dp[long][a][b][t],b<=t<=c;
                     
  
  是否有其它类型的贡献？
  不一定只关注有最长上升子序列长度为3的类型，只关注一也可以关注2关注3.
  当 a=b 或者b=c时，就不符合状态的定义。这些情况下，它的解是指，该情况下
  
  怎么进行初始化？
  初始化问题：  长度为0长度为1长度为2长度为3都没有合法解。长度为3确定了就可以正常进行。
  当初始化f[0][m+1][m+1]=1时，不小规模的问题f[0][a][b][c],f[1][a][b][c]....f[2][a][b][c],f[3][a][b][c]的状态的解是正确的。
  ```

### code

```cpp
#include<bits/stdc++.h>
using namespace std;

int f[1010][13][13][13];
int mod=998244353;
int main()
{
    int n,m;
    cin>>n>>m;
    f[0][m+1][m+1][m+1]=1;
    for(int i=1; i<=n; i++)
        for(int a=1; a<=m+1; a++)
            for(int b=a; b<=m+1; b++)
                for(int c=b; c<=m+1; c++)
                    for(int t=1; t<=m; t++)
                    {
                        if(t<=a)
                        {
                            f[i][t][b][c]+=f[i-1][a][b][c];
                            f[i][t][b][c]%=mod;
                        }
                        else if(t<=b)
                        {
                            f[i][a][t][c]+=f[i-1][a][b][c];
                            f[i][a][t][c]%=mod;
                        }
                        else if(t<=c)
                        {
                            f[i][a][b][t]+=f[i-1][a][b][c];
                            f[i][a][b][t]%=mod;
                        }
                    }
    long long ans=0;
    for(int i=1; i<=m; i++)
        for(int j=i+1; j<=m; j++)
            for(int k=j+1; k<=m; k++)
            {
                ans+=f[n][i][j][k];
                ans%=mod;
            }
    cout<<ans<<'\n';
}

```

##### 生长思考

- 怎么样可以更好的去想出动态规划方程？

