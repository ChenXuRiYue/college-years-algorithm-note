##### 题目简介

```txt
现在有两个人，每一个人手上都有一个森林。现在他们都进行一种操作。
为它们的树林上添加边。
有如下要求
1.它们添加的边要一致。即，如果添加（u,v），那么另外一个加上(u,v)这一条边。
2.要保证一系列的操作之后，两个图都还是一个森林。
```

##### 20min

```txt
对于，一棵树的内部，如果将他们相连，不再是森林
找出一组点，在两个森林中都属于不同的树。
当我我们找到这样一组点的时候，是否要立刻合并呢？
是否有就选就是最优的选法？
```

##### 题解

```txt
   如果两个点能进行合并，就立刻进行合并。这样就是最优答案。
最终边数比较多的图，一定连成了一棵树。

   结论证明，
假设a，b可以连接。
将a和b连接之后，1对以上不再可连。
受到影响的几对不能相连，说明了连上a,b之后，在某一个森林之中，几对之间处于同一颗树之中。同理，当选择其它的方案,会有同样数量的方案失去。所以是每一种选择是平等的。一遇到可行方案直接处理即可。直到把所有的方案全都枚举完。


方式一
并查集+暴力搜索；直接搜索所有的边的组合。大概是O(n^2)直接炸穿。

方式二：
先处理，以节点1为根部。与1，在两个森林中都可以连接的，就直接连接。
\\
剩下的都是一些树满足条件，在另外一个森林中，和1上的树都不相连。
\\可以发现，在剩下的树上找。
\\数量上，一个可建立的边的数量就是联连通图较少的连通图的数量。
注意后续的处理过程之中，有一些处理之后，直接和1相连。
因为找到的点之中，在另外一张图找到的点之中，在第一个森林中，肯定是和相连的。
```

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 10;

class union_find
{
public:
    int fa[100000 + 10]; //父节点
    int ra[maxn];
    union_find() //初始化
    {
        for (int i = 1; i < 100000 + 10; i++)
            fa[i] = i, ra[i] = 0; //初始化父节点以及等级。
    }
    int find(int x)
    {
        return fa[x] == x ? x : find(fa[x]);
    }
    void unit(int x, int y)
    {
        x = find(x);
        y = find(y);
        if (ra[x] < ra[y])
            swap(x, y);
        fa[y] = fa[x];
        ra[x]++;
    }
    bool same(int x, int y)
    {
        x = find(x);
        y = find(y);
        return x == y;
    }
};

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, m1, m2;
    cin >> n >> m1 >> m2;
    union_find u1, u2;
    for (int i = 1; i <= m1; i++)
    {
        int a, b;
        cin >> a >> b;
        u1.unit(a, b);
    }
    for (int i = 1; i <= m2; i++)
    {
        int a, b;
        cin >> a >> b;
        u2.unit(a, b);
    }
    int ans = n - 1 - max(m1, m2);
    cout << n - 1 - max(m1, m2) << '\n';
    for (int i = 2; i <= n; i++) //先把与一可连的先连上。
        if (!u1.same(i, 1) && !u2.same(i, 1))
        {
            cout << i << ' ' << 1 << '\n';
            ans--;
            u1.unit(i, 1), u2.unit(1, i);
        }                            //处理好这一类的点，进行下一类的点的处理。
    for (int i = 2, j = 2; ans; i++) //寻找两个点，满足，不是同一个，不在同一颗树上。两个点分别在在两个子图中不与1联通。
    {
        if (u1.same(i, 1))
            continue;
        while (u2.same(j, 1))
            j++; //找到一组点。
        cout << i << ' ' << j << '\n';
        ans--;
        u1.unit(i, 1), u2.unit(j, 1);
    }
}
```

