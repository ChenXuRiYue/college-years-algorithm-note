



##### 问题简介

```txt
给定一个图（not graranteed the graph is contected），该图有一些边已经确认了方向。而 有一些还没有。尝试给每一个边确认方向。得到一个有向无环图。
如果可以，输出yes并且打印，方案。如果不行就输出no。
```

###### 20min

```txt
分析样例：
样例四不行是因为，最后一个圈，无论如何都是哪个反向都作为一个闭环。
怎么判断，是否必定不可以变成一个有向，无环的图？
又如何构造？
对于一些边，只能染一种颜色，对于另外一些边，两种不能染色。
对于一些边的染色，可能使得某些边两种颜色都不能染色的问题。
```

##### 题解

```txt
发现，如果图已经成环，那么就是no。
否则就可以构造出一个有向无环图。具体的构造方法：从拓扑序比较小指向拓扑序大的可以保证没有环出现。
关于，判断是否有环，直接用拓扑排序，找出一个拓扑序，把结果利用即可。
但是看题意参考代码出现了一些疑惑。
```



##### 分析参考代码

```cpp
Firstly, if the graph consisting of initial vertices and only directed edges contains at least one cycle then the answer is "NO". Otherwise, the answer is always "YES". Let's build it. Let's build the topological sort of the graph without undirected edges. Then let's check for each directed edge if it's going from left to right (in order of topological sort). If it isn't true then there is a cycle and the answer is "NO". Otherwise, let's direct each edge from left to right in order of the topological sort.

Solution
#include <bits/stdc++.h>
using namespace std;

vector<int> ord;
vector<int> used;
vector<vector<int>> g;

void dfs(int v) {
	used[v] = 1;
	for (auto to : g[v]) {
		if (!used[to]) dfs(to);
	}
	ord.push_back(v);
}

int main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
//	freopen("output.txt", "w", stdout);
#endif
	
	int t;
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;
		g = vector<vector<int>>(n);
		vector<pair<int, int>> edges;
		for (int i = 0; i < m; ++i) {
			int t, x, y;
			cin >> t >> x >> y;
			--x, --y;
			if (t == 1) {
				g[x].push_back(y);
			}
			edges.push_back({x, y});
		}
		
		ord.clear();
		used = vector<int>(n);
		for (int i = 0; i < n; ++i) {
			if (!used[i]) dfs(i);
		}
		vector<int> pos(n);
		reverse(ord.begin(), ord.end());
		for (int i = 0; i < n; ++i) {
			pos[ord[i]] = i;
		}
		bool bad = false;
		for (int i = 0; i < n; ++i) {
			for (auto j : g[i]) {
				if (pos[i] > pos[j]) bad = true;
			}
		}
		if (bad) {
			cout << "NO" << endl;
		} else {
			cout << "YES" << endl;
			for (auto [x, y] : edges) {
				if (pos[x] < pos[y]) {
					cout << x + 1 << " " << y + 1 << endl;
				} else {
					cout << y + 1 << " " << x + 1 << endl;
				}
			}
		}
	}
	return 0;
}
```



```txt
这一个dfs是否保证了，拓扑序的要求？使得每一个元素，如果，一个节点到另外一个元素，那么必然，边的终点的拓扑序更加大？
显然上面的参考
单纯的一个dfs是不可以保证的关键在于，最终对这一个vector or进行了reverse的操作。
5->4->1->2->3;
这样的顺序。上述dfs方法得到的结果是
3 2 1 4 5
最终转一下
5 4 1 2 3
如果一条线的起点先被检索。就是正常的一个序。高级的在后面，低级的在前面。反转一下，就变成了高级的在前面，低级的在后面。
如果并非如此。对于后面一大段，低级的在前面，高级的在后面。
然后处理前面的段的时候，也是高级的在后面，低级的在前面。
从整体上看，也保证了高级的在前面，低级的在后面。
反转一下，就是正确的拓扑序了。
如果出现了闭环，在遍历的我们从这个环的某一个点进行拓扑。在这一个分界上，必然出现矛盾。这样，我们就可以判断了出现环的情况。
```

##### mycode//其实几乎是一模一样的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;

vector<int> order;
vector<vector<int>> g;
bool passed[maxn];
int pos[maxn];

void topo(int u)
{
    passed[u] = true;
    for (auto i : g[u])
        if (!passed[i])
            topo(i);
    order.push_back(u);
}
void solve()
{
    int n, m;
    cin >> n >> m; //分别代表节点数，以及边数。
    vector<pair<int, int>> e;
    g.resize(n);

    for (int i = 1; i <= m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        b--, c--;
        if (a)
            g[b].push_back(c);
        e.push_back({b, c});
    }
    for (int i = 0; i < n; i++)
        if (!passed[i])
            topo(i);
    reverse(order.begin(), order.end()); //倒转。
    for (int i = 0; i < n; i++)
        pos[order[i]] = i;
    //下面进行判断有无重环
    bool ok = true;
    for (int i = 0; i < n; i++)
        for (auto j : g[i])
            if (pos[i] > pos[j])
                ok = false;
    //下面进行输出
    if (ok)
    {
        cout << "YES" << '\n';
        for (auto i : e)
        {
            if (pos[i.first] < pos[i.second])
                cout << i.first + 1 << ' ' << i.second + 1 << '\n';
            else
                cout << i.second + 1 << ' ' << i.first + 1 << '\n';
        }
    }
    else
        cout << "NO" << '\n';

    //下面进行初始化
    g.clear();
    order.clear();
    memset(passed, 0, sizeof(passed));
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int t;
    cin >> t;
    while (t--)
        solve();
}
```

###### 生长思考

```txt
1.可以，扩充关于topo模板的思考。
2.猜结论的角度： 知道解决什么问题很重要，构造解所涉及的元素具体的情况如何很关键。
             认识有向图，不妨去细节的认识各个节点的拓扑序。通过它们的拓扑序来解决问题。
             比如该问题，确定边的方向，就是从拓扑序小的边连向拓扑序大的边。
   对于该问题的证明 ：
   假设，一个图没有闭环，根据拓扑序顺序来确定一些边的方向，相当于在原有的有向图之中加上一些边。
   假设由于按照规定的边，贡献了若干个环。对于一个环，说明原来就有一个由拓扑序小的点指向拓扑序较大的点。
   成环或与拓扑序的的定义矛盾。
```

