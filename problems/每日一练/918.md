#### 题意

```txt
有三组数，分别有数字k1,k2,k3个。数字范围是1--k1+k2+k3。每个数字仅出现一次。
一次操作使得，一个数字向另外两组转移。问使数域分为三份，分别出现在这三组数中，进行的操作的最小值是多少？
从小到大，分别在第一第二第三组数中。
1 2 3  
4 5 6
7 8 9
而
1 3 4
2 5 6
7 8 9
不合法。
1 2 3 4 5 6 7 8 9
wu
wu
也合法。

其它表述：
现在有三个队列，每个队列都有一堆的数。现在你要使得a队列里面的数为排列的前缀，c队列的数是排列的后缀，然后b队列是其他的数。每次操作你可以让一个数到另外的队列里面去，问你最少操作多少次，能够符合需求。
```



$20min$分析

```txt
暴力枚举的方法
枚举第一第二段的上界。最无脑子的实现是O（（k1+k2+k3）^2）
尝试优化
剪枝（寻找规律）
贪心 
1 5 可能采取的策略

二分答案。怎么check这一个次数是否可以达到一个实现？
check不容易设计。依然要暴力。也是O（n^2）的算法。

从要补多少个的角度开始计算。发现三个组之间共同需要补充的数的和就是答案。
为求最优解，每次的选择都是重复的。
当第二组的范围确定，k的范围也随之确定了。
如果花费比较小的代价完成了预处理，使用快速查询区间最小值的方法：01查询最优解。
但是预处理还是要o（n^2）的复杂度。                                                             
```

##### 滚去看题解

```txt
将三块分别排序，求出最长上升子序列长度。
ans=k1+k2+k3-lcs;

简单证明如下：
lcs中的各个数不用转移，对答案贡献为0.
假设有一个比ans还要小的数,可以得到一个满足题意的解。
如果最终的分配结构和假设结构中保持一致。那么显然答案一样，每一个部分的上界随之确定。
如果不一致，说明至少两组的上下界发生变化。

```

##### $code$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 10;
const int inf = 1e9;
int k[maxn], d[maxn];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int a, b, c;
    cin >> a >> b >> c;
    int n = a + b + c;
    for (int i = 0; i < n; i++)
        cin >> k[i];
    sort(k, k + a);
    sort(k + a, k + a + b);
    sort(k + a + b, k + a + b + c);
    //二分求最长上升子序列。、

    for (int i = 0; i <= n + 1; i++)
        d[i] = inf;
    int ans = 1;
    for (int i = 0; i < n; i++) //寻找第一个大于等于当前数的数组元素。
    {
        int low = 1, high = ans + 1;
        while (low < high)
        {
            int temp = (low + high) >> 1;
            if (d[temp] < k[i])
                low = temp + 1;
            else
                high = temp;
        }
        d[high] = k[i];
        if (high > ans)
            ans++;
    }
    cout << n - ans << '\n';
}
```



```生长思考
first 线段树的方法。
second 关于结论的证明。
```

