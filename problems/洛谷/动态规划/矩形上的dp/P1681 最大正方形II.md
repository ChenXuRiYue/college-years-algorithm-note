**P1681 最大正方形II（double experiences）**

[P1681 最大正方形II - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1681)

这种模型开发有限，但是也不大懂：

类似的问题如下：

[P1387 最大正方形 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1387)

### 最大正方形

#### solve

**状态定义**

定义$f_{i,j}$表示以， i , j 为右下角的的满足所有格子都是1的最大正方形边长。

定义$w_{i,j}$表示当前点向左走的最大距离。$h_{i,j}$表示向上走的最大距离。

**状态转移方程**

$f_{i,j}=min(f_{i-1,j-1},w_{i,j},h_{i,j})+(s_{i,j==1})$

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 10000 + 10;
int a[N][N] , f[N][N] , h[N][N] , w[N][N];


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];

			f[i][j] = min({f[i - 1][j - 1] , w[i - 1][j] , h[i][j - 1]}) + a[i][j];
			if (a[i][j])w[i][j] = w[i - 1][j] + 1 , h[i][j] = h[i][j - 1] + 1;
			ans = max(f[i][j] , ans);
		}
	cout << ans << '\n';
}
```



### 最大正方形二

#### solve

1. 关注到关注的解是正方形。

**状态定义**
定义左下角为$f_{i,j,0/1}$表示i , j作为右下角，该处为0/1的最大正方形的面积。

**状态转移**

如果当前位是0：

$f_{i,j,0} = min(f_{i-1,j-1,0} , f_{i-1,j,1},f_{i,j-1,1})+1$

如果当前位是1

$f_{i,j,1}=min(f_{i-1,j-1,1},f_{i-1,j,0},f_{i,j-1,0})+1$



和上述比较，在指标函数中，就已经有了一些与最大h ,最大w相关的长度。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 10000 + 10;

int a[N][N] , f[N][N][2];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m; cin >> n >> m;
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			if (a[i][j]) {
				f[i][j][1] = min({f[i - 1][j - 1][1] , f[i - 1][j][0] , f[i][j - 1][0]}) + 1;
				ans = max(f[i][j][1] , ans);
			} else {
				f[i][j][0] = min({f[i - 1][j - 1][0] , f[i - 1][j][1] , f[i][j - 1][1]}) + 1;
				ans = max(f[i][j][0] , ans);
			}

		}
	cout << ans << '\n';
}
```

