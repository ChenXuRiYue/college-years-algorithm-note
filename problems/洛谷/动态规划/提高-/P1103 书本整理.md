**P1103 书本整理**

[P1103 书本整理 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/solution/P1103)

### solve

用一种非常暴力的dp定义方法。把之前的解中可以关注的大多数属性都关注了。对于简单问题这总是可行：

###### **状态定义如下：**

$f_{i , j ,k}$表示：当前考虑了前i个，书架上的上一本书宽度为j， 已经使用丢掉了k本书的最小不整齐代价。

**状态转移方程如下**
$$
if(a[i]!=j)\\
f[i][j][k] = min(f[i][j][k] , f[i-1][j][k-1])\\
if(a[i]==j)\\
f[i][a[i]][k]=min(f[i-1][a[i]][k],f[i-1][j][k]+abs(j-w))\\
$$

###  code

-----
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;


const int N = 2E2 + 10;
const int inf  = 1E9 + 10;
//分别表示当前的尾数，当前去掉的书本的数目。
struct node {
	int h , w;
} a[N];
int f[N][N][N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , kk;
	cin >> n >> kk;

	for (int i = 0; i <= n; i++)
		for (int j = 0 ; j <= 200 ; j++)
			for (int k = 0; k <= kk; k ++) {
				f[i][j][k] = inf;
			}
	//cout << f[0][0][0] << '\n';
	for (int i = 1; i <= n; i++) {
		cin >> a[i].h >> a[i].w;
	}
	sort(a + 1 , a + 1 + n , [&](node & i , node & j) {
		return i.h < j.h;
	});

	for (int i = 1; i <= n; i++) {
		f[i][a[i].w][i - 1] = 0;
	}
	for (int i = 1; i <= n; i++) {
		//考虑状态怎么迁移。
		//当前新的状态可能由什么转移？
		for (int k = 1; k <= kk; k++)
			for (int j = 1; j <= 200; j++) {
				//f[i][j][k]->k = 0.是什么情况？
				f[i][j][k] = min(f[i][j][k] , f[i - 1][j][k - 1]);
			}
		for (int k = 0; k <= kk; k++ )
			for (int j = 0; j <= 200; j++) {
				f[i][a[i].w][k] = min(f[i][a[i].w][k] , f[i - 1][j][k] + abs(a[i].w - j));
			}
	}
	int ans = (1 << 29);
	for (int i = 0; i <= 200; i++) {
		ans = min(ans , f[n][i][kk]);
	}
	cout << ans << '\n';
}
```
