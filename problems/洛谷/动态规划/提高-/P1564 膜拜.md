#### **P1564 膜拜**

将一段01字符串分成若干段。对于每一段满足：一段中字符相同，或两种字符数量的差别不超过m。求出最少可以分成多少段。

### solve

线性dp ， 大概是属于被开发烂了的数组模型。但是事实上自己还是做的很慢。

1. **状态定义**

​			$dp_{i}$表示1....i最少可以分成多少段。	

2. **状态转移**

​			$dp_{i} = min(dp_{j}+1)$前提是j ... i合法。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3000;
int a[N];
int f[N];
int sum[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n , m;
	cin >> n >> m;
	fill(f + 1 , f + 1 + n , 100000000);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		sum[i] = sum[i - 1] + (a[i] == 1);
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= i; j++) {
			if (sum[i] - sum[j - 1] == i - j + 1 || sum[i] - sum[j - 1] == 0 || abs(i - j + 1 - 2 * (sum[i] - sum[j - 1])) <= m ) {
				f[i] = min(f[i] , f[j - 1] + 1);
			}
		}
	}
	cout << f[n] << '\n';
}
```

